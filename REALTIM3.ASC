DEFWRD "a-z"
$%0,E$,B+,N+,i-,u-,-t
' *********************************************************
' ****              Realtime 3D Motion Editor          ****
' ****             (c) 1990-1994 by B. Dunskus         ****
' *********************************************************
'
' V 3.46
' - defaultmÑûig keine Note offs
' - Bug beseitigt: Falsche Spurberechnung bei Input>32
' V 3.45
' - speichern alt produziert nu 3DS V 1.01 Format
' - nur aktive Spuren abspeichern
' - Signal-Nummer beim Laden mit einlesen, leere Signale Åberspringen
' - Midi-Ausgabe fÅr 64 Spuren umgebaut!
' V 3.44
' - Fehler bei ueberblend = 0 beseitigt
' - Fehler bei VOL Reset mit LFO beseitigt
' - Geschwindigkeit auf die haelfte reduziert, fuer LFO und MTR
' V 3.43
' - Input-Selektion von 1..64
' V 3.42
' - Dateiformat fÅr XYZ Dateien modifiziert fÅr Ausgabe der Spurnummern und
' - Versionsnummer im Dateiformat
' V 3.41
' - Bug bei Neuberechnung der XYK behoben
' V 3.40
' - Dateiformat fÅr XYZ Dateien repariert und fÅr Delight vorbereitet
' V 3.39
' - angepaût fÅr Geneva bei WINDOW_CREATE
'
DEFMOUSE 2
compiled!=FALSE
~TT?
version$="Version 3.46"
vdat$="30.10.1994"
pfad$=DIR$(0)
IF RIGHT$(pfad$)<>"\"
  pfad$=pfad$+"\"
ENDIF
CHDIR pfad$
IF NOT EXIST("realtim3.rsc")
  ON ERROR GOSUB rscnotfound
  CHDIR "realtime"
  ON ERROR
ENDIF
init_gem(1,0,"REALTIM3.RSC",65000,FRE(0)-100000)
fre%=FRE(0)!
init_variables
b%=fre%-FRE(0)
updatemenu
window=0
DEFMOUSE 0
ON MENU GOSUB menuevent
ON MENU MESSAGE GOSUB windowevent
ON MENU BUTTON 1,3,1 GOSUB buttonevent
ON MENU KEY GOSUB keyevent
lastmenu%=TIMER
' fill_window(3,TRUE)
DO
  ON MENU
  IF BIOS(1,3)
    midi_in
  ENDIF
  IF ext_maus! AND BIOS(1,1)
    ext_maus_check
  ENDIF
  IF mode<>stop AND TIMER-lastwork%>edtimer
    lastwork%=TIMER
    3d_timer
  ENDIF
  '  IF on_screen!(3)
  '  wuerfel_drehen
  ' ENDIF
LOOP
PROCEDURE menuevent
  mentitle%=MENU(4)
  @menujunction(MENU(5))
  @items_off
  @updatemenu
  @menu_off(mentitle%)
RETURN
PROCEDURE windowevent
  IF mode=stop
    w_alt=window
    window=MENU(4)
    SELECT MENU(1)
    CASE 20
      @rectanglelist(window,1,MENU(5),MENU(6),MENU(7),MENU(8))
      IF w_alt>0
        '        window=w_alt
        '      PRINT CHR$(7);
      ENDIF
      '     updatemenu
    CASE 21
      @openw(window)
      updatemenu
    CASE 22
      @closew(window)
      updatemenu
      window=0
    CASE 23,27,28
      @relocate(window)
    CASE 24
      IF MENU(5)>=4
        @scroll(window,FALSE,left(window),cols_in(window),ncols(window))
      ELSE
        @scroll(window,TRUE,upper(window),lines_in(window),nlines(window))
      ENDIF
    CASE 25
      @scroll(window,FALSE,left(window),cols_in(window),ncols(window))
    CASE 26
      @scroll(window,TRUE,upper(window),lines_in(window),nlines(window))
    ENDSELECT
    lastmenu%=TIMER
  ENDIF
RETURN
PROCEDURE buttonevent
  LOCAL object !,doubleclick!
  IF mode=stop
    LET doubleclick!=(MENU(15)=2)
    @wind_find(MENU(10),MENU(11))
    IF window=0
      IF deskaddr%>0
        object=OBJC_FIND(deskaddr%,0,5,MENU(10),MENU(11))
      ENDIF
      IF object>0
        @deskevent(deskaddr%,object)
      ELSE
        @items_off
        @deskbackground(desk%,deskaddr%)
      ENDIF
    ELSE
      @inworkspace(window)
    ENDIF
    @release_mouse
    @updatemenu
  ENDIF
RETURN
PROCEDURE deskevent(treeaddr%,object)
  IF OB_FLAGS(treeaddr%,object) AND 1
    @preselect(object)
    @change_desk(object,0)
  ENDIF
  @mouse_pos
  IF kmouse
    object=OBJC_FIND(treeaddr%,0,1,MENU(10),MENU(11))
    IF OB_FLAGS(treeaddr%,object) AND 1024
      @obj_offset(treeaddr%,object)
      @mouse_pos
      @graf_dragbox(xobj+xmouse-MENU(10),yobj+ymouse-MENU(11),wobj,hobj)
      IF destwind=0
        IF destobj=0 OR destparent=object
          @put_icon(object,xdest,ydest,"")
        ELSE
          @drag_onobj(treeaddr%,object,destobj,destparent)
        ENDIF
      ELSE
        IF destwind>0
          @drag_inw(treeaddr%,object,destwind,destcol,destline,xdest,ydest)
        ENDIF
      ENDIF
      IF OB_STATE(treeaddr%,object) AND 1
        @deselect(object,object)
        @change_desk(object,0)
      ENDIF
    ENDIF
  ELSE
    @deskobject(desk%,treeaddr%,object,doubleclick!)
  ENDIF
RETURN
PROCEDURE keyevent
  @keyboard(MENU(13),BYTE(MENU(14)),SHR(MENU(14),8))
RETURN
PROCEDURE items_off
  LOCAL object,window
  FOR window=1 TO nhandles
    IF active_in(window)>0
      item=active_in(window)
      active_in(window)=0
      @rectanglelist(window,3,xwork(0),ywork(0),wwork(0),hwork(0))
    ENDIF
  NEXT window
  @icons_off
RETURN
PROCEDURE icons_off
  IF deskaddr%>0
    treeaddr%=deskaddr%
    object=OB_HEAD(treeaddr%,object)
    IF object>=0
      REPEAT
        IF OB_STATE(treeaddr%,object) AND 1
          @deselect(object,object)
          @change_desk(object,5)
        ENDIF
        object=OB_NEXT(treeaddr%,object)
      UNTIL object=0
    ENDIF
  ENDIF
RETURN
PROCEDURE inworkspace(window)
  LOCAL xcoord,ycoord,column,item,oldactive%
  @relative_pos(window,MENU(10),MENU(11))
  item=line
  IF typew(window)<3
    IF MENU(10)-xwork(window)<ncols(window)*wchar
      IF MENU(11)-ywork(window)<lines_in(window)*hchar AND item<=nlines(window)
        IF typew(window)>0
          IF typew(window)=1
            oldactive%=active_in(window)
            active_in(window)=item
            @print_item(window,FALSE,oldactive%,FALSE)
          ELSE
            @invert_boolean(window,item)
          ENDIF
          @rectanglelist(window,3,xwork(0),ywork(0),wwork(0),hwork(0))
        ENDIF
        @click_in(window,column,item,doubleclick!)
      ENDIF
    ENDIF
  ELSE
    @graphclick(window,column,item,xcoord,ycoord,doubleclick!)
  ENDIF
RETURN
PROCEDURE rectanglelist(window,mode,xprev,yprev,wprev,hprev)
  LOCAL xoldbase,yoldbase
  ~WIND_UPDATE(1)
  @define_windbase           !Ñndert global xoldbase,yoldbase
  ~WIND_GET(window,11,xredr,yredr,wredr,hredr)
  WHILE wredr OR hredr
    IF RC_INTERSECT(xprev,yprev,wprev,hprev,xredr,yredr,wredr,hredr)
      @clip(1,xredr,yredr,wredr,hredr,xwindbase,ywindbase)
      ON mode GOSUB refill,reobject,reprintline
      @clip(0,xredr,yredr,wredr,hredr,xwindbase,ywindbase)
    ENDIF
    ~WIND_GET(window,12,xredr,yredr,wredr,hredr)
  WEND
  ~WIND_UPDATE(0)
RETURN
PROCEDURE refill
  LOCAL item,lastitem
  IF NOT (typew(window)<3 AND scrolldir<>0)
    @clear_area(0,0,wwork(window)-1,hwork(window)-1)
  ENDIF
  IF typew(window)<3
    IF scrolldir
      @fastscroll(scrolldir,window)
      item=upper(window)-(scrolldir>0)*(lines_in(window)-scrolldir)
      lastitem=item+ABS(scrolldir)-1
      @clear_area(0,(item-upper(window))*hchar,cols_in(window)*wchar-1,(lastitem-item+1)*hchar-1)
      scrolldir=0
    ELSE
      item=upper(window)+((yredr-ywindbase) DIV hchar)
      lastitem=upper(window)+((yredr-ywindbase+hredr) DIV hchar)
      lastitem=MIN(lastitem,upper(window)+lines_in(window)-1)
    ENDIF
    WHILE item<=lastitem AND item<=nlines(window)
      @print1item(window,item,FALSE)
      INC item
    WEND
  ELSE
    @graphic(window,(left(window)-1)*wcell(window),(upper(window)-1)*hcell(window))
    DEFTEXT ,,,standard_font%
  ENDIF
RETURN
PROCEDURE reobject
  LOCAL xbox,ybox,wbox,hbox
  xbox=xredr
  ybox=yredr
  wbox=wredr
  hbox=hredr
  @obj_draw(object,depth%)
RETURN
PROCEDURE reprintline
  @print1item(window,item,FALSE)
RETURN
PROCEDURE donothing
RETURN
PROCEDURE prepare_action(window,appear!)
  IF on_screen!(window)
    action!=TRUE
  ELSE
    IF appear!
      @openw(window)
    ENDIF
    action!=FALSE
  ENDIF
RETURN
PROCEDURE print1item(window,item,printer!)
  LOCAL item$,invert!
  LOCAL mptr%,firstcol%,text$
  @make_itemstring(window,item)
  IF LEN(item$)<ncols(window)
    item$=item$+SPACE$(ncols(window)-LEN(item$))
  ELSE
    item$=LEFT$(item$,ncols(window))
  ENDIF
  IF printer!
    LPRINT item$
  ELSE
    @vditext(window,item,1," "+item$+" ")
    ' op dit punt kan worden afgetakt als men een deel van de regel in een
    ' andere letterstijl wil overprinten
    IF item=active_in(window) OR invert!
      fill_rect(3,(item-upper(window))*hchar+1,MIN(cols_in(window),ncols(window))*wchar-4,hchar-3)
    ENDIF
  ENDIF
  DEFTEXT ,0
RETURN
PROCEDURE sliders(window)
  @slider(window,TRUE,upper(window),lines_in(window),nlines(window))
  @slider(window,FALSE,left(window),cols_in(window),ncols(window))
  IF infscroll!(window)
    @infscroll(window)
  ENDIF
RETURN
PROCEDURE slider(window,vertical!,first,visible,total)
  LOCAL size%,position%
  first=MAX(MIN(first,total-visible+1),1)
  IF total>visible THEN
    size%=visible*1000/total
    position%=(first-1)*1000/(total-visible)
  ELSE
    size%=1000
    position%=1
  ENDIF
  IF vertical!
    upper(window)=first
  ELSE
    left(window)=first
  ENDIF
  IF (attributes(window) AND 2048+1792*vertical!)>0
    @setslider(window,vertical!,size%,position%)
  ENDIF
RETURN
PROCEDURE setslider(handle%,vertical!,size%,position%)
  ~WIND_SET(handle%,15-vertical!,size%,0,0,0)
  ~WIND_SET(handle%,8-vertical!,position%,0,0,0)
RETURN
PROCEDURE infscroll(window)
  LOCAL txtaddr%,column
  txtaddr%=titlemem%+480+80*(window-1)
  column=MAX(MIN(left(window),78)-1,0)
  IF BYTE{txtaddr%+79}<>column
    POKE txtaddr%+79,column
    ~WIND_SET(window,3,SWAP(txtaddr%+column),txtaddr%+column,0,0)
  ENDIF
RETURN
PROCEDURE fastscroll(scrolldir,window)
  LOCAL yrect,hrect,ydest,copy$
  yrect=ywork(window)-(scrolldir>0)*scrolldir*hchar
  hrect=(lines_in(window)-ABS(scrolldir))*hchar-1
  ydest=ywork(window)-(scrolldir<0)*ABS(scrolldir)*hchar
  RC_COPY XBIOS(3),xwork(window),yrect,wwork(window),hrect TO XBIOS(3),xwork(window),ydest
RETURN
PROCEDURE scroll(window,vertical!,first,visible,total)
  LOCAL oldfirst
  oldfirst=first
  IF MENU(1)=24
    IF MENU(5) AND 2
      ADD first,2*(MENU(5) AND 1)-1
    ELSE
      ADD first,2*(visible-1)*(MENU(5) AND 1)-visible+1
    ENDIF
    first=MAX(MIN(first,total-visible+1),1)
  ELSE
    first=SHR&(3+MENU(5)*(total-visible)/500,1)
  ENDIF
  IF first<>oldfirst
    IF ABS(first-oldfirst)<lines_in(window) AND typew(window)<3
      IF ywork(window)+hwork(window)<ywork(0)+hwork(0)
        scrolldir=first-oldfirst
      ENDIF
    ENDIF
    IF vertical!
      upper(window)=first
    ELSE
      left(window)=first
      scrolldir=0
    ENDIF
    @fill_window(window,TRUE)
  ENDIF
RETURN
FUNCTION selected(o)
  '  $F%
  RETURN OB_STATE(treeaddr%,o) AND 1
ENDFUNC
PROCEDURE init_gem(firstmenu%,firstdesk%,rscfile$,size_rscfile%,varmem%)
  '  GEMSYS 109          ! mit TOS1.4 werden damit alle Fenster geschlossen
  IF FRE(0)<size_rscfile%+2000
    EDIT
  ENDIF
  RESERVE -size_rscfile%-960
  rscfile$=DIR$(0)+"\"+rscfile$+CHR$(0)
  @rscload(rscfile$)
  @init_hnumbers
  void=RSRC_GADDR(0,0,adr_mainrsc%)
  '  void=OBJC_DELETE(0,droteben)
  '  void=OBJC_ADD(adr_rotrsc%,0,0)
  titlemem%=MALLOC(960)
  IF XBIOS(4)<2                      ! wenn das Programm nur in Monochrom
    @form_alert(rt_nolowres%,1)        ! laufen soll, mÅssen diese Zeilen
    EDIT                               ! aktiviert werden.
  ENDIF
  IF FRE(0)<varmem%
    @form_alert(rt_nomemory%,1)
    EDIT
  ENDIF
  IF compiled!
    ON ERROR GOSUB crash
  ENDIF
  DIM xcoord(6),ycoord(6),width(6),height(6),full!(6),on_screen!(6),typew(6)
  DIM oldxcoord(6),oldycoord(6),oldwidth(6),oldheight(6),infscroll!(6)
  DIM xwork(6),ywork(6),wwork(6),hwork(6),active_in(6),wcell(6),hcell(6)
  DIM upper(6),nlines(6),lines_in(6),left(6),ncols(6),cols_in(6),attributes(6)
  ~WIND_UPDATE(1)
  ~WIND_GET(0,4,xwork(0),ywork(0),wwork(0),hwork(0))
  DEFFILL ,2,4
  PBOX xwork(0)-1,ywork(0)-1,wwork(0)+xwork(0),hwork(0)+ywork(0)
  DEFFILL ,1
  '
  ' ####################### Hier Anpassung fÅr Farbmodi ######################
  IF XBIOS(4)<2                                 ! lÑuft das Programm in Farbe
    @rscaddress(tree,0)                        ! Adress des Desktop holen
    FOR s=1 TO 100                             ! 100 Objekte durchsuchen
      IF OB_TYPE(treeaddr%,s)=31               ! ist es ein ICON
        OB_H(treeaddr%,s)=OB_H(treeaddr%,s)*2 ! Hîhe
        OB_Y(treeaddr%,s)=OB_Y(treeaddr%,s)*2 ! und Breite verdoppeln
      ENDIF
    NEXT s
  ENDIF
  ' ##########################################################################
  '
  rscaddress(desktop,0)
  rscaddress(1,1)
  ~FORM_CENTER(treeaddr%,xbox,ybox,wbox,hbox)
  @switch_desk(firstdesk%)
  @switch_menu(firstmenu%)
  @getcharsize
  ~WIND_UPDATE(0)
  @reserve_handles
  @read_mcode
RETURN
PROCEDURE read_mcode
  LOCAL byte%
  RESTORE mcdata
  mcode$=""
  DO
    READ byte%
    EXIT IF byte%=-1
    mcode$=mcode$+CHR$(byte%)
  LOOP
mcdata:
  DATA 38,111,0,4,36,111,0,8,62,47,0,12,83,71,74,71,109,0,0,20,112
  DATA 0,16,18,212,252,0,1,54,128,214,252,0,2,81,207,255,240,78,117,-1
RETURN
PROCEDURE exit
  IF deskaddr%>0
    @switch_desk(-1)
  ENDIF
  @menu_bar(FALSE)
  ~MFREE(titlemem%)
  ~RSRC_FREE()
  window=nhandles
  WHILE window>0
    @closew(window)
    ~WIND_DELETE(window)
    DEC window
  WEND
  CLOSEW 0
  CLS
  GEMSYS 109
  EDIT
RETURN
PROCEDURE crash
  LOCAL er%
  ' ***  crash   ***
  DEFMOUSE 0
  IF ERR>=0
    @edit_alert(rt_error%,1,STR$(ERR),"")
    @exit
  ENDIF
  er%=ABS(ERR)
  IF er%=4 OR er%=8 OR er%=10 OR er%=11 OR er%=16
    @form_alert(rt_fatal%,1)
  ELSE
    ~FORM_ERROR(er%)
  ENDIF
  @exit
RETURN
PROCEDURE make_window(window,type%,title$,info$,flag!,attributes,xcoord,ycoord,width,height,ncols,nlines)
  IF WIND_CREATE(attributes,xwork(0),ywork(0),wwork(0),hwork(0))<>window
    '    ERROR 83
  ENDIF
  INC nhandles
  @set_typew(window,type%)
  attributes(window)=attributes
  @titlew(window,title$)
  @infow(window,info$,flag!)
  xcoord(window)=((xcoord*wwork(0)) DIV 1000)+xwork(0)
  ycoord(window)=((ycoord*hwork(0)) DIV 1000)+ywork(0)
  IF (attributes AND 36)=0
    @wind_calc(0,window,0,0,width*wcell(window),height*hcell(window))
    width(window)=wcalc
    height(window)=hcalc
  ELSE
    width(window)=(width*wwork(0)) DIV 1000
    height(window)=(height*hwork(0)) DIV 1000
  ENDIF
  @windowsize(window,wcell(window),hcell(window))
  ncols(window)=ncols
  nlines(window)=nlines
RETURN
PROCEDURE set_typew(window,type%)
  typew(window)=type%
  IF typew(window)<3
    wcell(window)=wchar
    hcell(window)=hchar
  ELSE
    @set_cellsize(window)
  ENDIF
RETURN
PROCEDURE attributext(info%)
  LOCAL txtaddr%,column
  IF (attributes(window) AND (1+15*info%))>0
    txtaddr%=titlemem%+480*info%+80*(window-1)
    CHAR{txtaddr%}=LEFT$(text$,77)
    IF info%=1
      IF infscroll!(window)
        column=MAX(MIN(left(window),78)-1,0)
      ENDIF
      POKE txtaddr%+79,column
    ENDIF
    ~WIND_SET(window,2+info%,SWAP(txtaddr%+column),txtaddr%+column,0,0)
  ENDIF
RETURN
PROCEDURE define_windbase
  xoldbase=WORD{WINDTAB+64}
  yoldbase=WORD{WINDTAB+66}
  ~WIND_GET(window,4,xwindbase,ywindbase,dummy,dummy)
RETURN
PROCEDURE lift_point00
  WORD{WINDTAB+64}=xwork(window)-hor%
  WORD{WINDTAB+66}=ywork(window)-ver%
RETURN
PROCEDURE define_workspace(window)
  ~WIND_GET(window,4,xwork(window),ywork(window),wwork(window),hwork(window))
  CLIP  OFFSET xwork(window),ywork(window)
  IF (MENU(1)<>21 AND MENU(1)<>28) OR appear!
    set_cellsize(window)
    LET lines_in(window)=hwork(window) DIV hcell(window)
    cols_in(window)=wwork(window) DIV wcell(window)
    @sliders(window)
  ENDIF
RETURN
PROCEDURE openw(window)
  IF window<=nhandles
    IF on_screen!(window)
      ~WIND_SET(window,10,0,0,0,0)
    ELSE
      ~WIND_OPEN(window,xcoord(window),ycoord(window),width(window),height(window))
      LET on_screen!(window)=TRUE
    ENDIF
    @define_workspace(window)
  ENDIF
RETURN
PROCEDURE relocate(window)
  IF NOT full!(window)
    oldxcoord(window)=xcoord(window)
    oldycoord(window)=ycoord(window)
    oldwidth(window)=width(window)
    oldheight(window)=height(window)
  ENDIF
  IF MENU(1)=23
    IF full!(window)
      xcoord(window)=oldxcoord(window)
      ycoord(window)=oldycoord(window)
      width(window)=oldwidth(window)
      height(window)=oldheight(window)
      full!(window)=FALSE
    ELSE
      xcoord(window)=xwork(0)
      ycoord(window)=ywork(0)
      width(window)=wwork(0)
      height(window)=hwork(0)
      full!(window)=TRUE
    ENDIF
  ELSE
    xcoord(window)=MENU(5)
    ycoord(window)=MENU(6)
    width(window)=MENU(7)
    height(window)=MENU(8)
    IF width(window)<wwork(0) OR height(window)<hwork(0)
      full!(window)=FALSE
    ELSE
      full!(window)=TRUE
    ENDIF
  ENDIF
  @windowsize(window,wcell(window),hcell(window))
  ~WIND_SET(window,5,xcoord(window),ycoord(window),width(window),height(window))
  @define_workspace(window)
RETURN
PROCEDURE relocate_key(window)
  IF window>0 AND window<7
    IF NOT full!(window)
      oldxcoord(window)=xcoord(window)
      oldycoord(window)=ycoord(window)
      oldwidth(window)=width(window)
      oldheight(window)=height(window)
    ENDIF
    IF menu1=23
      IF full!(window)
        xcoord(window)=oldxcoord(window)
        ycoord(window)=oldycoord(window)
        width(window)=oldwidth(window)
        height(window)=oldheight(window)
        full!(window)=FALSE
      ELSE
        xcoord(window)=xwork(0)
        ycoord(window)=ywork(0)
        width(window)=wwork(0)
        height(window)=hwork(0)
        full!(window)=TRUE
      ENDIF
    ELSE
      '    xcoord(window)=MENU(5)
      '   ycoord(window)=MENU(6)
      '   width(window)=MENU(7)
      '   height(window)=MENU(8)
      '   IF width(window)<wwork(0) OR height(window)<hwork(0)
      '   full!(window)=FALSE
      ' ELSE
      '  full!(window)=TRUE
      '  ENDIF
    ENDIF
    @windowsize(window,wcell(window),hcell(window))
    ~WIND_SET(window,5,xcoord(window),ycoord(window),width(window),height(window))
    @define_workspace(window)
  ENDIF
RETURN
PROCEDURE windowsize(window,wcell,hcell)
  @wind_calc(1,window,xcoord(window),ycoord(window),width(window),height(window))
  IF typew(window)<3
    ADD xcoord(window),4-SHR&(xcalc+4,3)
  ENDIF
  IF NOT full!(window)
    ADD width(window),SHR&(wcell,1)-MOD(wcalc+SHR&(wcell,1),wcell)
    IF width(window)>wwork(0)
      SUB width(window),wcell
    ENDIF
    ADD height(window),SHR&(hcell,1)-MOD(hcalc+SHR&(hcell,1),hcell)
    IF height(window)>hwork(0)
      SUB height(window),hcell
    ENDIF
  ENDIF
RETURN
' #############################################################################
PROCEDURE fill_window(window,appear!)
  @prepare_action(window,appear!)
  IF action!
    @sliders(window)
    @rectanglelist(window,1,xwork(0),ywork(0),wwork(0),hwork(0))
  ENDIF
RETURN
PROCEDURE print_item(window,appear!,item,printer!)
  IF printer!
    @print1item(window,item,TRUE)
  ELSE
    IF item>=upper(window) AND item<upper(window)+lines_in(window)
      @prepare_action(window,appear!)
      IF action!
        @rectanglelist(window,3,xwork(0),ywork(0),wwork(0),hwork(0))
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE draw_icon(window,tree,object,column,line,text$,invert!)
  @rscaddress(tree,0)
  IF invert!
    @preselect(object)
  ENDIF
  OB_X(treeaddr%,object)=(column-left(window)+1)*wcell(window)+xwork(window)
  OB_Y(treeaddr%,object)=(line-upper(window)+1)*hcell(window)+ywork(window)
  text$=text$+CHR$(0)
  LPOKE OB_SPEC(treeaddr%,object)+8,VARPTR(text$)
  depth%=0
  @reobject
  IF invert!
    @deselect(object,object)
  ENDIF
RETURN
PROCEDURE clear_area(xcoord,ycoord,width,height)
  DEFFILL ,0
  @vdiborder(FALSE)
  PBOX xcoord,ycoord,xcoord+width,ycoord+height
  @vdiborder(TRUE)
  DEFFILL ,1
RETURN
PROCEDURE titlew(window,text$)
  text$=" "+text$+" "
  @attributext(0)
RETURN
PROCEDURE infow(window,text$,flag!)
  infscroll!(window)=flag!
  text$=" "+text$
  @attributext(1)
RETURN
PROCEDURE closew(window)
  IF on_screen!(window)
    ~WIND_CLOSE(window)
    LET on_screen!(window)=FALSE
    active_in(window)=0
  ENDIF
RETURN
PROCEDURE relative_pos(window,xmouse,ymouse)
  IF window>0 AND window<=nhandles
    xcoord=xmouse-xwork(window)+(left(window)-1)*wcell(window)
    ycoord=ymouse-ywork(window)+(upper(window)-1)*hcell(window)
    column=(xcoord DIV wcell(window))+1
    line=(ycoord DIV hcell(window))+1
  ENDIF
RETURN
PROCEDURE switch_menu(tree)
  IF menuaddr%>0
    @menu_off(mentitle%)
    @menu_bar(FALSE)
    mentitle%=3
  ENDIF
  @rscaddress(tree,0)
  LET menunr%=tree
  LET menuaddr%=treeaddr%
  @menu_bar(TRUE)
  @updatemenu
RETURN
PROCEDURE switch_desk(tree)
  desk%=tree
  IF tree>=0
    @rscaddress(tree,0)
    deskaddr%=treeaddr%
    ~WIND_GET(0,4)
    BMOVE GINTOUT+2,deskaddr%+16,8
  ELSE
    deskaddr%=0
  ENDIF
  ~WIND_SET(0,14,SWAP(deskaddr%),deskaddr%,0,0)
  ~FORM_DIAL(3,0,0,0,0,xwork(0),ywork(0),wwork(0),hwork(0))
RETURN
PROCEDURE change_desk(object,depth%)
  LOCAL treeaddr%
  treeaddr%=deskaddr%
  @obj_offset(treeaddr%,object)
  @rectanglelist(0,2,xobj-1,yobj-1,wobj+3,hobj+3)
RETURN
PROCEDURE remove_icon(object)
  LOCAL treeaddr%,depth%
  treeaddr%=deskaddr%
  @obj_offset(treeaddr%,object)
  @hide(object,TRUE)
  object=0
  depth%=5
  @rectanglelist(0,2,xobj-1,yobj-1,wobj+3,hobj+3)
RETURN
PROCEDURE put_icon(object,xcoord,ycoord,text$)
  LOCAL treeaddr%,txtaddr%
  treeaddr%=deskaddr%
  IF xcoord>=0 AND ycoord>=0
    @remove_icon(object)
    ADD xcoord,wchar/2-((xcoord+wchar/2) MOD wchar)
    ADD xcoord,SHR&(wchar,1)-MOD(ADD(xcoord,SHR(wchar,1)),wchar)
    WHILE xcoord+OB_W(treeaddr%,object)>wwork(0)
      SUB xcoord,wchar
    WEND
    OB_X(treeaddr%,object)=xcoord
    ADD ycoord,SHR&(hchar,1)-MOD(ADD(ycoord,SHR(hchar,1)),hchar)
    WHILE ycoord+OB_H(treeaddr%,object)>hwork(0)
      SUB ycoord,wchar
    WEND
    OB_Y(treeaddr%,object)=ycoord
  ENDIF
  IF text$<>""
    txtaddr%={OB_SPEC(treeaddr%,object)+8}
    length%=MIN(LEN(text$),INT{OB_SPEC(treeaddr%,object)+30}/6)
    CHAR{txtaddr%}=LEFT$(text$,length%)
  ENDIF
  @hide(object,FALSE)
  @deselect(object,object)
  @change_desk(object,5)
RETURN
PROCEDURE form_alert(alertbox%,defaultbutton%)
  LOCAL treeaddr%
  @release_mouse
  ~RSRC_GADDR(15,alertbox%,treeaddr%)
  LET alertbutton%=FORM_ALERT(defaultbutton%,CHAR{{treeaddr%}})
RETURN
PROCEDURE edit_alert(alertbox%,defaultbutton%,variable$,secvar$)
  LOCAL treeaddr%,txtaddr%,length%
  @release_mouse
  ~RSRC_GADDR(15,alertbox%,treeaddr%)
  txtaddr%={treeaddr%}
  aler$=""
  WHILE BYTE{txtaddr%}
    IF BYTE{txtaddr%}=126               !~ = 126
      length%=txtaddr%
      WHILE BYTE{txtaddr%}=126
        INC txtaddr%
      WEND
      length%=txtaddr%-length%
      aler$=aler$+LEFT$(variable$,length%)
      variable$=secvar$
    ENDIF
    aler$=aler$+CHR$(BYTE{txtaddr%})
    INC txtaddr%
  WEND
  LET alertbutton%=FORM_ALERT(defaultbutton%,aler$)
RETURN
PROCEDURE storedstring(tree,object)
  @rscaddress(tree,0)
  text$=CHAR{OB_SPEC(treeaddr%,object)}
RETURN
' #############################################################################
PROCEDURE set_text(object,edtext$)
  LOCAL txtaddr%,length%
  IF object=0
    ALERT 1,"Object=0",1,"OK",wahl
  ENDIF
  txtaddr%={OB_SPEC(treeaddr%,object)}
  length%=MIN(LEN(edtext$),INT{OB_SPEC(treeaddr%,object)+24}-1)
  CHAR{txtaddr%}=LEFT$(edtext$,length%)
  IF te!
    obj_draw(object,0)
  ENDIF
RETURN
PROCEDURE set_text0(object,edtext$)
  ' Set_text mit "0"-UnterdrÅckung
  LOCAL txtaddr%,length%
  IF object=0
    ALERT 1,"Object=0",1,"OK",wahl
  ENDIF
  IF edtext$="0"
    edtext$=""
  ENDIF
  txtaddr%={OB_SPEC(treeaddr%,object)}
  length%=MIN(LEN(edtext$),INT{OB_SPEC(treeaddr%,object)+24}-1)
  CHAR{txtaddr%}=LEFT$(edtext$,length%)
  IF te!
    obj_draw(object,0)
  ENDIF
RETURN
PROCEDURE center_text(object,text$)
  LOCAL length%
  length%=INT{OB_SPEC(treeaddr%,object)+24}-1
  edtext$=SPACE$(length%)
  LSET edtext$=SPACE$(MAX(0,(length%-LEN(text$)) DIV 2))+text$
  @set_text(object,edtext$)
RETURN
PROCEDURE editedtext(object,despace!)
  edtext$=CHAR{{OB_SPEC(treeaddr%,object)}}
  IF despace!
    edtext$=TRIM$(edtext$)
    IF LEN(edtext$)>0
      edtext$=UPPER$(LEFT$(edtext$))+MID$(edtext$,2)
    ENDIF
  ENDIF
RETURN
FUNCTION editedtxt$(object)
  editedtext(object,TRUE)
  RETURN edtext$
ENDFUNC
PROCEDURE enable_edit(object,flag!)
  IF flag!
    OB_FLAGS(treeaddr%,object)=OB_FLAGS(treeaddr%,object) OR 8
  ELSE
    OB_FLAGS(treeaddr%,object)=OB_FLAGS(treeaddr%,object) AND 65527
  ENDIF
RETURN
PROCEDURE enable_button(object,flag!)
  IF flag!
    OB_STATE(treeaddr%,object)=OB_STATE(treeaddr%,object) AND 65527
  ELSE
    OB_STATE(treeaddr%,object)=OB_STATE(treeaddr%,object) OR 8
  ENDIF
RETURN
PROCEDURE hide(object,flag!)
  IF flag!
    OB_FLAGS(treeaddr%,object)=OB_FLAGS(treeaddr%,object) OR 128
  ELSE
    OB_FLAGS(treeaddr%,object)=OB_FLAGS(treeaddr%,object) AND 65407
  ENDIF
RETURN
PROCEDURE hide_disable(object,flag!)
  ' Gemeinsamer Aufruf by B. Dunskus
  hide(object,flag!)
  enable_edit(object,NOT flag!)
RETURN
PROCEDURE deselect(firstbutton%,lastbutton%)
  LOCAL object
  FOR object=firstbutton% TO lastbutton%
    OB_STATE(treeaddr%,object)=OB_STATE(treeaddr%,object) AND 65534
    IF te!
      obj_draw(object,0)
    ENDIF
  NEXT object
RETURN
PROCEDURE preselect(object)
  OB_STATE(treeaddr%,object)=OB_STATE(treeaddr%,object) OR 1
  IF te!
    obj_draw(object,0)
  ENDIF
RETURN
PROCEDURE select(object,flag!)
  IF flag!
    OB_STATE(treeaddr%,object)=OB_STATE(treeaddr%,object) OR 1
  ELSE
    OB_STATE(treeaddr%,object)=OB_STATE(treeaddr%,object) AND 65534
  ENDIF
  IF te!
    obj_draw(object,0)
  ENDIF
RETURN
FUNCTION radioselect(first,last)
  LOCAL object,exit!
  FOR object=first TO last
    IF OB_FLAGS(treeaddr%,object) AND 1     !Selectable
      exit!=@selected(object)
    ENDIF
    EXIT IF exit!
  NEXT object
  RETURN object
ENDFUNC
PROCEDURE customslider(object,child%,vertical!,size%,position%)
  IF size%>=0
    IF vertical!
      OB_H(treeaddr%,child%)=size%*OB_H(treeaddr%,object)/1000
    ELSE
      OB_W(treeaddr%,child%)=size%*OB_W(treeaddr%,object)/1000
    ENDIF
  ENDIF
  IF position%>=0
    IF vertical!
      OB_Y(treeaddr%,child%)=position%*(OB_H(treeaddr%,object)-OB_H(treeaddr%,child%))/1000
    ELSE
      OB_X(treeaddr%,child%)=position%*(OB_W(treeaddr%,object)-OB_W(treeaddr%,child%))/1000
    ENDIF
  ENDIF
RETURN
PROCEDURE dialogbox(firstedit%,depth%)
  LOCAL xbox,ybox,wbox,hbox,touchexit!,underbox$
  @release_mouse
  IF OB_FLAGS(treeaddr%,0) AND 1024
    @movable(tree)
    OB_X(treeaddr%,0)=xbox+3
    OB_Y(treeaddr%,0)=ybox+3
    wbox=OB_W(treeaddr%,0)+6
    hbox=OB_H(treeaddr%,0)+6
  ELSE
    ~FORM_CENTER(treeaddr%,xbox,ybox,wbox,hbox)
  ENDIF
  IF dialog_level=0
    ' Menu aus
    '    rscaddress(hauptmen,0)
    '   ~MENU_BAR(treeaddr%,0)
    ~FORM_DIAL(0,0,0,0,0,xbox,ybox,wbox,hbox)
  ELSE
  ENDIF
  GET xbox,ybox,xbox+wbox,ybox+hbox,underbox$
  INC dialog_level
  ~FORM_DIAL(1,0,0,0,0,xbox,ybox,wbox,hbox)
  @obj_draw(0,depth%)
  REPEAT
    @form_do(firstedit%)
    LET touchexit!=((OB_FLAGS(treeaddr%,exitbutton%) AND 64)>0)
    IF touchexit!
      @touchexit(tree,exitbutton%,doubleclick!)
    ENDIF
  UNTIL NOT touchexit!
  @deselect(exitbutton%,exitbutton%)
  ~FORM_DIAL(2,0,0,0,0,xbox,ybox,wbox,hbox)
  DEC dialog_level
  PUT xbox,ybox,underbox$
  IF dialog_level=0
    ~FORM_DIAL(3,0,0,0,0,xbox,ybox,wbox,hbox)
    ' Menu ein
    '    rscaddress(hauptmen,0)
    '    ~MENU_BAR(treeaddr%,1)
  ELSE
  ENDIF
RETURN
PROCEDURE popupbox(preselect,depth%)
  LOCAL xbox,ybox,wbox,hbox,touchexit!,underbox$
  mouse_pos
  IF OB_FLAGS(treeaddr%,0) AND 1024
    @movable(tree)
    OB_X(treeaddr%,0)=xbox+3
    OB_Y(treeaddr%,0)=ybox+3
    wbox=OB_W(treeaddr%,0)+6
    hbox=OB_H(treeaddr%,0)+6
  ELSE
    ~FORM_CENTER(treeaddr%,xbox,ybox,wbox,hbox)
  ENDIF
  GET xbox,ybox,xbox+wbox,ybox+hbox,underbox$
  '  ~FORM_DIAL(0,0,0,0,0,xbox,ybox,wbox,hbox)
  ~FORM_DIAL(1,0,0,0,0,xbox,ybox,wbox,hbox)
  select(preselect,TRUE)
  lastobject=preselect
  te!=TRUE
  @obj_draw(0,depth%)
  REPEAT
    '    @form_do(firstedit%)
    mouse_pos
    object=OBJC_FIND(treeaddr%,0,5,xmouse,ymouse)
    IF object<=0
      object=preselect
    ENDIF
    IF object<>lastobject
      IF lastobject>0
        select(lastobject,FALSE)
      ENDIF
      IF object>0
        select(object,TRUE)
      ENDIF
    ENDIF
    lastobject=object
  UNTIL kmouse=0
  exitbutton%=lastobject
  IF exitbutton%>0
    select(exitbutton%,FALSE)
  ENDIF
  PUT xbox,ybox,underbox$
  ~FORM_DIAL(2,0,0,0,0,xbox,ybox,wbox,hbox)
  '  ~FORM_DIAL(3,0,0,0,0,xbox,ybox,wbox,hbox)
  te!=FALSE
RETURN
' #############################################################################
PROCEDURE menu_bar(flag!)
  ~MENU_BAR(menuaddr%,-flag!)
RETURN
PROCEDURE menu_check(object,flag!)
  ~MENU_ICHECK(menuaddr%,object,-flag!)
RETURN
PROCEDURE menu_enable(object,flag!)
  ~MENU_IENABLE(menuaddr%,object,-flag!)
RETURN
PROCEDURE menu_off(object)
  ~MENU_TNORMAL(menuaddr%,object,1)
RETURN
PROCEDURE obj_draw(object,depth%)
  ~OBJC_DRAW(treeaddr%,object,depth%,xbox,ybox,wbox,hbox)
RETURN
PROCEDURE obj_offset(treeaddr%,object)
  ~OBJC_OFFSET(treeaddr%,object,xobj,yobj)
  wobj=OB_W(treeaddr%,object)
  hobj=OB_H(treeaddr%,object)
RETURN
PROCEDURE form_do(firstedit%)
  LOCAL object
  object=FORM_DO(treeaddr%,firstedit%)
  LET exitbutton%=object AND &H7FFF
  LET doubleclick!=object<0
RETURN
PROCEDURE graf_dragbox(xbox,ybox,wbox,hbox)
  LOCAL object,window,xcoord,ycoord,column,line
  ~GRAF_DRAGBOX(wbox,hbox,xbox,ybox,xwork(0),ywork(0),wwork(0),hwork(0),xdest,ydest)
  @mouse_pos
  @wind_find(xmouse,ymouse)
  destwind=window
  IF destwind=0
    SUB xdest,xwork(0)
    SUB ydest,ywork(0)
    destobj=OBJC_FIND(deskaddr%,0,5,xmouse,ymouse)
    destparent=OBJC_FIND(deskaddr%,0,1,xmouse,ymouse)
  ELSE
    IF destwind>0
      @relative_pos(destwind,xmouse,ymouse)
      xdest=xcoord
      ydest=ycoord
      destcol=column
      destline=line
    ENDIF
  ENDIF
RETURN
PROCEDURE graf_slidebox(object,child%,vertical!)
  position%=GRAF_SLIDEBOX(treeaddr%,object,child%,-vertical!)
RETURN
PROCEDURE getcharsize
  V~H=GRAF_HANDLE(dummy,dummy,dummy,dummy)
  VDISYS 38
  standard_font%=PTSOUT(1)
  wchar=PTSOUT(2)
  hchar=PTSOUT(3)
  V~H=-1
  {INTIN}=3
  VDISYS 39
RETURN
PROCEDURE release_mouse
  REPEAT
    @mouse_pos
  UNTIL kmouse=0
RETURN
PROCEDURE mouse_pos
  ~GRAF_MKSTATE(xmouse,ymouse,kmouse,shiftstate%)
RETURN
PROCEDURE wind_find(xmouse,ymouse)
  window=WIND_FIND(xmouse,ymouse)
  IF ymouse<ywork(0) OR window>nhandles
    window=-1
  ENDIF
RETURN
PROCEDURE wind_calc(mode,window,xcoord,ycoord,width,height)
  ~WIND_CALC(mode,attributes(window),xcoord,ycoord,width,height,xcalc,ycalc,wcalc,hcalc)
RETURN
PROCEDURE rscload(rscfile$)
  ~RSRC_FREE()
  DEFMOUSE 2
  IF RSRC_LOAD(rscfile$)=0
    ALERT 3,rscfile$+" not found",1,"STOP",alertbutton%
    EDIT
  ENDIF
  DEFMOUSE 0
RETURN
PROCEDURE rscaddress(object,type%)
  ~RSRC_GADDR(type%,object,treeaddr%)
  IF type%=0
    tree=object
  ENDIF
RETURN
PROCEDURE vditext(window,item,firstcol%,text$)
  LOCAL mptr%,x,y
  IF firstcol%+LEN(text$)>=left(window) AND firstcol%<left(window)+cols_in(window)
    text$=MID$(text$,1+MAX(0,left(window)-firstcol%),cols_in(window)-MAX(0,firstcol%-left(window)))
    x=MAX(0,firstcol%-left(window))*wchar
    y=(item-upper(window)+1)*hchar-1
    TEXT x,y,text$
    IF FALSE
      mptr%=VARPTR(mcode$)
      VOID C:mptr%(L:INTIN,L:VARPTR(text$),LEN(text$))
      DPOKE PTSIN,xwork(window)+MAX(0,firstcol%-left(window))*wchar
      DPOKE PTSIN+2,ywork(window)+(item-upper(window)+1)*hchar-1
      VDISYS 8,LEN(text$),1
    ENDIF
  ENDIF
RETURN
PROCEDURE vdiborder(flag!)
  BOUNDARY flag!
RETURN
PROCEDURE fill_rect(xcoord,ycoord,width,height)
  LOCAL x0,y0,ox,oy,ow,oh
  x0=xwork(window)+xcoord
  y0=ywork(window)+ycoord
  ox=MAX(x0,xredr)
  oy=MAX(y0,yredr)
  ow=MIN(x0+width,xredr+wredr)-ox
  oh=MIN(y0+height+1,yredr+hredr)-oy
  RC_COPY XBIOS(2),ox-xredr,oy-yredr,ow,oh TO XBIOS(2),ox,oy,10
RETURN
PROCEDURE clip(flag!,xclip,yclip,wclip,hclip,xbase,ybase)
  IF window>0 AND (typew(window)>=3 OR wclip<wwork(window) OR hclip<hwork(window) OR mode>1)
    IF flag!
      CLIP xclip,yclip,wclip,hclip
    ELSE
      CLIP OFF
    ENDIF
  ENDIF
  CLIP  OFFSET xbase,ybase
RETURN
'
' #############################################################################
'                           Programm
' #############################################################################
'
PROCEDURE reserve_handles
  DEFMOUSE 2
  '
  ' ==========================================================================
  ' Nicht direkt aufrufen.
  ' Reserviert GEM-Handles fÅr benîtigte Fenster.
  ' Beispiel:
  ' @make_window(1,1,"TITLE","Info",FALSE,&X111111111111,0,20,320,950,77,0)
  ' (siehe dort)
  ' ==========================================================================
  make_window(1,0,"Kopfdaten des Parts","",TRUE,&X111111101111,5+10*1,20+50*1,920,600,80,0)
  make_window(2,1,"Einzelevents des Parts","",TRUE,&X111111101111,5+10*2,20+50*2,920,600,70,0)
  make_window(3,5,"Event-öbersicht","",TRUE,&X111111101111,0,0,1010,1020,3300,8*6*18*2*640/1000)
  make_window(4,0,"Hilfe-Fenster","",TRUE,&X111111101111,0,0,1010,1020,wwork(0)/8,hwork(0)/16)
  make_window(5,5,"2-D-Editor","",TRUE,&X111111101111,0,0,1010,1020,wwork(0)/8,hwork(0)/16)
  make_window(6,5,"3-D-Editor","",TRUE,&X111111101111,0,0,1010,1020,wwork(0)/8,hwork(0)/16)
  '  fill_window(6,TRUE)
  DEFMOUSE 0
  window=0
RETURN
PROCEDURE menujunction(menuitem)
  '
  ' ==========================================================================
  ' Sprungverteiler fÅr MenÅ
  ' menuitem& ist die Objectnummer des gewÑhlten Menueintrags.
  ' ==========================================================================
  '
  stop_3d_timer
  SELECT menuitem
  CASE copyr
    copyright
  CASE mladen
    @load_save_merge_box(1)
  CASE mmerge
    @load_save_merge_box(2)
  CASE msave
    @load_save_merge_box(3)
  CASE mexporte
    @load_save_merge_box(4)
  CASE mende
    ende
  CASE mxyzumw
    altpart_3d
    ' ---  MIDI  ---
  CASE mmidiin
    midi_setup
  CASE mvolres
    vol_reset!=NOT vol_reset!
  CASE mvolausg
    volume_ausgabe!=NOT volume_ausgabe!
    ' ---  Editoren  ---
  CASE m3dedit
    edit_2d!=FALSE
    fill_window(6,TRUE)
  CASE m2dedit
    edit_2d!=TRUE
    fill_window(5,TRUE)
  CASE meventue
    event_uebersicht
  CASE mrecordp
    record_parameter
  CASE msperre
    sperren(0)
  CASE mlinie3d
    linie_3d!=NOT linie_3d!
  CASE mkooranz
    anz_parameter
  CASE mfaden3d
    fadenkreuz_parameter
  CASE mgrafikm
    grafik_mode
  CASE mmauszoo
    maus_zoom
  CASE minnenra
    innenraum!=NOT innenraum!
    IF window=5 OR window=6
      fill_window(window,FALSE)
    ENDIF
  CASE mquant
    quant
  CASE mevueamp
    event_uebers_ampl
  CASE mevuebre
    event_uebers_breite
    ' ---  Setups  ---
  CASE minputs
    input_parameter
  CASE medpres
    rts_dialog
  CASE mgeneset
    ' General-Setup
    general_setup_dialog
  CASE minpchan
    ' Input-Change
    @inputchange_dialog
  CASE mgesdreh
    gesamt_parameter
  CASE mrotalle
    mtr_parameter
  CASE mbalance
    balance
  CASE mueberbl
    ueberblend_parameter
  CASE mlfopar0
    lfo_parameter(0)
  CASE mlfopar1
    lfo_parameter(1)
  CASE mmausext
    ext_maus!=NOT ext_maus!
    ext_maus_init
  CASE mperiode
    periode
  CASE mwiederh
    PRINT CHR$(7);
    wiederholungen
  CASE mipuffer
    in_puffer
  DEFAULT
    PRINT menuitem
  ENDSELECT
RETURN
PROCEDURE updatemenu
  '  PRINT CHR$(7);
  '
  ' ==========================================================================
  ' Hier kînnen die MenueintrÑge entsprechend den Variablen gesetzt werden.
  ' menu_enable, menu_check.
  ' ==========================================================================
  '
  LOCAL fenster!,akt_fenster!
  '
  '  menu_enable(drlang,TRUE)
  menu_check(msperre,sperre!)
  menu_check(mlinie3d,linie_3d!)
  menu_check(mfaden3d,fadenkreuz_3d!)
  menu_check(mvolres,vol_reset!)
  menu_check(minnenra,innenraum!)
  menu_check(mvolausg,volume_ausgabe!)
  menu_check(mkooranz,koor_anz!)
  menu_check(mmausext,ext_maus!)
  menu_enable(mperiode,FALSE)
  menu_enable(mipuffer,FALSE)
  menu_enable(mwiederh,FALSE)
  menu_enable(mpankano,FALSE)
  menu_enable(mgesdreh,FALSE)
  menu_enable(mbalance,FALSE)
  '  OB_STATE(treeaddr%,mpanlfo)=OB_STATE(treeaddr%,mpanlfo) OR &H8 ! Disabled
RETURN
PROCEDURE set_cellsize(window)
  '
  ' ==========================================================================
  ' Hier werden wcell&() und hcell&() geÑndert.
  ' ==========================================================================
  '
  SELECT window
  CASE 3
    wcell(window)=MAX(10,10*uebers_stepbreite)
    hcell(window)=MAX(1,uebers_ydist)
  DEFAULT
    wcell(window)=8
    hcell(window)=16
  ENDSELECT
RETURN
PROCEDURE graphic(window,hor%,ver%)
  '
  ' ==========================================================================
  ' Hier wird der Inhalt von Graphik- (Nicht-Text) Fenstern gezeichnet.
  ' Dabei geben hor% und ver% den Koordinatenoffset an (lift_point00).
  ' Zur Beschleunigung des Redraws kann man hcell&(), wcell&(), lines_in&()
  ' und cols_in&()
  ' ==========================================================================
  '
  SELECT window
  CASE 3
    ' event-uebersicht
    lift_point00
    uebers_init
    uebers_draw(0,0)
  CASE 5,6
    lift_point00
    ed_aufbau
    disp_dpresets
  CASE 4
    IF FALSE
      lift_point00
      SELECT w4mode
      CASE allg_help
        allg_help
      CASE param_3d
        3d_param(1)
        '    CASE ed_help
        '      ed_help
      CASE helptext
        ' anderer Fenster-Typ: Typ 0 = Text
        '      helptext
      ENDSELECT
    ENDIF
  ENDSELECT
RETURN
PROCEDURE keyboard(shiftstate%,ascii%,scancode%)
  '
  ' ==========================================================================
  ' Hier werden die Tastatureingaben ohne aktive Dialogbox oder Alertbox
  ' verarbeitet. shiftstate% enthÑlt eine Bitmaske fÅr die Tastaturumschalt-
  ' tasten. shiftstate% and 2 steht fÅr die linke shifttaste, entsprechend:
  ' 1=rechts Shift, 2=links Shift, 4=Control, 8=Alternate, 16=Caps Lock.
  ' ascii% enthÑlt den Ascii-Wert der Taste und scancode% die Nummer der Taste,
  ' wie bei INKEY$ ist, wenn ascii%=0, nur der scancode% ausschlaggebend.
  ' ==========================================================================
  '
  '  LOCAL upp_alt
  '  upp_alt=upper(window)
  '  taste=MENU(14)
  ' taste$=CHR$(taste)
  find_top_window
  sc%=scancode%
  taste$=CHR$(ascii%)
  '  gprint(70,1,HEX$(scancode%))
  SELECT window
  DEFAULT
    IF scancode%=&H62
      ' <HELP>
      stop_3d_timer
      IF on_screen!(4)
        w4mode=MAX((w4mode+1) MOD (presets+1),helptext)
      ENDIF
      help
    ELSE IF on_screen!(4)
      schl_fenster(4)
    ENDIF
    IF (window=5 AND on_screen!(5)) OR (window=6 AND on_screen!(6))
      ed_taste(shiftstate%)
    ENDIF
    SELECT shiftstate%
    CASE 8,9,10
      alt_tasten
    CASE 4,2,1
      ctrl_tasten
    DEFAULT
      '    3d_param_tasten
      SELECT scancode%
      CASE &HF
        ' <TAB>
        SELECT uebers_mode
        CASE 0
          uebers_mode=1
        CASE 1
          uebers_mode=0
        ENDSELECT
        fill_window(3,FALSE)
      CASE &H10
        ' q
        stop_3d_timer
        quant
      CASE &H11
        ' w
        wiederholungen
      CASE &H12
        ' e
        event_uebersicht
      CASE &H13
        ' r
        stop_3d_timer
        record_parameter
      CASE &H15
        ' z
        stop_3d_timer
        maus_zoom
      CASE &H17
        ' i
        stop_3d_timer
        input_parameter
      CASE &H19
        ' p
        in_puffer
      CASE &H1A
        ' Å
        ueberblend_parameter
      CASE &H1C,&H72
        IF window=3 AND on_screen!(window)
          @closew(3)
        ENDIF
      CASE &H1E
        ' a
        stop_3d_timer
        mtr_parameter
      CASE &H21
        ' f
        stop_3d_timer
        grafik_mode
      CASE &H22
        ' g
        stop_3d_timer
        general_setup_dialog
      CASE &H25
        ' k
        koor_anz!=NOT koor_anz!
        updatemenu
      CASE &H26
        ' l
        stop_3d_timer
        lfo_parameter(0)
      CASE &H2D
        ' x
        stop_3d_timer
        @inputchange_dialog
      CASE &H2F
        ' v
        vol_reset!=NOT vol_reset!
        updatemenu
      CASE &H30
        ' b
        stop_3d_timer
        balance
      CASE &H31
        ' n
        stop_3d_timer
        innenraum!=NOT innenraum!
        IF window=5 OR window=6
          fill_window(window,FALSE)
        ENDIF
      CASE &H32
        ' m
        '    dchanmidi   ! Midi-Kanal-Zuordnung
        stop_3d_timer
        midi_setup
      CASE &H2 TO &HA
        ' Zahlenreihe 1 - 9
        ARRAYFILL mtr_geschw_koeff(),(ascii%-48)*100 ! asc("1")=49
        IF relation_mtrlfo>0
          ARRAYFILL lfo_geschw_koeff(),mtr_geschw_koeff(1)*relation_mtrlfo/100
        ENDIF
      CASE &HB
        ' Zahlenreihe 0 = Beschleunigung 0
        ARRAYFILL mtr_geschw_koeff(),0
        IF relation_mtrlfo>0
          ARRAYFILL lfo_geschw_koeff(),mtr_geschw_koeff(1)*relation_mtrlfo/100
        ENDIF
      CASE &H60
        ' <
        change_preset_type(TRUE)
      CASE &H67 TO &H6F,&H70
        ' Zahlenblock 1-9,0
        IF (window=5 AND on_screen!(5)) OR (window=6 AND on_screen!(6))
          IF mtr_angabe!
            set_presets
          ELSE
            signal=VAL(taste$)
            IF signal>0 AND signal<9
              play_inp!(signal)=NOT play_inp!(signal)
              play_inp_status(signal)
              IF vol_reset!
                koor_signal(3,signal)=-127*play_inp!(signal)
                mute!=TRUE
                kneu!(3,signal)=TRUE
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      CASE &H3B TO &H43
        ' F1 .. F9 = LFO-Speed-Faktor 1 .. 9
        f_taste=scancode%-&H3A
        ARRAYFILL lfo_geschw_koeff(),(f_taste)*100
      CASE &H44
        ' F10 = LFO-Speed-Faktor 0
        ARRAYFILL lfo_geschw_koeff(),0
      CASE &H4B
        ' cursor links
        mausmodus(0)
      CASE &H50
        ' cursor unten
        mausmodus(1)
      CASE &H4D
        ' cursor rechts
        mausmodus(2)
      CASE &H4E
        ' [+]
        IF (window=5 AND on_screen!(5)) OR (window=6 AND on_screen!(6))
          change_presets(TRUE)
        ENDIF
      CASE &H4A
        ' [-]
        IF (window=5 AND on_screen!(5)) OR (window=6 AND on_screen!(6))
          change_presets(FALSE)
        ENDIF
      CASE &H47
        ' CLR/HOME
        menu1=23
        relocate_key(window)
        '      fill_window(window,TRUE)
      CASE &H61
        ' UNDO
        IF NOT on_screen!(4)
          IF window=5 OR window=6
            stop_3d_timer
            mode=stop
            exit!=TRUE
          ENDIF
          schl_fenster(window)
        ELSE
          schl_fenster(4)
        ENDIF
      CASE &H52
        ' insert
        stop_3d_timer
        rts_dialog
      CASE &H71
        ' Zahlenblock "."
        IF (window=5 AND on_screen!(5)) OR (window=6 AND on_screen!(6))
          mtr_angabe!=TRUE
          '          set_presets
          rscaddress(dpresets,0)
          te!=TRUE
          set_text(@pres_change_type_obj(pres_change_type),"_____")
          te!=FALSE
          a!=FALSE
          b!=FALSE
          c!=FALSE
          d!=FALSE
        ENDIF
      ENDSELECT
    ENDSELECT
  ENDSELECT
RETURN
PROCEDURE 3d_param_tasten
  SELECT taste$
  CASE ")"
    var_alt=variation
    variation=MIN(variation+1,anz_var)
    IF variation=var_alt
      zeigen!=FALSE
    ENDIF
  CASE "("
    var_alt=variation
    variation=MAX(0,variation-1)
    IF variation=var_alt
      zeigen!=FALSE
    ENDIF
  CASE "+"
    IF bild=2
      IF seite*rows<laenge+1-rows
        INC seite
      ELSE
        zeigen!=FALSE
      ENDIF
    ELSE
      ADD zoom#,0.05
    ENDIF
  CASE "-"
    IF bild=2
      IF seite>0
        DEC seite
      ELSE
        zeigen!=FALSE
      ENDIF
    ELSE
      SUB zoom#,0.05
    ENDIF
  CASE "/"
    seite=0
  CASE "*"
    IF bild=3
      IF linie=3
        linie=0
      ELSE
        linie=3
      ENDIF
    ELSE
      seite=INT(laenge/(rows+1))
    ENDIF
  CASE "1"
    SUB vz#,0.05
  CASE "2"
    SUB vy#,0.05
  CASE "3"
    SUB p#,0.0002
  CASE "4"
    SUB vx#,0.05
  CASE "5"
    default_3dparam
  CASE "6"
    ADD vx#,0.05
  CASE "7"
    ADD p#,0.0002
  CASE "8"
    ADD vy#,0.05
  CASE "9"
    ADD vz#,0.05
  CASE "."
    aussenw!=NOT aussenw!
  CASE 27
    schl_fenster(window)
  ENDSELECT
RETURN
PROCEDURE alt_tasten
  LOCAL a,b,c
  SELECT scancode%
  CASE &H21
    ' f
    fadenkreuz_3d!=NOT fadenkreuz_3d!
    updatemenu
  CASE &H25
    ' k
    anz_parameter
  CASE &H3B TO &H44
    f_taste=scancode%-&H3A
    lfo_an!(f_taste-1)=NOT lfo_an!(f_taste-1)
    lfo_status(f_taste-1)
  CASE &H1F
    ' <ALT> S
    sperren(0)
  DEFAULT
  ENDSELECT
RETURN
PROCEDURE ctrl_tasten
  '    PRINT HEX$(scancode%)
  SELECT taste$
  CASE 17
    ' CTRL-q
    ende
  CASE 15
    ' CTRL-o
    @load_save_merge_box(1)
  CASE 26
    ' CTRL-<z>
    zeitl(TRUE,TRUE)
  DEFAULT
    SELECT scancode%
    CASE &H54 TO &H5D
      f_taste=scancode%-&H53
      '      get_setup(fkeyn(f_taste))
    CASE 3
      ' <Ctrl> 2
      edit_2d!=TRUE
      updatemenu
      fill_window(5,TRUE)
    CASE 4
      ' <Ctrl> 3
      edit_2d!=FALSE
      updatemenu
      fill_window(6,TRUE)
    CASE &H12
      ' CTRL-e
      @load_save_merge_box(4)
    CASE &H1F
      ' CTRL-s
      @load_save_merge_box(3)
    CASE &H26
      ' SHIFT L
      stop_3d_timer
      lfo_parameter(1)
    CASE &H48
      SELECT shiftstate%
      CASE 0
        DEC upper(window)
      CASE 1,2,5,6
        SUB upper(window),lines_in(window)
      CASE 4
        upper(window)=0
      ENDSELECT
      fill_window(window,FALSE)
    CASE &H50
      '          PRINT AT(1,1);STR$(shiftstate%,2)
      SELECT shiftstate%
      CASE 0
        INC upper(window)
      CASE 1,2,5,6
        ADD upper(window),lines_in(window)
      CASE 4
        '        upper(window)=nlines(window)-lines_in(window)
        upper(window)=nlines(window)
      ENDSELECT
      fill_window(window,FALSE)
    CASE &H53
      ' <CONTROL><DELETE>
      delete_events(count%,max3devents%)
    CASE &H60
      ' <SHIFT> <
      change_preset_type(FALSE)
    ENDSELECT
  ENDSELECT
RETURN
PROCEDURE click_in(window,column,item,doubleclick!)
  '
  ' ==========================================================================
  ' Hier werden Mausclicks in Textfenstern mit aktivierbaren Zeilen
  ' verarbeitet. window& enthÑlt die Nummer des Fensters, item& enthÑlt die
  ' Zeilenummer, column& die Spaltennummer. Das Flag doubleclick! ist bei
  ' Aktivierung mit Doppelclick gesetzt.
  ' ==========================================================================
  '
  SELECT window
  CASE 4
    IF w4mode=presets
      setupnr=item
      schl_fenster(window)
      do_setup(setupnr)
    ENDIF
  ENDSELECT
RETURN
PROCEDURE graphclick(window,column,line,xcoord,ycoord,doubleclick!)
  '
  ' ==========================================================================
  ' Hier werden Mausclicks in Graphikfenstern verarbeitet. Die Routine arbeitet
  ' wie click_in fÅr Textfenster, nur gibt es zusÑtzlich Pixelkoordinaten in
  ' xcoord& und ycoord&.
  ' ==========================================================================
  '
  SELECT window
  CASE 5,6
    IF mode=stop
      presetbox(xcoord+xwork(window),ycoord+ywork(window),doubleclick!)
    ENDIF
  ENDSELECT
RETURN
PROCEDURE deskobject(tree%,treeaddr%,object,doubleclick!)
  LOCAL datei
  '
  ' ==========================================================================
  ' Hier werden Mausclicks auf Objecte im Desktophintergrund verarbeitet.
  ' Die weitere Bearbeitung erfolgt in PROCEDURE change_desk oder put_icon.
  ' ==========================================================================
  '
RETURN
PROCEDURE deskbackground(tree%,treeaddr%)
  '
  ' ==========================================================================
  ' Hier werden Mausclicks auf leere Bereiche im Desktophintergrund verarbeitet.
  ' ==========================================================================
  '
RETURN
PROCEDURE drag_onobj(treeaddr%,object,destobj,destparent)
  '
  ' ==========================================================================
  ' Hier werden Objectverschiebungen von object& auf andere Objecte destobj&
  ' im Åbergeordneten Object destparent& im Desktophintergrund verarbeitet.
  ' ==========================================================================
  '
RETURN
PROCEDURE drag_inw(treeaddr%,object,window,column,line,xcoord,ycoord)
  '
  ' ==========================================================================
  ' Hier werden Objectverschiebungen von object& in ein Fenster window&
  ' verarbeitet. Zielkoordinaten in column&, line& und xcoord&, ycoord&.
  ' ==========================================================================
  '
RETURN
PROCEDURE touchexit(tree%,exitbutton%,doubleclick!)
  '
  ' ==========================================================================
  ' Hier werden Mausclicks auf Touchexit-Objecte in Dialogboxen verarbeitet.
  ' tree% ist die Nummer der Dialogbox, exitbutton% ist die Nummer des
  ' gewÑhlten Objects und doubleclick! gibt an, ob die Aktivierung mittels
  ' Doppelclick erfolgte.
  ' ==========================================================================
  '
  '  PRINT CHR$(7);
  LOCAL vinc
  te!=TRUE
  shiftstate%=BIOS(11,-1) ! kbshift()
  SELECT tree%
  CASE dinppara
    te_ip_dialog
  CASE dgespara
    te_dg_dialog
  CASE dparam
    te_dparam
  CASE dbalance
    te_balance
  CASE dmidi
    te_midi_setup
  CASE dallrot
    '    select(exitbutton%,TRUE)
    te_mtr_dialog
  CASE dfkeys
    '    te_rts_dialog
  CASE dlfos
    te_lfo_dialog(lfo_group)
  CASE dgenset
    te_genset_dialog
  CASE dcminput
    te_inputchange_dialog
  CASE drecordp
    te_record_parameter
  ENDSELECT
  te!=FALSE
RETURN
PROCEDURE movable(tree%)
  '
  ' ==========================================================================
  ' Das Zentrieren einer Dialogbox kann durch Setzen von Bit 10 in OB_FLAGS
  ' verhindert werden. Dann kînnen hier xbox& und ybox& gesetzt werden.
  ' ==========================================================================
  '
  SELECT tree%
  CASE dinput,dsignal,drotrich,drotmod,dlfoquel,dlfosel,droteben,dmausmod
    xbox=MIN(MAX(3,xmouse-OB_W(treeaddr%,0)/2-16),wwork(0)-OB_W(treeaddr%,0))
    ybox=MIN(MAX(3,ymouse-OB_H(treeaddr%,0)/2),hwork(0)-OB_H(treeaddr%,0))
  CASE dzahl
    '    xbox=MOUSEX !+OB_W(treeaddr%,0)/2
    xbox=MAX(3,xmouse-OB_W(treeaddr%,0)/2-16)
    ybox=MIN(MAX(3,ymouse-OB_H(treeaddr%,0)/2),hwork(0)-OB_H(treeaddr%,0))
  CASE dfkname
    xbox=wwork(0)/2-OB_W(treeaddr%,0)/2
    ybox=MIN(MAX(3,ymouse-OB_H(treeaddr%,0)/2),hwork(0)-OB_H(treeaddr%,0))
  CASE dpresets
    xbox=xwork(window)+5
    ybox=ywork(window)+5
  ENDSELECT
RETURN
PROCEDURE invert_boolean(window,item)
  '
  ' ==========================================================================
  ' Hier werden Selektierungen in Textfenstern type=2 geÑndert.
  ' Beispiel:
  ' Yagh!(Item)=Not Yagh!(Item)
  ' ==========================================================================
  '
  '  yagh!(item)=NOT yagh!(item)
RETURN
PROCEDURE make_itemstring(window,item)
  '
  ' ==========================================================================
  ' Hier wird aus Fensternummer window&  und Zeilennummer item& ein String
  ' item$ erzeugt, der dann Åber PROCEDURE print1item ausgegeben wird.
  ' ==========================================================================
  '
  item$=""
  SELECT window
  CASE 2
    IF sinput=0 OR sinput=@input(item)
      z=item
      SELECT mitte
      CASE lang
        item$=@zeit$(item)+STR$(wert(z,1),5)+STR$(mwert(z,variation),5)
        IF wert(z,6)=159
          item$=item$+"  CYB "
        ELSE
          item$=item$+"  &h"+HEX$(wert(z,6),2)
        ENDIF
        item$=item$+STR$(wert(z,7),5)+STR$(wert(z,8),5)+STR$(wert(z,9),5)+STR$(SHL(wert(z,lenmsb),8)+wert(z,lenlsb),5)+STR$(wert(z,12),5)
        IF wert(z,status)=159
          item$=item$+STR$(@input(z),5)+STR$(@output(z),5)
        ENDIF
      CASE kurz
        item$=@zeit$(z)
        IF wert(z,6)=159
          item$=item$+"   CYB  "
        ELSE
          item$=item$+STR$(wert(z,6),7)
        ENDIF
        item$=item$+STR$(wert(z,7),5)
        IF wert(z,status)=159
          item$=item$+STR$(@input(z),5)+STR$(@output(z),5)
        ENDIF
      CASE hex
        item$=item$+@zeit$(z)
        FOR v=1 TO 12
          item$=item$+"  "+HEX$(wert(z,v),2)
        NEXT v
      ENDSELECT
    ENDIF
    invert!=selevent!(item,window)
  CASE 4
    SELECT w4mode
    CASE helptext
      item$=helptext$(MAX(0,MIN(helplines%,item-1)))
    CASE presets
      invert!=setupnr=item
      IF item<=maxsetups/2
        item$=STR$(item,4)+"  "+setup$(item)
      ELSE
        item$=STR$(item,4)+"  "+setup2$(item-maxsetups/2)
      ENDIF
    ENDSELECT
  ENDSELECT
RETURN
PROCEDURE init_hn_arrays
  ' ***   Umrechnungen   ***
  DIM mausmodus$(2)
  mausmodus$(0)="0: O-U"
  mausmodus$(1)="1: V-H"
  mausmodus$(2)="2: L-R"
  ' ***   Symbole   ***
  ' ***   Dialoge   ***
  DIM daebene(8)
  DIM daphase(8)
  DIM dasekum(8)
  DIM dausek(8)
  DIM daricht(8)
  DIM damodus(8)
  DIM dawinkel(8)
  object=daebene1
  FOR signal=1 TO 8 ! (frÅher 9, wg. FÅhrungspunkt)
    ' mod 9: bei 9-> input 0
    daebene(signal MOD 9)=object
    INC object
    daricht(signal MOD 9)=object
    INC object
    damodus(signal MOD 9)=object
    INC object
    dawinkel(signal MOD 9)=object
    INC object
    dasekum(signal MOD 9)=object
    INC object
    dausek(signal MOD 9)=object
    INC object
    daphase(signal MOD 9)=object
    INC object
    INC object
  NEXT signal
  DIM mtr_richtung$(3)
  mtr_richtung$(0)="Stop"
  mtr_richtung$(1)="Links"
  mtr_richtung$(2)="Stop"
  mtr_richtung$(3)="Rechts"
  DIM mtr_modus$(3)
  mtr_modus$(0)="Durchl."
  mtr_modus$(1)="Autostop"
  mtr_modus$(2)="Pendel"
  mtr_modus$(3)="Durchl."
  DIM mtr_ebene$(14)
  mtr_ebene$(0)="Vorne"
  mtr_ebene$(1)="Rechts"
  mtr_ebene$(2)="Hinten"
  mtr_ebene$(3)="Links"
  mtr_ebene$(4)="Oben"
  mtr_ebene$(5)="Unten"
  mtr_ebene$(6)="6-7-4-1"
  mtr_ebene$(7)="8-5-2-3"
  mtr_ebene$(8)="7-8-1-2"
  mtr_ebene$(9)="5-6-3-4"
  mtr_ebene$(10)="1-5-7-3"
  mtr_ebene$(11)="2-6-8-4"
  mtr_ebene$(12)="L-O-R-U"
  mtr_ebene$(13)="L-V-R-H"
  mtr_ebene$(14)="V-O-H-U"
  DIM drdreh(14)
  drdreh(0)=drvorn
  drdreh(1)=drrechts
  drdreh(2)=drhinten
  drdreh(3)=drlinks
  drdreh(4)=droben
  drdreh(5)=drunten
  drdreh(6)=drvohu
  drdreh(7)=drrolu
  drdreh(8)=drhovu
  drdreh(9)=drloru
  drdreh(10)=drlhrv
  drdreh(11)=drlvrh
  drdreh(12)=drabfl
  drdreh(13)=dracfl
  drdreh(14)=drbcfl
  DIM dypres(10)
  DIM dytext(10)
  object=dynum1
  FOR key=1 TO 10
    dypres(key)=object
    INC object
    dytext(key)=object
    INC object
  NEXT key
  DIM dcminput(64)
  object=dinp1
  FOR signal=1 TO 64
    dcminput(signal)=object
    INC object
  NEXT signal
  DIM dcsig(8)
  DIM dcinp(8)
  DIM dcan(8)
  i=0
  FOR signal=1 TO 8
    dcsig(signal)=dcsig1+i
    dcinp(signal)=dcinp1+i
    dcan(signal)=dcan1+i
    INC i
  NEXT signal
  DIM ipspiegx(8)
  DIM ipspiegy(8)
  DIM ipspiegz(8)
  DIM iptauschxy(8)
  DIM iptauschxz(8)
  DIM iptauschyz(8)
  DIM ipdreh(2,8)
  DIM ipoffs(2,8)
  DIM ipincs(8)
  DIM ipdecs(8)
  DIM ipsetup(8)
  DIM ipausgabe(8)
  LOCAL anz_buttons
  anz_buttons=ip2-ip1
  FOR signal=1 TO 8
    ipspiegx(signal)=ipspiex1+anz_buttons*(signal-1)
    ipspiegy(signal)=ipspiey1+anz_buttons*(signal-1)
    ipspiegz(signal)=ipspiez1+anz_buttons*(signal-1)
    iptauschxy(signal)=ipverxy1+anz_buttons*(signal-1)
    iptauschxz(signal)=ipverxz1+anz_buttons*(signal-1)
    iptauschyz(signal)=ipveryz1+anz_buttons*(signal-1)
    ipdreh(0,signal)=ipdrehx1+anz_buttons*(signal-1)
    ipdreh(1,signal)=ipdrehy1+anz_buttons*(signal-1)
    ipdreh(2,signal)=ipdrehz1+anz_buttons*(signal-1)
    ipoffs(0,signal)=ipoffsx1+anz_buttons*(signal-1)
    ipoffs(1,signal)=ipoffsy1+anz_buttons*(signal-1)
    ipoffs(2,signal)=ipoffsz1+anz_buttons*(signal-1)
    ipincs(signal)=ipincs1+anz_buttons*(signal-1)
    ipdecs(signal)=ipdecs1+anz_buttons*(signal-1)
    ipsetup(signal)=ipsetup1+anz_buttons*(signal-1)
    ipausgabe(signal)=ipausg1+anz_buttons*(signal-1)
  NEXT signal
  DIM drec(7,maxsignals)
  FOR signal=0 TO 8
    drec(0,signal)=drecx+signal
    drec(1,signal)=drecy+signal
    drec(2,signal)=drecz+signal
    drec(3,signal)=drecvol+signal
    drec(4,signal)=dreczoom+signal
    drec(5,signal)=dreccyc+signal
    drec(6,signal)=drecover+signal
    drec(7,signal)=drec+signal
  NEXT signal
RETURN
PROCEDURE init_variables
  DEFMOUSE 2
  '
  ' ==========================================================================
  ' Hier werden Arrays dimensioniert, Variablen initialisiert, Files
  ' geladen usw.
  ' ==========================================================================
  '
  ' *************    Typen     ********
  DEFWRD "a-z"
  ' *************    Felder    ********
  ' Allgemein
  maxfenster=6
  maxzeilen=6
  maxicons=10
  maxdateien=8
  anz_var=1 ! Anzahl Variationen
  kzeilen=5
  maxsignals=8
  max_setup_types=4
  DIM kanal(maxsignals),vol(maxsignals)
  DIM komment$(kzeilen)
  ' Koordinaten-Werte
  DIM koor_signal(4,maxsignals)                  ! x,y,z,v,zoom umgerechnet fÅr 8 Inputs
  DIM koor_in_alt(4,maxsignals)                 !
  DIM koor_pre_ueberbl(4,maxsignals)            ! Zum Merken der Position vor öberblenden
  DIM koor_add_lfo(4,maxsignals)                ! Offset LFO->SIGNAL
  DIM ext_koor(4)                               ! FÅr externe Maus-Daten
  DIM kneu!(5,maxsignals)                       ! neue Koordinaten vorhanden
  DIM event_number(maxsignals)                  ! MitzÑhler fÅr die einzelne Spuren
  DIM wert_alt(9)
  DIM xk(128,128)                               ! Speicher fÅr 3D-Koordinaten
  DIM yk(128,128)                               ! Speicher fÅr 3D-Koordinaten
  DIM ko(5,maxsignals)                          ! Koeffizienten fÅr andere Inputs (xyzvzoom,inp)
  DIM dreh(3,maxsignals)                        ! Drehung um XYZ-Achsen der Inputs
  DIM tausch!(3,maxsignals)                     ! Tausch XY/XZ/YZ-Achsen der Inputs
  DIM play_inp!(maxsignals)                     ! Schalter fÅr Ausgabe der Inputs
  DIM midich(maxsignals)
  DIM xp(256)                                   ! Speicher fÅr
  DIM zp(256)
  ' MTR-Setup-Parameter
  max_mtr_setups=2000                             ! Anzahl speicherbarer Multirotationen
  DIM mtr_wpos#(maxsignals)                      ! Parameter fÅr Auto-Rotationen
  DIM mtr_winkel#(maxsignals)
  DIM mtr_phase(maxsignals,max_mtr_setups)
  DIM mtr_dreh(maxsignals,max_mtr_setups)
  DIM mtr_seku(maxsignals,max_mtr_setups)
  DIM mtr_richtung(maxsignals,max_mtr_setups)
  DIM mtr_wausschnitt%(maxsignals,max_mtr_setups)
  ARRAYFILL mtr_wausschnitt%(),360
  DIM mtr_modus(maxsignals,max_mtr_setups)
  DIM mtr_form(max_mtr_setups)                    ! Rund/Kante etc.
  DIM mtr_geschw_koeff(maxsignals)              ! ZusÑtzlicher Koeffizient fÅr MTR-Speed
  ARRAYFILL mtr_geschw_koeff(),100
  DIM midi_out|(200)                            ! Speicher fÅr Midi-Events
  DIM mtc_out|(50)                              ! Speicher fÅr Midi-Time-Code
  DIM ueberblend_dist(3,maxsignals)             ! Distanz fÅr jede Koordinate beim öberblenden
  ' alte RTS-Setup-Paremeter
  maxhelplines=1 !   1000
  DIM helptext$(maxhelplines)                   ! Helptexte aus Help-Datei
  DIM obj_men(maxicons)
  maxsetups=1    !   1600                       ! Maximum wg GFA-BeschrÑnkung
  DIM setup(maxsetups/2,74)                     ! Speicher fÅr Setups 1
  DIM setup$(maxsetups/2)                       ! Setup-Beschreibung  1
  DIM setup2(maxsetups/2,74)                    ! Speicher fÅr Setups 2
  DIM setup2$(maxsetups/2)                      ! Setup-Beschreibung  2
  DIM fkeyn(10)                                 ! Nummer des Setups auf FTaste
  ' SPI-Setup-Parameter
  maxspisetups=1000                             ! Anzahl Spiegel-Setups
  DIM spiegel_setup(maxsignals,maxspisetups)    ! Speicher fÅr Spiegel/Hand-Sets
  DIM dreh_setup(2,maxsignals,maxspisetups)     ! Speicher fÅr Drehung x/y/z
  DIM offset_setup(2,maxsignals,maxspisetups)     ! Speicher fÅr Verschiebung x/y/z
  ' GEN-Setup-Parameter
  maxgensetups=30000
  DIM general_setup(5,maxgensetups)             ! Speicher fÅr General-Setups
  maxinpsetups=1000
  DIM input_setup|(maxsignals,maxinpsetups)     ! Speicher fÅr Input_Change-Sets
  DIM ext_maus_koor(2)                          ! Speicher fÅr externe PC-Maus
  ' GEM-Arrays
  DIM text_size(maxfenster)
  DIM laenge(maxdateien)
  DIM selevent!(100,maxfenster)
  DIM fenster(100)
  '  DIM yagh!(maxevents)
  ' Record-Parameter
  DIM record!(7,maxsignals)
  ' x,y,z,volume,zoom,cycle-rec,overdub,rec an/aus
  FOR signal=1 TO maxsignals
    FOR koor=0 TO 4
      record!(koor,signal)=TRUE
    NEXT koor
    record!(5,signal)=FALSE
    record!(6,signal)=FALSE
    record!(7,signal)=TRUE
  NEXT signal
  ' ************* Defaultwerte ********
  '
  ' Midi-Parameter
  device=3
  midi_in_channel=1
  midi_out_channel=16
  sendnoteoff!=FALSE
  note_on=&H9F
  note_off=&H8F
  midi_start=&HFA
  midi_stop=&HFB
  midi_reset=&HFC
  ARRAYFILL mtc_out|(),&HF1
  '
  ' Fenster-Par.
  max_depth=8                   ! Max. Zeichentiefe fÅr Dialogboxen
  allg_help=1
  param_3d=2
  ed_help=3
  helptext=4
  presets=5
  w4mode=presets
  helpdname$="realtim2.hlp"
  depth%=9
  ' random-Auslese-Parameter
  rand_maus=1
  rand_lfo=2
  maus_zoom=100
  mausmodus=0                   ! Normale Steuerung
  '
  ' Anzeige-Parameter
  disp_panpos!=FALSE
  disp_panbreite!=FALSE
  disp_mtrspeed!=FALSE
  disp_vorzur!=FALSE
  disp_volume!=FALSE
  disp_xyzkoor!=TRUE
  disp_zoom!=FALSE
  disp_count!=TRUE
  disp_zeit!=TRUE
  koor_anz!=FALSE
  '
  ' Optionen
  edit_2d!=FALSE
  sperre!=TRUE
  sperre_aussen=0
  mitte=lang
  laenge=-1
  takt=4
  bild=0
  linie=3
  play=1
  rec=2
  stop=0
  mtr_autostop=1
  mtr_pendel=2
  mtr_durchlauf=3
  mtr_richtung=1
  lfo_richtung=1
  edtimer=4
  quant=20
  quant=edtimer*ROUND(quant/edtimer)
  qkoeff=quant/edtimer
  ueberblend=3
  ARRAYFILL mtr_seku(),400
  sendstart!=TRUE
  sendclock!=FALSE
  sendstop!=TRUE
  syncstart!=FALSE
  syncstop!=TRUE
  lfo_para_an!=TRUE
  volume_ausgabe!=TRUE
  count_bar=4
  step_count=192
  maxs=256
  quadrat%=256^2
  hdrei%=256^3
  sx#=64
  gx0=100
  speed$="1"
  linie1%=&HFFFF
  '  linie1%=&X1010101010101010
  linie2%=&X1000100010001000
  '
  ' Grafikmodus
  pan=0
  quadro=1
  single=2
  grafik_aus=3
  grafikmode=pan
  '
  ' Event-öbersicht
  uebers_amplitude=16
  uebers_stepbreite=5
  '
  dat$=LEFT$(DATE$,2)+"/"+MID$(DATE$,4,2)+"/"+RIGHT$(DATE$,2)
  datum$=DATE$
  '  pfad$="D:\CUBAS\*.PRT"
  '  lpfad$="a:"+DIR$(1)+"\*.PRT"
  lpfad$=DIR$(0)+"\*.*"
  sdir$=lpfad$
  xyzdir$=DIR$(0)+"\*.3DS"
  exppfad$="A:\*.EXP"
  genexp$="GEN.EXP"
  mtrexp$="MTR.EXP"
  lfoexp$="LFO.EXP"
  spiexp$="SPI.EXP"
  inpexp$="CMI.EXP"
  pname$="DEFAULT.PRT"
  replace!=TRUE
  innenraum!=FALSE
  aufloesung=8
  ext_maus!=TRUE
  ext_maus_init
  ' FÅr Setup-Angabe
  mtr_angabe!=FALSE
  a!=TRUE
  b!=TRUE
  c!=TRUE
  s#=1
  leer$=SPACE$(60)
  KEYPAD 0
  SPOKE &H484,BCLR(PEEK(&H484),0)
  autor$="bk"
  '  pfad$="e:\gfa\source\konzept\*.*"
  dname$="DEFAULT.RTS"
  init_hn_arrays
  init_inputs
  init_3d_ed
  init_help
  init_mausachsen
  init_lfo_var
  init_waveform
  midi_init(10000)
  autosave!=TRUE
  xykoor
  DEFMOUSE 0
  laden_alle_setups(TRUE)
  '  init_bild
  DEFMOUSE 0
  '
  ' 3-D-Events dimensionieren
  '
  maxpufferlaenge=400
  DIM koor_p(5,max3devents%)     ! Puffer fÅr random-Auslese
  '
  init_3d_events
  '
  rscaddress(desktop,0)
  te!=TRUE
  ~FORM_CENTER(treeaddr%,xbox,ybox,wbox,hbox)
  set_text(deskver,version$)
  set_text(deskdat,vdat$)
  set_text(deskeven,STR$(prev%(header(0)),6))
  te!=FALSE
  winkel=90
  generalsetup=1
  do_inputset(1)
  pres_change_type=0            ! MTR
  do_general_setup(generalsetup)
  ed_init
  edit_2d!=FALSE
  updatemenu
  fill_window(6,TRUE)
RETURN
PROCEDURE init_3d_events
  DEFMOUSE 2
  KEYTEST a
  akttxt$="Verkette 3D-Events ..."
  aktstat_box(TRUE)
  IF a=27
    max3devents%=1000
  ELSE
    max3devents%=MAX(1,MIN(65000,(FRE(0)-40000)/(12+4+4))) ! 35 kb Verwaltung+Restvariable + 300 KB Setups
  ENDIF
  DIM koor(5,max3devents%)       ! x,y,z,v,zoom
  DIM prev%(max3devents%)
  DIM foll%(max3devents%)
  DIM header(maxsignals)
  DIM pointer%(maxsignals)
  ' Alle Listen sind Bidirectional Circular Headed Lists
  ' Header initialisieren
  FOR signal=0 TO maxsignals
    header(signal)=signal
    foll%(header(signal))=header(signal)
    prev%(header(signal))=header(signal)
    pointer%(signal)=header(signal)     ! Zeiger auf aktuelle Position
  NEXT signal
  ' Empty-List initialisieren
  prev%(header(0))=0                    ! Merker fÅr Anzahl verbleibender Nodes
  foll%(header(0))=maxsignals+1
  FOR pointer%=maxsignals+1 TO max3devents%-1
    foll%(pointer%)=pointer%+1
    INC prev%(header(0))
  NEXT pointer%
  foll%(pointer%)=header(0)
  aktstat_box(FALSE)
  DEFMOUSE 0
RETURN
PROCEDURE init_inputs
  ARRAYFILL ko(),1
  FOR signal=1 TO maxsignals
    '    midich(signal)=signal
    play_inp!(signal)=TRUE
    koor_signal(3,signal)=127
    koor_signal(4,signal)=32
  NEXT signal
RETURN
PROCEDURE init_bild
  IF init_bild$=""
    GRAPHMODE 1
    '    DEFFILL 1,2,4
    '    PBOX 0,19,640,400
    COLOR 1
    DEFFILL 1,1
    breite=370
    hoehe=225
    xl=330-breite/2
    xr=330+breite/2
    yo=230+hoehe/2
    yu=230-hoehe/2
    PRBOX xl,yo,xr,yu
    DEFFILL 1,0
    PRBOX 320-breite/2,220+hoehe/2,320+breite/2,220-hoehe/2
    GRAPHMODE 2
    DEFTEXT 1,4,0,32,1
    '    TEXT 166,157,200,""
    DEFTEXT 1,20,0,32,1
    x=170
    TEXT x,155,"R"
    ADD x,18
    TEXT x,155,"e"
    ADD x,18
    TEXT x,155,"a"
    ADD x,16
    TEXT x,155,"l"
    ADD x,14
    TEXT x,155,"t"
    ADD x,16
    TEXT x,155,"i"
    ADD x,18
    TEXT x,155,"m"
    ADD x,18
    TEXT x,155,"e"
    ADD x,20
    TEXT x,155,"m"
    ADD x,18
    TEXT x,155,"o"
    ADD x,18
    TEXT x,155,"v"
    ADD x,18
    TEXT x,155,"e"
    GRAPHMODE 1
    DEFTEXT 1,1,0,4,1
    TEXT 170,170,210,"3D Motion Editor and Utilities"
    DEFTEXT 1,0,0,13,1
    TEXT 170,210,"Cybernetic Arts"
    DEFTEXT ,,,6
    TEXT 170,235,"Copyright 1990"
    TEXT 170,250,version$+"  "+vdat$
    DEFTEXT ,,,6
    TEXT 170,270,"Idee    :  Bernhard Kunkel"
    TEXT 170,285,"Programm:  Bertram Dunskus"
    DEFTEXT ,,,13
    DEFLINE 5,0,0,0
    ed_zoom=30
    p=64
    m=-p
    fxoffset=440
    fzoffset=170
    wuerfel(TRUE,FALSE,1)
    GET xl,yo,xr,yu,init_bild$
  ELSE
    '    PUT xl,yo,init_bild$
  ENDIF
RETURN
PROCEDURE init_3d_ed
  fbreite=126
  fbreit2=fbreite/2
  feinh=fbreite/3
  fein2=feinh/2
  fdia=ROUND(fein2*1.42)
  fqg=(fbreite/2+1)^2 ! Feld^2+1=Grenzwert fÅr Ein- und Ausgaben
  p=fbreit2
  m=-p
RETURN
PROCEDURE init_help
  IF EXIST(helpdname$)
    OPEN "i",#1,helpdname$
    RECALL #1,helptext$(),maxhelplines,helplines%
    CLOSE #1
  ENDIF
RETURN
PROCEDURE init_mausachsen
  DIM mausachsen(2,2)                            ! Achsen fÅr XYZ,Mode
  mausachsen(0,0)=0
  mausachsen(1,0)=1
  mausachsen(2,0)=2
  mausachsen(0,1)=0
  mausachsen(1,1)=2
  mausachsen(2,1)=1
  mausachsen(0,2)=1
  mausachsen(1,2)=0
  mausachsen(2,2)=2
  mausmodus=0
RETURN
PROCEDURE init_lfo_var
  ' LFO-Parameter
  max_lfo_groups=1
  maxlfos=11 ! 0...11 = 12
  maxlfosetups=2000
  DIM lfo_param(9,maxlfos,maxlfosetups)         ! Laufparameter
  DIM lfo_val#(2,maxlfos,max_lfo_groups)        ! Position, Wert
  DIM lfo_ziel(10,maxsignals,maxlfosetups)      ! Verwendung
  DIM lfo_winkel#(maxlfos,max_lfo_groups)       ! Rotationswinkel pro quant
  DIM lfo_an!(maxlfos,max_lfo_groups)           ! FÅr an/aus-Schaltung
  ARRAYFILL lfo_an!(),TRUE                      ! Alle LFO's anschalten
  DIM lfo_geschw_koeff(maxlfos,max_lfo_groups)  ! Faktor wie bei Rotationen
  ARRAYFILL lfo_geschw_koeff(),100
  DIM lfo_setup(1)                              ! Akt. Nummer der LFO-Gruppe
  DIM pauso!(maxlfos,max_lfo_groups)            ! Merker, ob schon Pause
  DIM pausu!(maxlfos,max_lfo_groups)            ! gemacht wurde
  DIM pauso_cumul(maxlfos,max_lfo_groups)       ! ZeitzÑhler
  DIM pausu_cumul(maxlfos,max_lfo_groups)
  DIM lfo_pauso_winkel#(maxlfos,max_lfo_groups)
  DIM lfo_pausu_winkel#(maxlfos,max_lfo_groups)
  DIM lfo_midiin_val(maxlfos,max_lfo_groups)    ! Merker fÅr Midi-Controller-Wert
  DIM lfo_val_alt#(maxlfos,max_lfo_groups)      ! Merker fÅr LFO-Pos vor Pause
  FOR lfo=0 TO maxlfos
    '    lfo_param(2,lfo)=100                        ! Speed = 100%
    '    lfo_param(4,lfo)=100                        ! Ampli = 100%
  NEXT lfo
  DIM panbreite(maxsignals)
  DIM panpos(maxsignals)
  ARRAYFILL panbreite(),100
  ARRAYFILL panpos(),0
  DIM rand_koor#(maxsignals)
  ' GEM-Arrays
  anz_buttons=lf2-lf1
  DIM dlfo(anz_buttons+lf1,maxlfos)
  FOR x=0 TO maxlfos
    dlfo(lfo1,x)=lf11+x*anz_buttons
    dlfo(lf1quell,x)=lf1quell+x*anz_buttons
    dlfo(lf1ctin,x)=lf1ctin+x*anz_buttons
    dlfo(lf1speed,x)=lf1speed+x*anz_buttons
    dlfo(lf1phase,x)=lf1phase+x*anz_buttons
    dlfo(lf1ampl,x)=lf1ampl+x*anz_buttons
    dlfo(lf1offs,x)=lf1offs+x*anz_buttons
    dlfo(lf1pauso,x)=lf1pauso+x*anz_buttons
    dlfo(lf1pausu,x)=lf1pausu+x*anz_buttons
    dlfo(lf1ctout,x)=lf1ctout+x*anz_buttons
  NEXT x
  ' LFO-Patchbay
  dlfstbas=0
  dlfpanpo=dlfstbas+1
  dlfmtrspd=dlfpanpo+1
  dlfvolume=dlfmtrspd+1
  dlfzoom=dlfvolume+1
  dlffree=dlfzoom+1
  dlfposx=dlffree+1
  dlfposy=dlfposx+1
  dlfposz=dlfposy+1
  DIM dlplfo(4*2+8*7,maxsignals-1)
  FOR x=0 TO 3
    ' alle 4-fach Ziele
    dlplfo(dlfstbas,x)=lfbr12+x
    dlplfo(dlfpanpo,x)=lfpan12+x
  NEXT x
  FOR x=0 TO maxsignals-1
    dlplfo(dlfmtrspd,x)=lfmtr1+x
    dlplfo(dlfvolume,x)=lfvol1+x
    dlplfo(dlfzoom,x)=lfzoom1+x
    dlplfo(dlffree,x)=lffree1+x
    dlplfo(dlfposx,x)=lfposx1+x
    dlplfo(dlfposy,x)=lfposy1+x
    dlplfo(dlfposz,x)=lfposz1+x
  NEXT x
  REM dlfqaus=1 !Obj in #21
  REM dlfqmaux=2 !Obj in #21
  REM dlfqmauy=3 !Obj in #21
  REM dlfqmidi=4 !Obj in #21
  REM dlfqrand=5 !Obj in #21
  REM dlfqsin=6 !Obj in #21
  REM dlfqstri=7 !Obj in #21
  REM dlfqsawu=8 !Obj in #21
  REM dlfqsawd=9 !Obj in #21
  REM dlfoqsqr=10 !Obj in #21
  REM dlfo1=1 !Obj in #22
  REM dlfo2=2 !Obj in #22
  maxlfoquellen=10
  DIM dlqlfo(maxlfoquellen)
  dlqlfo(0)=dlfqaus
  dlqlfo(1)=dlfqmaux
  dlqlfo(2)=dlfqmauy
  dlqlfo(3)=dlfqmidi
  dlqlfo(4)=dlfqsin
  dlqlfo(5)=dlfqstri
  dlqlfo(6)=dlfqsawu
  dlqlfo(7)=dlfqsawd
  dlqlfo(8)=dlfqrand
  dlqlfo(9)=dlfoqsqr
  dlqlfo(10)=dlfqpitc
  DIM lfo_quell$(maxlfoquellen)
  lfo_quell$(0)="AUS"
  lfo_quell$(1)="M-> X"
  lfo_quell$(2)="M-> Y"
  lfo_quell$(3)="Contr"
  lfo_quell$(4)="~~~~"
  lfo_quell$(5)="/\/\"
  lfo_quell$(6)="/|/|"
  lfo_quell$(7)="|\|\"
  lfo_quell$(8)="Random"
  lfo_quell$(9)="_-_-"
  lfo_quell$(10)="Pitchb"
  DIM dlzlfo(maxlfos+1)
  dlzlfo(0)=dlfo0
  FOR lfo=1 TO maxlfos+1
    dlzlfo(lfo)=dlzlfo(0)+lfo
  NEXT lfo
  lfo=0
  lfo_setup(1)=maxlfosetups
RETURN
PROCEDURE init_waveform
  maxwaves=5
  akttxt$="Wellenformen berechnen ..."
  aktstat_box(TRUE)
  maxwavesteps=359
  DIM wave(maxwavesteps,maxwaves)
  LET waveampl=30000
  FOR waveform=0 TO maxwaves
    FOR winkel=0 TO maxwavesteps
      SELECT waveform
      CASE 0
        ' Sinus
        wave(winkel,waveform)=SIN(2*PI*winkel/360)*waveampl
      CASE 1
        ' Dreieck
        SELECT winkel
        CASE  TO 89
          ' aufsteigend
          wave(winkel,waveform)=(winkel)*waveampl/90
        CASE 90 TO 269
          ' absteigend
          wave(winkel,waveform)=waveampl-(winkel-90)*waveampl/90
        CASE 270 TO 359
          wave(winkel,waveform)=-waveampl+(winkel-269)*waveampl/90
        ENDSELECT
      CASE 2
        ' Saw up
        wave(winkel,waveform)=((winkel+0) MOD 360)*waveampl/360-waveampl
      CASE 3
        ' Saw down
        wave(winkel,waveform)=-((winkel+0) MOD 360)*waveampl/360+waveampl
      CASE 4
        ' Rechteck
        IF winkel<180
          wave(winkel,waveform)=waveampl
        ELSE
          wave(winkel,waveform)=-waveampl
        ENDIF
      CASE 5
        ' Spezial-Welle fÅr "Dreieck-Rotation"
        SELECT winkel
        CASE  TO 45,316 TO
          wave(winkel,waveform)=waveampl
        CASE 46 TO 135
          wave(winkel,waveform)=waveampl*(90-winkel)/45
        CASE 136 TO 225
          wave(winkel,waveform)=-waveampl
        CASE 226 TO 315
          wave(winkel,waveform)=-waveampl*(270-winkel)/45
        ENDSELECT
      ENDSELECT
      IF FALSE !winkel MOD 10=0
        LINE winkel,200,winkel,200-wave(winkel,waveform)*200/waveampl
      ENDIF
    NEXT winkel
    '    KEYGET a
  NEXT waveform
  aktstat_box(FALSE)
RETURN
'
' * * *   Listen-Verwaltung   * * *
PROCEDURE insert_node(node%)
  LOCAL pointer%
  pointer%=foll%(node%)                  ! alten Nachfolger merken
  foll%(node%)=foll%(header(0))          ! 1. freien Node holen
  foll%(header(0))=foll%(foll%(node%))   ! Empty-List verkÅrzen
  foll%(foll%(node%))=pointer%           ! Alten Nachfolger anbinden
  prev%(foll%(node%))=node%              ! Zeiger vom Nachfolger zurÅck
  DEC prev%(header(0))                   ! Merker verbl. Nodes
RETURN
PROCEDURE delete_node(node%)
  foll%(prev%(node%))=foll%(node%)       ! Link v. Vorh. zum NÑchsten
  prev%(foll%(node%))=prev%(node%)       ! Link v. NÑchsten zum Vorh.
  foll%(node%)=foll%(header(0))          ! Node vor 1. freien Node setzen
  foll%(header(0))=node%                 ! Header auf Node zeigen lassen
  INC prev%(header(0))                   ! Merker verbl. Nodes
RETURN
FUNCTION get_last_node(signal)
  LOCAL pointer%
  ' Gibt letzten Knoten des Signals zurÅck
  laenge%=0
  pointer%=foll%(header(signal))
  WHILE pointer%<>header(signal)
    pointer%=foll%(pointer%)
    INC laenge%
  WEND
  ' In laenge% steht die Anzahl der Knoten fÅr das Signal
  RETURN pointer%
ENDFUNC
'
' * * *   Fenster    * * *
'
PROCEDURE schl_fenster(fenster)
  @closew(fenster)
  '  w4mode=allg_help
  IF fenster=3
    stop_3d_timer
  ENDIF
  updatemenu
  find_top_window
RETURN
PROCEDURE find_top_window
  LOCAL x,y,z ! VOID
  ~WIND_GET(window,10,window,x,y,z)
  ' window enthÑlt jetzt Nummer des obersten Fensters
RETURN
PROCEDURE minif(mode)
  SELECT mode
  CASE 1,2
    lift_point00
    fill_window(4,TRUE)
  CASE 0
    @closew(4)
  ENDSELECT
RETURN
'
' * * *   Grafik- und Fenster-Routinen   * * *
'
PROCEDURE def_mouse(typ)
  IF typ<>mouse
    DEFMOUSE typ
    mouse=typ
    SHOWM
  ENDIF
RETURN
PROCEDURE help
  IF on_screen!(4)
    '    @closew(4)
  ENDIF
  DEFTEXT ,,,13
  SELECT w4mode
  CASE ed_help
    '    set_typew(4,1)
    titlew(4,"Editor-Hilfe")
    infow(4,"",FALSE)
    ncols(4)=30
    nlines(4)=15
  CASE allg_help
    '    set_typew(4,4)
    titlew(4,"Allgemeine Hilfe")
    infow(4,"",FALSE)
    ncols(4)=30
    nlines(4)=17
  CASE param_3d
    '    set_typew(4,4)
    titlew(4,"3-D-Parameter")
    infow(4,"",FALSE)
    ncols(4)=30
    nlines(4)=25
  CASE helptext
    '    set_typew(4,0)
    titlew(4,"Hilfe-Datei")
    infow(4,helpdname$,FALSE)
    ncols(4)=80
    nlines(4)=MIN(32000,helplines%)
  CASE presets
    titlew(4," Preset-öbersicht ")
    infow(4,"Eintragung anklicken zum AuswÑhlen!",FALSE)
    ncols(4)=80
    nlines(4)=maxsetups
    upper(4)=setupnr
  ENDSELECT
  fill_window(4,TRUE)
RETURN
PROCEDURE allg_help
  DEFTEXT ,,,13
  gprint(3,1," Laden                 ^o")
  gprint(3,2," Speichern             ^s")
  gprint(3,3," MPX+Speichern          M")
  gprint(3,4," Variat. erst.          V")
  gprint(3,5," Grafik-Seite           G")
  gprint(3,6," Kopfdaten              K")
  gprint(3,7," Events                 M")
  gprint(3,8," Andere Variation     ( )")
  gprint(3,9," BlÑttern             + -")
  gprint(3,10," Erste Seite           /")
  gprint(3,11," Letzte Seite          *")
  gprint(3,12," Input Filter          I")
  gprint(3,13," QualitÑt              Q")
  gprint(3,14," Ende                 ^Q")
  gprint(3,16," ^ bedeutet CONTROL-Taste")
  gprint(3,17,"  bedeutet ALTERNATE-Taste")
RETURN
PROCEDURE wuerfel_drehen
  IF on_screen!(3)
    ADD winkel,5
    drehwuerfel(TRUE,FALSE,2,winkel)
  ENDIF
RETURN
PROCEDURE aktstat_box(flag!)
  rscaddress(daktstat,0)
  IF flag!
    ~FORM_CENTER(treeaddr%,xbox,ybox,wbox,hbox)
    ybox=hwork(0)-hbox-6
    OB_Y(treeaddr%,0)=ybox+3
    GET xbox,ybox,xbox+wbox,ybox+hbox,underbox$
    set_text(dxakttxt,akttxt$)
    @obj_draw(0,depth%)
  ELSE
    PUT xbox,ybox,underbox$
  ENDIF
RETURN
'
' * * *   3 D Eingabe   * * *
'
PROCEDURE ed_init
  exit!=FALSE
  stop_3d_timer
  mode=stop
  count%=0
  max=fbreit2
  vol=127                               !***   keine énderung   ***
  zoom=32
  reset_pointers
RETURN
PROCEDURE ed_aufbau
  DEFLINE 1,2
  GRAPHMODE 1
  '  w4mode=ed_help
  IF window<>5 AND window<>6
    find_top_window
  ENDIF
  SELECT window
  CASE 6
    edit_2d!=FALSE
    IF on_screen!(5)
      @closew(5)
    ENDIF
  CASE 5
    edit_2d!=TRUE
    IF on_screen!(6)
      @closew(6)
    ENDIF
  ENDSELECT
  '
  CLIP xwork(window),ywork(window),wwork(window),hwork(window)
  editor_parameter_feld
  '
  '
  IF edit_2d!
    IF innenraum!
      ed_zoom=200*(wwork(5)-ed_par_breite)/440
      fxoffset=(fbreite/2)*ed_zoom/100
      fzoffset=(fbreite/2)*ed_zoom/100
      fyoffset=65*ed_zoom/100
      GRAPHMODE 1
      DEFLINE 3
      BOX @xp(-fein2),@zp(-fein2),@xp(fein2),@zp(fein2)
      PLOT @xp(fbreite/2),@zp(fbreite/2)
      GRAPHMODE 2
      DEFLINE &X11111111111111110101010101010110
      CIRCLE @xp(0),@zp(0),ed_zoom*feinh*SQR(2)/100
      LINE @xp(-fein2),@zp(-fein2),@xp(fein2),@zp(fein2)
      LINE @xp(-fein2),@zp(fein2),@xp(fein2),@zp(-fein2)
      DEFLINE 1
      GRAPHMODE 3
      '    GET fxoffset,fzoffset+38,fxoffset+fbreite,fzoffset+fbreite+38,ed_feld$
      DEFTEXT ,,,6
      TEXT @xp(-fein2)-16,@zp(-fein2),"1"
      TEXT @xp(fein2)+8,@zp(-fein2),"2"
      TEXT @xp(fein2)+8,@zp(fein2)+4,"3"
      TEXT @xp(-fein2)-16,@zp(fein2)+4,"4"
      DEFTEXT ,,,13
    ELSE
      ed_zoom=200*(wwork(5)-ed_par_breite)/400
      fxoffset=10+(fbreite/4)*ed_zoom/100
      fzoffset=10+(fbreite/4)*ed_zoom/100
      fyoffset=65*ed_zoom/100
      GRAPHMODE 1
      DEFFILL 1,0
      PBOX @xp(m),@zp(m),@xp(p),@zp(p)
      DEFLINE 3
      BOX @xp(-fein2),@zp(-fein2),@xp(fein2),@zp(fein2)
      PLOT @xp(fbreite/2),@zp(fbreite/2)
      GRAPHMODE 2
      DEFLINE &X11111111111111110101010101010110
      CIRCLE @xp(0),@zp(0),ed_zoom*feinh/SQR(2)/100
      CIRCLE @xp(0),@zp(0),ed_zoom*feinh*SQR(2)/100
      LINE @xp(-fbreite/2),@zp(-fbreite/2),@xp(fbreite/2),@zp(fbreite/2)
      LINE @xp(-fbreite/2),@zp(fbreite/2),@xp(fbreite/2),@zp(-fbreite/2)
      DEFLINE 1
      GRAPHMODE 3
      '    GET fxoffset,fzoffset+38,fxoffset+fbreite,fzoffset+fbreite+38,ed_feld$
      DEFTEXT ,,,6
      TEXT @xp(-fbreit2)-16,@zp(-fbreit2),"1"
      TEXT @xp(fbreit2)+8,@zp(-fbreit2),"2"
      TEXT @xp(fbreit2)+8,@zp(fbreit2)+4,"3"
      TEXT @xp(-fbreit2)-16,@zp(fbreit2)+4,"4"
      DEFTEXT ,,,13
    ENDIF
  ELSE
    ' 3-D-Mode
    ed_zoom=MIN(120*(wwork(6)-ed_par_breite)/400,140*hwork(6)/400)
    fxoffset=120*ed_zoom/100
    SELECT ed_zoom
    CASE  TO 200
      fzoffset=180*ed_zoom/100-385
    DEFAULT
      fzoffset=180*ed_zoom/100-375
    ENDSELECT
    fyoffset=65*ed_zoom/100
    IF innenraum!
      signal=1
      rahmen!=TRUE
      kreuz!=TRUE
      innenraum!=FALSE
      ' xzpos
      wuerfel(TRUE,FALSE,2)
      '
      SELECT ed_zoom
      CASE  TO 200
        DEFTEXT ,,,4
      CASE 201 TO
        DEFTEXT ,,,6
      ENDSELECT
      3d_text(m,m,m,"1")
      3d_text(p,m,m,"2")
      3d_text(p,m,p,"3")
      3d_text(m,m,p,"4")
      3d_text(m,p-4,m,"5")
      3d_text(p,p-4,m,"6")
      3d_text(p,p-4,p,"7")
      3d_text(m,p-4,p,"8")
      DEFTEXT ,,,13
      innenraum!=TRUE
    ELSE
      signal=1
      rahmen!=TRUE
      kreuz!=TRUE
      ' xzpos
      wuerfel(TRUE,FALSE,2)
      innenflaechen
      '
      SELECT ed_zoom
      CASE  TO 200
        DEFTEXT ,,,4
      CASE 201 TO
        DEFTEXT ,,,6
      ENDSELECT
      3d_text(m,m,m,"1")
      3d_text(p,m,m,"2")
      3d_text(p,m,p,"3")
      3d_text(m,m,p,"4")
      3d_text(m,p-4,m,"5")
      3d_text(p,p-4,m,"6")
      3d_text(p,p-4,p,"7")
      3d_text(m,p-4,p,"8")
      DEFTEXT ,,,13
    ENDIF
  ENDIF
  '  GET xwork(window),ywork(window),xwork(window)+390,ywork(window)+hwork(window),ed_feld$
  DEFLINE 1,1
  ' mtr_reset
  ' reset_lfos
  disp_mausmodus
  ed_parameter_disp
RETURN
PROCEDURE editor_parameter_feld
  SELECT hwork(window)
  CASE  TO 400
    ed_parameter_gross!=FALSE
  CASE 400 TO
    ed_parameter_gross!=TRUE
  ENDSELECT
  IF ed_parameter_gross!
    DEFTEXT ,,,13
    htext=16
    wtext=8
  ELSE
    DEFTEXT ,,,4
    htext=6
    wtext=6
  ENDIF
  ed_par_breite=30*wtext
  ed_par_y0=htext*2
  ed_par_hoehe=19*htext
  ed_par_x0=wwork(window)-ed_par_breite-wtext
  BOX ed_par_x0-wtext,ed_par_y0-htext*1.5,ed_par_x0+ed_par_breite,ed_par_y0+ed_par_hoehe
  FOR signal=1 TO maxsignals
    TEXT ed_par_x0,ed_par_y0+signal*htext,STR$(midich(signal),2)
  NEXT signal
  TEXT ed_par_x0+3*wtext,ed_par_y0,"PBre"
  TEXT ed_par_x0+8*wtext,ed_par_y0,"PPos"
  TEXT ed_par_x0+13*wtext,ed_par_y0,"Spd"
  TEXT ed_par_x0+18*wtext,ed_par_y0,"Vol"
  TEXT ed_par_x0+23*wtext,ed_par_y0,"V+Z"
  TEXT ed_par_x0,ed_par_y0+htext*10,"F/E:"
  FOR signal=1 TO maxsignals
    TEXT ed_par_x0,ed_par_y0+10*htext+signal*htext,STR$(signal)+":"
  NEXT signal
  TEXT ed_par_x0+3*wtext,ed_par_y0+htext*9," L-R"
  TEXT ed_par_x0+8*wtext,ed_par_y0+htext*9," O-U"
  TEXT ed_par_x0+13*wtext,ed_par_y0+htext*9," V-H"
  TEXT ed_par_x0+18*wtext,ed_par_y0+htext*9,"Zoom"
  TEXT ed_par_x0+23*wtext,ed_par_y0+htext*9,"Count"
  ed_set_x0=ed_par_x0
  ed_set_y0=ed_par_y0+htext*2.5+ed_par_hoehe
  BOX ed_set_x0-wtext,ed_set_y0-12,ed_set_x0+ed_par_breite,ed_set_y0+192
  DEFTEXT ,,,13
  TEXT ed_set_x0,ed_set_y0+40,"Maus :"
  TEXT ed_set_x0,ed_set_y0+56,"Count:"
  TEXT ed_set_x0,ed_set_y0+72,"Zeit :"
  TEXT ed_set_x0,ed_set_y0+88,"Quant:"
  disp_mausmodus
  disp_quant
  sperre(FALSE,TRUE)
  cycle(FALSE,TRUE)
  zeitl(FALSE,TRUE)
  richtung(FALSE,FALSE,TRUE)
  pause(FALSE,TRUE)
  DEFTEXT ,,,13
  TEXT ed_set_x0,ed_set_y0+140,"123456789012"
  TEXT ed_set_x0+104,ed_set_y0+156,"ZEIGEN"
  TEXT ed_set_x0+104,ed_set_y0+172,"RECORD"
  TEXT ed_set_x0+104,ed_set_y0+188,"LFO's"
  DEFTEXT ,,,13
  FOR signal=1 TO maxsignals
    play_inp_status(signal)
  NEXT signal
  signal=1
  FOR lfo=0 TO maxlfos
    lfo_status(lfo)
  NEXT lfo
  '  KEYPRESS 48 ! "0" fÅr Stop
  DEFLINE 1,1
  SHOWM
RETURN
PROCEDURE ed_get
  ti%=TIMER
  LOCAL maus_tasten_speed
  change!=TRUE
  IF ext_maus!
    ext_maus_calc
  ENDIF
  IF rand_mode=0 AND (mtr_richtung(0,mtr_setup)=2 OR mtr_richtung(0,mtr_setup)=0)
    ' Maus-Koordinaten immer berechnen, auûer wenn Multirotation 0 an
    taste%=BIOS(11,-1) ! kbshift()
    maus_tasten_speed=2+BTST(taste%,2)*-4+BTST(taste%,1)*-8+BTST(taste%,3)*-16
    maus_tasten_speed=maus_tasten_speed*quant/40
    '  PRINT AT(1,1);STR$(a,2)
    SELECT MOUSEK
    CASE 1
      ' runter
      yk=MAX(-max,yk-maus_tasten_speed)
    CASE 2
      ' rauf
      yk=MIN(max,yk+maus_tasten_speed)
    ENDSELECT
    ' Bezugsbasis: +63 ... -63
    x=(MOUSEX-wwork(0)/2)*maus_zoom*127/wwork(0)/100
    y=ROUND(yk*maus_zoom/100)
    z=(MOUSEY-hwork(0)/2)*maus_zoom*127/hwork(0)/100
    IF sperre!
      y=MAX(MIN(y,sperre_aussen),-sperre_aussen)
    ENDIF
    yk=ROUND(y*100/maus_zoom)
    dxz=SQR(x*x+z*z)
    '  dxyz=SQR(x*x+y*y+z*z)
    IF sperre! AND dxz>sperre_aussen   !fein2*1.4142
      verh=100*sperre_aussen/dxz
    ELSE
      verh=100
    ENDIF
    IF innenraum!
      koor_signal(mausachsen(0,mausmodus),0)=x*verh/100
      koor_signal(mausachsen(1,mausmodus),0)=y*verh/100
      koor_signal(mausachsen(2,mausmodus),0)=z*verh/100
    ELSE
      koor_signal(mausachsen(0,mausmodus),0)=x*125*verh/10000
      koor_signal(mausachsen(1,mausmodus),0)=y*125*verh/10000
      koor_signal(mausachsen(2,mausmodus),0)=z*125*verh/10000
    ENDIF
  ENDIF
  koor_signal(3,0)=vol
  koor_signal(4,0)=zoom
  '
  ' FÅllen der koor_input() mit Daten aus Sequencer oder aktueller Steuerung
  FOR signal=1 TO maxsignals
    IF play_inp!(signal)
      FOR koor=0 TO 4
        IF record!(6,signal) AND NOT record!(koor,signal)
          ' Nur wenn Overdub an und Record(koor) aus: Daten aus Sequencer holen
          koor_signal(koor,signal)=koor(koor,pointer%(signal))
        ELSE
          IF inmausext! AND (signal MOD 2=0)
            SELECT koor
            CASE  TO 2
              koor_signal(koor,signal)=ext_koor(koor)
            CASE 3,4
              ' Vol und Zoom vom jeweils korrespondierenden internen Wert Åbernehmen
              koor_signal(koor,signal)=koor_signal(koor,signal-1)
            ENDSELECT
          ELSE
            koor_signal(koor,signal)=koor_signal(koor,0)
          ENDIF
        ENDIF
      NEXT koor
    ENDIF
  NEXT signal
  '
  IF ueberblend_count%=0
    ' Solange wie noch keine öberbl. angefangen hat
    '
    ' Balance durchfÅhren
    '    do_balance     ! Noch nicht drin
    ' LFO's berechnen
    calc_lfos
    '
    ' Koordinaten berechnen
    set_koor
    '
  ENDIF
  IF ueberblend_aktiv!
    ' öberblendung im vollen Gange
    ueberblenden
  ENDIF
  ' Anzeige der 8 KanÑle
  ed_disp
  '
  '  DEFMOUSE 7
  '
  ' Speichern in Sequencer
  '
  FOR signal=1 TO maxsignals
    IF record!(7,signal)
      FOR koor=0 TO 4
        IF record!(koor,signal)
          koor(koor,pointer%(signal))=koor_signal(koor,signal)
        ENDIF
      NEXT koor
    ENDIF
  NEXT signal
  GRAPHMODE 1
  q=TIMER-ti%+8                          ! Sicherheit
  IF q>quant
    INC loquant
    IF loquant>1
      ' Wenn mehr als einmal Quant-Wert Åberschritten wurde
      '      stop_3d_timer
      PRINT CHR$(7);
      setquant(q)
      disp_quant
      '      start_3d_timer(edtimer)
      loquant=0
    ENDIF
  ENDIF
RETURN
PROCEDURE ed_disp
  GRAPHMODE 1
  COLOR 1
  CLIP xwork(window),ywork(window),wwork(window),hwork(window)
  IF count%>0 ! AND mode<>stop
    GRAPHMODE 3
    ' in CALC-LFO's evtl neue Koor's fÅr FÅhrungspunkte
    IF edit_2d!
      '      LINE @xp(@limit(za#*koor(0,MAX(0,count%-1)))),@zp(@limit(za#*koor(2,MAX(0,count%-1)))),@xp(@limit(zn#*koor(0,count%))),@zp(@limit(zn#*koor(2,count%)))
      '      GRAPHMODE 1
      '      za#=koor(4,MAX(0,count%-1))*4/127
      '      zn#=koor(4,count%)*4/127
      '      IF koor(1,count%-1)*za#<>koor(1,count%)*zn#
      '        DEFTEXT 1,0,2700,6
      '        TEXT @xp(-fbreit2)-16,@zp(@limit(zn#*-koor(1,count%)))-28,"      "
      '        DEFTEXT 1,0,0,13
      '      ENDIF
    ELSE
      draw8ch
      IF linie_3d!
        '        za#=koor(4,MAX(0,count%-1))*4/127
        '        zn#=koor(4,count%)*4/127
        '        3d_line(koor(0,count%-1)*za#,koor(1,count%-1)*za#,koor(2,count%-1)*za#,koor(0,count%)*zn#,koor(1,count%)*zn#,koor(2,count%)*zn#)
      ENDIF
      IF fadenkreuz_3d!
        fadenkreuz
      ENDIF
      '      DEFLINE 1
      '      GRAPHMODE 1
    ENDIF
  ENDIF
  GRAPHMODE 1
  DEFLINE 1,1
  DEFTEXT ,,,13
  TEXT ed_set_x0+56,ed_set_y0+56,STR$(count%,5)
  ed_parameter_disp
  midi_out
  merk_koor
RETURN
PROCEDURE ed_parameter_disp
  GRAPHMODE 1
  COLOR 1
  IF ed_parameter_gross!
    DEFTEXT ,,,13
  ELSE
    DEFTEXT ,,,4
  ENDIF
  IF koor_anz!
    FOR ziel=0 TO 3
      IF disp_panbreite!
        TEXT ed_par_x0+3*wtext,ed_par_y0+2*htext*(ziel)+htext*1.5,STR$(panbreite(ziel),4)
      ENDIF
      IF disp_panpos!
        TEXT ed_par_x0+8*wtext,ed_par_y0+2*htext*(ziel)+htext*1.5,STR$(panpos(ziel),4)
      ENDIF
    NEXT ziel
  ENDIF
  FOR signal=0 TO 8
    IF koor_anz! OR signal=0
      IF play_inp!(signal) OR signal=0
        IF disp_xyzkoor!
          FOR koor=0 TO 2
            TEXT ed_par_x0+3*wtext+koor*5*wtext,ed_par_y0+htext*10+htext*signal,STR$(INT(koor_signal(koor,signal)),4)
            IF ext_maus! AND signal=0
              TEXT ed_par_x0+18*wtext+koor*4*wtext,ed_par_y0+htext*10,STR$(INT(ext_maus_koor(koor)),3)
            ENDIF
          NEXT koor
        ENDIF
        IF signal>0
          IF disp_mtrspeed!
            TEXT ed_par_x0+13*wtext,ed_par_y0+htext*signal,STR$(mtr_geschw_koeff(signal),4)
          ENDIF
          IF disp_vorzur!
            TEXT ed_par_x0+23*wtext,ed_par_y0+htext*signal,STR$(rand_koor#(signal),4)
          ENDIF
          IF disp_count!
            TEXT ed_par_x0+23*wtext,ed_par_y0+htext*10+htext*signal,STR$(event_number(signal),4)
          ENDIF
          IF disp_zoom!
            TEXT ed_par_x0+18*wtext,ed_par_y0+htext*10+htext*signal,STR$(INT(koor_signal(4,signal)*400/128),4)
          ENDIF
          IF disp_volume!
            TEXT ed_par_x0+18*wtext,ed_par_y0+htext*signal,STR$(koor_signal(3,signal),4)
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  NEXT signal
  DEFTEXT ,,,13
RETURN
PROCEDURE ed_play
  '  PRINT CHR$(7);
  ti%=TIMER
  FOR signal=1 TO maxsignals
    FOR koor=0 TO 4
      koor_signal(koor,signal)=koor(koor,pointer%(signal))
    NEXT koor
  NEXT signal
  ed_disp
  IF FALSE !triggermode!
    count%=0
    KEYPRESS 48     ! Stop
    KEYPRESS 13     ! In Startposition
    ' ZurÅck auf 0 setzen
  ENDIF
  ' ELSE IF cycle!
  '  DEC count%
  '  IF fadenkreuz_3d! AND NOT edit_2d!
  '  draw_fdk(koor(0,count%),koor(1,count%),koor(2,count%),koor(4,count%))
  ' ENDIF
  '  count%=1
  '  editor_feld
  '  ed_disp(count%)
  '  OUT 3,248,248,248,248,248,248
  GRAPHMODE 1
  '  gprint(70,1,STR$(TIMER-ti%,2))
  q=TIMER-ti%+5                          ! Sicherheit
RETURN
PROCEDURE ed_taste(shiftstate%)
  '  KEYTEST a%
  taste=BYTE(ascii%)
  taste$=CHR$(ascii%)
  SELECT taste
  CASE 13
    ti%=TIMER
    editor_feld
    HIDEM
    mode=play
    IF syncstart!
      exit!=FALSE
      TEXT ed_set_x0,ed_set_y0+120,"SYNC PLAY"
      DO
        IF BIOS(1,3)
          midiin=BIOS(2,3) AND 255
          exit!=midiin=midi_start
          IF midiin=&HCF                ! Prog-Change Ch 16
            prognr=BIOS(2,3) AND 255
            exit!=prognr=0
            triggermode!=TRUE
          ENDIF
        ELSE
          KEYTEST taste
          exit!=taste<>0
        ENDIF
        EXIT IF exit!
      LOOP
    ENDIF
    exit!=FALSE
    send_start
    ARRAYFILL kneu!(),TRUE
    loquant=0                           ! Merker fÅr Quant-öberschreitung
    start_3d_timer(edtimer)
    GRAPHMODE 1
    TEXT ed_set_x0,ed_set_y0+120,"PLAY     "
    '    DEFMOUSE 7
  CASE "*"
    ti%=TIMER
    ARRAYFILL kneu!(),TRUE
    HIDEM
    send_start
    mode=rec
    TEXT ed_set_x0,ed_set_y0+120,"SYNC REC "
    IF syncstart!
      exit!=FALSE
      DO
        IF BIOS(1,3)
          exit!=(BIOS(2,3) AND 255)=midi_start
        ELSE
          KEYTEST taste
          exit!=taste<>0
        ENDIF
        EXIT IF exit!
      LOOP
    ENDIF
    exit!=FALSE
    PRINT CHR$(7);
    nzeit(qframes%/4)
    '    full!=TRUE
    '    send_timec
    '    full!=FALSE
    loquant=0                           ! Merker fÅr Quant-öberschreitung
    start_3d_timer(edtimer)
    GRAPHMODE 1
    TEXT ed_set_x0,ed_set_y0+120,"RECORD   "
    '    DEFMOUSE 7
  CASE "u"
    ' normal
    richtung(TRUE,TRUE,TRUE)
  CASE "U"
    ' shift
    richtung(TRUE,FALSE,TRUE)
  CASE ""
    ' control
    richtung(FALSE,TRUE,TRUE)
  CASE "/"
    cycle(TRUE,TRUE)
  CASE "p"
    pause(TRUE,TRUE)
  CASE "s"
    sperre(TRUE,TRUE)
  CASE 26
    ' CTRL-<z>
    zeitl(TRUE,TRUE)
    start_3d_timer(edtimer*(1-zeitl!*5))
  CASE "("
    stop_3d_timer
    count%=MAX(0,count%-1)               ! Wird in ed_play inkrementiert
    IF count%>0
      FOR signal=1 TO maxsignals
        pointer%(signal)=prev%(prev%(pointer%(signal)))
        DEC event_number(signal)
      NEXT signal
      ed_play
    ENDIF
  CASE ")"
    count%=MIN(max3devents%,count%+1)
    stop_3d_timer
    FOR signal=1 TO maxsignals
      pointer%(signal)=foll%(pointer%(signal))
      INC event_number(signal)
    NEXT signal
    ed_play
  DEFAULT
    '    scan=BYTE(SHR(ascii%,16))
    SELECT scancode%
    CASE &H39,&H70
      ' <SPACE>,"[0]"
      IF NOT (mtr_angabe! AND scancode%=&H70)
        ed_stop
      ENDIF
    ENDSELECT
  ENDSELECT
  IF exit!=TRUE AND mode=stop AND count%=0
    schl_fenster(window)
  ENDIF
RETURN
PROCEDURE ed_stop
  stop_3d_timer
  IF mode<>stop
    PRINT CHR$(7);
    mode=stop
    GRAPHMODE 1
    ' DEFMOUSE 7
    TEXT ed_set_x0,ed_set_y0+120,"STOP     "
    IF sendstop!
      OUT 3,midi_stop         ! Midi-Stop
    ENDIF
    SHOWM
    '      INC count%
  ELSE
    count%=0
    reset_pointers
    qframes%=0
    editor_feld
    nzeit(0)
    ed_disp
    stop_3d_timer
    IF sendstop!
      OUT 3,midi_reset         ! Midi-Stop
    ENDIF
    mtr_reset
    reset_lfos
    calc_lfos
    ' DEFMOUSE 7
    SHOWM
  ENDIF
RETURN
PROCEDURE 3d_timer
  ' EVERY STOP
  startwork%=TIMER
  ADD qframes%,edtimer/2
  IF qframes%-lastzeitframe%>=16
    nzeit(qframes%/4)
    IF disp_zeit!
      TEXT ed_set_x0+56,ed_set_y0+72,STR$(hh,2)+":"+STR$(mm,2)+":"+STR$(ss,2)+":"+STR$(ff,2)
    ENDIF
    lastzeitframe%=qframes%
  ENDIF
  IF sendtimec!
    '    PRINT AT(1,1);STR$(qframes%,5)
    send_timec
  ENDIF
  IF qframes%-lastcountframe%>=qkoeff*2
    lastcountframe%=qframes%
    count%=MIN(max3devents%,count%+1)
    SELECT mode
    CASE play
      playing!=FALSE
      FOR signal=1 TO maxsignals
        IF foll%(pointer%(signal))<>header(signal)
          ' Normal weiter im Text
          playing!=TRUE
          pointer%(signal)=foll%(pointer%(signal))
          INC event_number(signal)
        ELSE
          ' Beim letzten Event bleiben
          IF cycle!
            playing!=TRUE
            pointer%(signal)=foll%(header(signal))
            event_number(signal)=1
          ENDIF
        ENDIF
      NEXT signal
      IF playing!
        ed_play
      ELSE
        ' Wenn alle KanÑle fertig sind
        ed_stop
      ENDIF
    CASE rec
      FOR signal=1 TO maxsignals
        IF foll%(pointer%(signal))=header(signal)
          IF record!(5,signal)
            ' Bei Cycle-Record wieder zum Anfang springen
            pointer%(signal)=foll%(header(signal))
            fill_window(window,FALSE)
            '            qframes%=0
            playing!=TRUE
            event_number(signal)=1
          ELSE
            ' Wenn kein Cycle-Record: Neuen Node anhÑngen
            IF record!(7,signal)        ! aber nur wenn Kanal-Rec an
              insert_node(pointer%(signal))
              pointer%(signal)=foll%(pointer%(signal))
              INC event_number(signal)
            ENDIF
          ENDIF
        ELSE
          ' Normal weiter im Text
          pointer%(signal)=foll%(pointer%(signal))
          INC event_number(signal)
        ENDIF
      NEXT signal
      ed_get
    ENDSELECT
  ENDIF
  startwork%=TIMER-startwork%
  ' Beim arbeiten verpaûte qframes aufholen
  ADD qframes%,ROUND(startwork%/2)
  IF qframes%>2300000
    '    STOP
  ENDIF
  IF mode<>stop
    ' EVERY  CONT
  ENDIF
RETURN
PROCEDURE stop_3d_timer
  ' EVERY STOP
  rscaddress(hauptmen,0)
  x=MENU_BAR(treeaddr%,1)
  ON MENU GOSUB menuevent
RETURN
PROCEDURE start_3d_timer(edtimer)
  ' MenÅ aus
  rscaddress(hauptmen,0)
  ~MENU_BAR(treeaddr%,0)
  lastzeitframe%=0
  lastcountframe%=0
  CLIP xwork(window),ywork(window),wwork(window),hwork(window)
  '  ' EVERY edtimer GOSUB 3d_timer
  ' on menu timer gosub 3d_timer
  3d_timer
RETURN
PROCEDURE reset_pointers
  ' Setzt alle Zeiger wieder auf 0 den Kopf
  FOR signal=1 TO maxsignals
    pointer%(signal)=header(signal)
    event_number(signal)=0
  NEXT signal
RETURN
PROCEDURE editor_feld
  fill_window(window,FALSE)
  '  PUT xwork(window),ywork(window),ed_feld$
  SHOWM
RETURN
PROCEDURE ext_maus_init
  ex_mausk=0
  ex_mausx=wwork(0)/2
  ex_mausy=hwork(0)/2
  ARRAYFILL ext_maus_koor(),0
  ~XBIOS(15,7,0,-1,-1,-1,-1)
RETURN
PROCEDURE ext_maus_calc
  LOCAL x,y,z
  ' ex_maush Hîhe
  IF ex_mausk AND 2
    ex_maus_tasten_speed=4*quant/20
  ELSE
    ex_maus_tasten_speed=2*quant/20
  ENDIF
  y=ex_maush
  IF ex_mausk AND 4
    ' runter
    SUB y,ex_maus_tasten_speed
  ENDIF
  IF ex_mausk AND 1
    ' rauf
    ADD y,ex_maus_tasten_speed
  ENDIF
  ' Bezugsbasis: +63 ... -63
  x=(ex_mausx-wwork(0)/2)*maus_zoom*127/wwork(0)/100
  ex_maush=y
  y=ROUND(y*maus_zoom/100)
  z=(ex_mausy-hwork(0)/2)*maus_zoom*127/hwork(0)/100
  dxz=SQR(x*x+z*z)
  '  dxyz=SQR(x*x+y*y+z*z)
  IF sperre! AND dxz>sperre_aussen   !fein2*1.4142
    verh=100*sperre_aussen/dxz
  ELSE
    verh=100
  ENDIF
  IF innenraum!
    ext_maus_koor(0)=x*verh/100
    ext_maus_koor(1)=y
    ext_maus_koor(2)=z*verh/100
  ELSE
    ext_maus_koor(0)=x*125*verh/10000
    ext_maus_koor(1)=y
    ext_maus_koor(2)=z*125*verh/10000
  ENDIF
  FOR koor=0 TO 2
    IF ext_maus_koor(koor)>63
      ext_maus_koor(koor)=63
    ELSE IF ext_maus_koor(koor)<-63
      ext_maus_koor(koor)=-63
    ENDIF
  NEXT koor
RETURN
PROCEDURE ext_maus_check
  ' PC-Maus Treiber
  ' ex_mausk Knîpfe
  ' ex_mausx Original-Koordinate
  ' ex_mausy Original-Koordinate
  LOCAL x,y
  WHILE BIOS(1,1)
    byte=BIOS(2,1)
    IF byte>=&H80 AND byte<=&H87
      PRINT CHR$(7);
      byte=byte AND &X111
      byte=byte XOR &X111
      ex_mausk=byte
      ' PRINT AT(1,2);"Maus: "+BIN$(byte)+STR$(ex_mausk,2)
      '
      byte=BIOS(2,1)
      ADD x,@sbyte(byte)
      ' PRINT AT(10,11);"1. X: "+STR$(@sbyte(byte),3)
      '
      byte=BIOS(2,1)
      ADD y,@sbyte(byte)
      ' PRINT AT(10,12);"1. Y: "+STR$(@sbyte(byte),3)
      '
      byte=BIOS(2,1)
      ADD x,@sbyte(byte)
      ' PRINT AT(10,13);"2. X: "+STR$(@sbyte(byte),3)
      '
      byte=BIOS(2,1)
      ADD y,@sbyte(byte)
      ' PRINT AT(10,14);"2. Y: "+STR$(@sbyte(byte),3)
      '
      ex_mausx=MIN(wwork(0),MAX(0,ex_mausx+x))
      ex_mausy=MIN(hwork(0),MAX(0,ex_mausy-y))
      ' PRINT AT(3,10);"x, y "+STR$(x,5)+STR$(y,5)
      x=0
      y=0
    ELSE
      ' PRINT HEX$(byte&,2),
      ' OUT 1,byte&
    ENDIF
  WEND
RETURN
FUNCTION sbyte(x)
  LOCAL y
  IF x>=128
    y=-256+x
  ELSE
    y=x
  ENDIF
  RETURN y
ENDFUNC
'
PROCEDURE set_koor
  '  koor_input(xyzv,input)
  FOR signal=1 TO maxsignals
    rotieren(signal)
    FOR koor=0 TO 2
      koor_signal(koor,signal)=ko(koor,signal)*koor_signal(koor,signal)
    NEXT koor
    IF tausch!(0,signal)
      SWAP koor_signal(0,signal),koor_signal(1,signal)
    ENDIF
    IF tausch!(1,signal)
      SWAP koor_signal(0,signal),koor_signal(2,signal)
    ENDIF
    IF tausch!(2,signal)
      SWAP koor_signal(1,signal),koor_signal(2,signal)
    ENDIF
    x=koor_signal(0,signal)+koor_add_lfo(0,signal)
    y=koor_signal(1,signal)+koor_add_lfo(1,signal)
    z=koor_signal(2,signal)-koor_add_lfo(2,signal)
    a=0
    b=1
    c=2
    IF tausch!(0,0)
      a=1
      b=0
    ENDIF
    IF tausch!(1,0)
      a=2
      c=0
    ENDIF
    IF tausch!(2,0)
      b=2
      c=1
    ENDIF
    dx=SQR(y*y+z*z)
    dy=SQR(x*x+z*z)
    dz=SQR(x*x+y*y)
    SELECT x
    CASE  TO -1
      wz=180+DEG(ATN(y/x))    ! Winkel in der XY-FlÑche, Dreh. um Z-Achse
    CASE 0
      wz=SGN(y)*90
    CASE 1 TO
      wz=DEG(ATN(y/x))
    ENDSELECT
    '
    SELECT x
    CASE  TO -1
      wy=180+DEG(ATN(z/x))    ! Winkel in der XZ-FlÑche, Dreh. um Y-Achse
    CASE 0
      wy=SGN(z)*90
    CASE 1 TO
      wy=DEG(ATN(z/x))
    ENDSELECT
    '
    SELECT y
    CASE  TO -1
      wx=180+DEG(ATN(z/y))    ! Winkel in der YZ-FlÑche, Dreh. um X-Achse
    CASE 0
      wx=SGN(z)*90
    CASE 1 TO
      wx=DEG(ATN(z/y))
    ENDSELECT
    dxz=SQR(x*x+z*z)
    dxyz=SQR(x*x+y*y+z*z)
    IF dxz=0
      wxz=SGN(y)*90           ! Winkel Y-Achse gegen X-Z-FlÑche
    ELSE
      wxz=DEG(ATN(y/dxz))
    ENDIF
    ADD wxz,dreh_setup(0,signal,spiegelsetup)
    SUB wy,dreh_setup(1,signal,spiegelsetup)
    ' Koordinate=berechneter Wert + Offset aus SPI
    koor_signal(a,signal)=dxyz*COSQ(wy)*COSQ(wxz)+offset_setup(a,signal,spiegelsetup)
    koor_signal(b,signal)=dxyz*SINQ(wxz)+offset_setup(b,signal,spiegelsetup)
    koor_signal(c,signal)=dxyz*SINQ(wy)*COSQ(wxz)-offset_setup(c,signal,spiegelsetup)
    FOR koor=0 TO 2
      IF ext_maus!
        ADD koor_signal(koor,signal),ext_maus_koor(koor)
      ENDIF
      IF koor_signal(koor,signal)>63
        koor_signal(koor,signal)=63
      ELSE IF koor_signal(koor,signal)<-63
        koor_signal(koor,signal)=-63
      ENDIF
    NEXT koor
    '      PRINT AT(1,1);STR$(wxz,4),STR$(dxz,4),STR$(wy,4),STR$(dxyz,4)
  NEXT signal
  panpos
RETURN
PROCEDURE panpos
  IF FALSE !panbreite_lfo=-1
    ' wird in Reset_lfo erldedigt
    ' Normpanbreite=0..100%
    panbreite=100
  ENDIF
  IF FALSE !panpos_lfo=-1
    ' wird in Reset_lfo erldedigt
    ' Normpanpot= -100% .. 100%
    panpos=0
  ENDIF
  FOR signal=1 TO maxsignals STEP 2
    IF play_inp!(signal) OR play_inp!(signal+1)
      FOR koor=0 TO 2
        ' Input/2=Ziel fÅr LFO-Parameter
        ' Abstand * Panbreiten-LFO (%)
        hilf1=(koor_signal(koor,signal)-koor_signal(koor,signal+1))
        ' Berechnung der Panorama-Verkleinerung
        hilf2=hilf1*(100-panbreite(signal/2))/200
        ' Koor=Mitte+Halbe Breite+Verschiebung
        ADD koor_signal(koor,signal),hilf1*panpos(signal/2)/100-hilf2
        ' Zweiter Kanal= 1. Kanal um Panbreite verschoben.
        koor_signal(koor,signal+1)=koor_signal(koor,signal)-hilf1+2*hilf2
      NEXT koor
      IF FALSE! play_inp!(input) AND koor=0
        text$="1:"+STR$(koor_signal(koor,signal),4)+"  2:"+STR$(koor_signal(koor,signal+1),4)
        text$=text$+"|1:"+STR$(koor_signal(1,signal),4)+"  2:"+STR$(koor_signal(1,signal+1),4)
        text$=text$+"|1:"+STR$(koor_signal(2,signal),4)+"  2:"+STR$(koor_signal(2,signal+1),4)+" "
        ALERT 0,text$,1,"OK",x
      ENDIF
    ENDIF
  NEXT signal
RETURN
PROCEDURE merk_koor
  ' merken koordinaten
  BMOVE V:koor_signal(0,0),V:koor_in_alt(0,0),90
RETURN
PROCEDURE rotieren(signal)
  IF mtr_richtung(signal,mtr_setup)=1 OR mtr_richtung(signal,mtr_setup)=3 AND NOT pause!
    mtr_wpos#(signal)=mtr_wpos#(signal)+mtr_winkel#(signal)*mtr_geschw_koeff(signal)/100*mtr_richtung
    SELECT mtr_form(mtr_setup)
    CASE 0
      ' fdia=fein2*SQR(2)
      sin=ROUND(-fdia*SINQ(mtr_wpos#(signal)))
      cos=ROUND(fdia*COSQ(mtr_wpos#(signal)))
    CASE 1
      sin=ROUND(-fein2*wave((720+mtr_wpos#(signal)-90) MOD 360,5)/waveampl)
      cos=ROUND(fein2*wave((720+mtr_wpos#(signal)) MOD 360,5)/waveampl)
    ENDSELECT
    SELECT mtr_dreh(signal,mtr_setup)
    CASE 0
      ' vorn
      x=sin
      y=cos
      z=-fein2
    CASE 1
      ' rechts
      x=fein2
      y=cos
      z=sin
    CASE 2
      ' hinten
      x=-sin
      y=cos
      z=fein2
    CASE 3
      ' links
      x=-fein2
      y=cos
      z=-sin
    CASE 4
      ' oben
      x=sin
      y=fein2
      z=cos
    CASE 5
      ' unten
      x=sin
      y=-fein2
      z=-cos
    CASE 6
      ' rolu
      x=cos
      y=cos
      z=sin
    CASE 7
      ' loru
      x=cos
      y=-cos
      z=sin
    CASE 8
      ' hovu
      x=sin
      y=cos
      z=cos
    CASE 9
      ' vohu
      x=-sin
      y=-cos
      z=cos
    CASE 10
      ' lvrh
      x=-cos
      y=sin
      z=-cos
    CASE 11
      ' lhrv
      x=-cos
      y=sin
      z=cos
    CASE 12
      x=sin
      y=cos
      z=0
    CASE 13
      x=cos
      y=0
      z=sin
    CASE 14
      x=0
      y=cos
      z=sin
    ENDSELECT
    IF signal=0 AND autostop!
      IF ABS(mtr_wpos#(signal)+mtr_winkel#(signal))>360
        stop_3d_timer
        KEYPRESS 48         ! Stop
      ENDIF
    ELSE
      SELECT mtr_modus(signal,mtr_setup)
      CASE mtr_autostop
        IF ABS(mtr_wpos#(signal)+mtr_winkel#(signal))>mtr_wausschnitt%(signal,mtr_setup)
          stop_3d_timer
          KEYPRESS 48         ! Stop
        ENDIF
      CASE mtr_pendel
        IF ABS(mtr_wpos#(signal)+mtr_winkel#(signal)*mtr_geschw_koeff(signal)/100*mtr_richtung-mtr_phase(signal,mtr_setup))>mtr_wausschnitt%(signal,mtr_setup)/2
          '        mtr_wpos#(input)=SGN(mtr_wpos#(input))*mtr_wausschnitt%(input)/2+mtr_phase(input)+mtr_winkel#(input)
          MUL mtr_winkel#(signal),-1
        ENDIF
      CASE mtr_durchlauf
        mtr_wpos#(signal)=mtr_wpos#(signal) MOD (mtr_wausschnitt%(signal,mtr_setup))
      ENDSELECT
    ENDIF
  ENDIF
  IF record!(7,signal)   ! Nur wenn RECORD an
    IF mtr_richtung(signal,mtr_setup)=1 OR mtr_richtung(signal,mtr_setup)=3
      IF record!(0,signal)
        ADD koor_signal(0,signal),x
      ENDIF
      IF record!(1,signal)
        ADD koor_signal(1,signal),y
      ENDIF
      IF record!(2,signal)
        ADD koor_signal(2,signal),z
      ENDIF
    ELSE
      ' Wenn Signal nicht durch MTR gesteuert wird,
      ' Information des "Parallel-Signals" fÅr Spiegelung
      ' zur VerfÅgung stellen.
      ' Evtl. öberschreibung der in Calc-LFO festgelegten XYZ-Positionen
      SELECT signal
      CASE 5 TO 8
        IF mtr_doppeln!
          IF record!(0,signal)
            koor_signal(0,signal)=koor_signal(0,signal-4)
          ENDIF
          IF record!(1,signal)
            koor_signal(1,signal)=koor_signal(1,signal-4)
          ENDIF
          IF record!(2,signal)
            koor_signal(2,signal)=koor_signal(2,signal-4)
          ENDIF
        ENDIF
      ENDSELECT
    ENDIF
  ENDIF
RETURN
'
PROCEDURE fadenkreuz
  '  DEFLINE &X11111111111111110101010101010110
  IF NOT innenraum!
    mi=ADD(m,64)
    pl=ADD(p,64)
  ELSE
    mi=ADD(m/3,64)
    pl=ADD(p/3,64)
  ENDIF
  draw_fdk(koor_signal(0,fdk_signal),koor_signal(1,fdk_signal),koor_signal(2,fdk_signal),koor_signal(4,fdk_signal))
  IF count%>1
    draw_fdk(koor_in_alt(0,fdk_signal),koor_in_alt(1,fdk_signal),koor_in_alt(2,fdk_signal),koor_in_alt(4,fdk_signal))
  ENDIF
RETURN
PROCEDURE draw_fdk(xk,yk,zk,zo)
  MUL xk,zo*4/127
  MUL yk,zo*4/127
  MUL zk,zo*4/127
  linienxyz(xk,yk,zk)
  xk=MAX(0,MIN(127,xk+64))
  yk=MAX(0,MIN(127,yk+64))
  zk=MAX(0,MIN(127,zk+64))
  DEFLINE linieyz%
  LINE @xp(xk(mi,zk)),400-(@zp(yk(yk,zk))),@xp(xk(pl,zk)),400-(@zp(yk(yk,zk)))
  DEFLINE liniexy%
  LINE @xp(xk(xk,mi)),400-(@zp(yk(yk,mi))),@xp(xk(xk,pl)),400-(@zp(yk(yk,pl)))
  DEFLINE liniexz%
  LINE @xp(xk(xk,zk)),400-(@zp(yk(mi,zk))),@xp(xk(xk,zk)),400-(@zp(yk(pl,zk)))
  IF FALSE
    ' Alternative, aber langsamer
    3d_z_line(x,m,z,x,p,z,zo,zo)
    3d_z_line(m,y,z,p,y,z,zo,zo)
    3d_z_line(x,y,m,x,y,p,zo,zo)
  ENDIF
RETURN
PROCEDURE draw8ch
  SELECT grafikmode
  CASE grafik_aus
    ' Nix!
  CASE pan
    ' 1-2 3-4 5-6 7-8
    DEFLINE &HFFFF
    IF count%>1
      FOR i=1 TO 7 STEP 2
        IF play_inp!(i) OR play_inp!(i+1)
          3d_z_line(koor_in_alt(0,i),koor_in_alt(1,i),koor_in_alt(2,i),koor_in_alt(0,i+1),koor_in_alt(1,i+1),koor_in_alt(2,i+1),koor_in_alt(4,i),koor_in_alt(4,i+1))
        ENDIF
      NEXT i
      '  3d_z_line(koor_in_alt(0,i),koor_in_alt(1,i),koor_in_alt(2,i),koor_in_alt(0,1),koor_in_alt(1,1),koor_in_alt(2,1),koor_in_alt(4,i),koor_in_alt(4,1))
    ENDIF
    FOR i=1 TO 7 STEP 2
      IF play_inp!(i) OR play_inp!(i+1)
        3d_z_line(koor_signal(0,i),koor_signal(1,i),koor_signal(2,i),koor_signal(0,i+1),koor_signal(1,i+1),koor_signal(2,i+1),koor_signal(4,i),koor_signal(4,i+1))
      ENDIF
    NEXT i
    '  3d_z_line(koor_input(0,i),koor_input(1,i),koor_input(2,i),koor_input(0,1),koor_input(1,1),koor_input(2,1),koor_input(4,i),koor_input(4,1))
  CASE quadro
    ' 1-2-3-4 5-6-7-8
    DEFLINE &HFFFF
    IF count%>1
      FOR i=1 TO maxsignals-1
        3d_z_line(koor_in_alt(0,i),koor_in_alt(1,i),koor_in_alt(2,i),koor_in_alt(0,i+1),koor_in_alt(1,i+1),koor_in_alt(2,i+1),koor_in_alt(4,i),koor_in_alt(4,i+1))
      NEXT i
    ENDIF
    FOR i=1 TO maxsignals-1
      3d_z_line(koor_signal(0,i),koor_signal(1,i),koor_signal(2,i),koor_signal(0,i+1),koor_signal(1,i+1),koor_signal(2,i+1),koor_signal(4,i),koor_signal(4,i))
    NEXT i
  CASE single
    ' 0-1 0-2 0-3 0-4 ...
    FOR i=1 TO maxsignals
      IF play_inp!(i)
        DEFLINE -(&HFFFF-2^(i-1)+1)
        '          3d_z_line(koor_in_alt(0,i),koor_in_alt(1,i),koor_in_alt(2,i),koor_in_alt(0,i+1),koor_in_alt(1,i+1),koor_in_alt(2,i+1),koor_in_alt(4,i))
        3d_z_line(koor_signal(0,i),koor_signal(1,i),koor_signal(2,i),0,0,0,koor_signal(4,i),0)
      ENDIF
    NEXT i
    IF count%>1
      FOR i=1 TO maxsignals
        IF play_inp!(i)
          DEFLINE -(&HFFFF-2^(i-1)+1)
          '          3d_z_line(koor_in_alt(0,i),koor_in_alt(1,i),koor_in_alt(2,i),koor_in_alt(0,i+1),koor_in_alt(1,i+1),koor_in_alt(2,i+1),koor_in_alt(4,input))
          3d_z_line(koor_in_alt(0,i),koor_in_alt(1,i),koor_in_alt(2,i),0,0,0,koor_in_alt(4,i),0)
        ENDIF
      NEXT i
    ENDIF
  ENDSELECT
RETURN
PROCEDURE 3d_line(x1,y1,z1,x2,y2,z2)
  '  LINE @xp(@xkoor(x1,y1,z1)),400-@zp(@ykoor(1,x1,y1,z1)),@xp(@xkoor(x2,y2,z2)),400-@zp(@ykoor(x2,y2,z2))
  x1=MAX(m,MIN(p,x1))
  y1=MAX(m,MIN(p,y1))
  z1=MAX(m,MIN(p,z1))
  x2=MAX(m,MIN(p,x2))
  y2=MAX(m,MIN(p,y2))
  z2=MAX(m,MIN(p,z2))
  LINE @xp(xk(x1+64,z1+64)),400-@zp(yk(y1+64,z1+64)),@xp(xk(x2+64,z2+64)),400-@zp(yk(y2+64,z2+64))
RETURN
PROCEDURE 3d_z_line(x1,y1,z1,x2,y2,z2,zoom1,zoom2)
  '  LINE @xp(@xkoor(x1,y1,z1)),400-@zp(@koor(1,x1,y1,z1)),@xp(@xkoor(x2,y2,z2)),400-@zp(@ykoor(x2,y2,z2))
  x1=MAX(m,MIN(p,x1*zoom1/32))+64
  y1=MAX(m,MIN(p,y1*zoom1/32))+64
  z1=MAX(m,MIN(p,z1*zoom1/32))+64
  x2=MAX(m,MIN(p,x2*zoom2/32))+64
  y2=MAX(m,MIN(p,y2*zoom2/32))+64
  z2=MAX(m,MIN(p,z2*zoom2/32))+64
  LINE @xp(xk(x1,z1)),400-@zp(yk(y1,z1)),@xp(xk(x2,z2)),400-@zp(yk(y2,z2))
  '  LINE xp(fbreit2+xk(x1,z1)),400-zp(fbreit2+yk(y1,z1)),xp(fbreit2+xk(x2,z2)),400-zp(fbreit2+yk(y2,z2))
RETURN
PROCEDURE 3d_text(x,y,z,text$)
  '  GRAPHMODE 1
  '  COLOR 1
  '  DEFTEXT ,,,13
  x=MAX(m,MIN(p,x))
  y=MAX(m,MIN(p,y))
  z=MAX(m,MIN(p,z))
  '  TEXT xoffset+@xkoor(x,y,z),408-(yoffset+@ykoor(x,y,z))," "
  '  TEXT xoffset+@xkoor(x,y,z),392-(yoffset+@ykoor(x,y,z))," "
  '  TEXT xoffset+@xkoor(x,y,z),400-(yoffset+@ykoor(x,y,z)),text$
  TEXT @xp(xk(x+64,z+64)),400-@zp(yk(y+64,z+64)),text$
RETURN
PROCEDURE default_3dparam
  vx#=0.55
  vy#=0.5
  vz#=0.2
  p#=0.001
  zoom#=3
RETURN
PROCEDURE 3d_param(mode)
  GRAPHMODE 1
  SELECT mode
  CASE 1
    DEFTEXT ,,,13
    gprint(4,12,"Zahlenblock:")
    DEFTEXT ,,,6
    gprint(4,26,"   +----+----+----+")
    gprint(4,27,"   | +p | +y | +z |")
    gprint(4,28,"   +----+----+----+")
    gprint(4,29,"   | -x |  0 | +x |")
    gprint(4,30,"   +----+----+----+------+")
    gprint(4,31,"   | -z | -y | -p |      |")
    gprint(4,32,"   +----+----+----+ Ende |")
    gprint(4,33,"   |         |In/A|      |")
    gprint(4,34,"   +----+----+----+------+")
    DEFTEXT ,,,13
    CONT
  CASE 2
    gprint(2,2,"Verzerrung    x ="+STR$(vx#,5))
    gprint(2,4,"              y ="+STR$(vy#,5))
    gprint(2,6,"              z ="+STR$(vz#,5))
    gprint(2,8,"Zoom            ="+STR$(zoom#,5))
    gprint(2,10,"Perspektive     ="+STR$(p#,8))
  CASE 0
    schl_fenster(3)
  ENDSELECT
RETURN
PROCEDURE wuerfel(rahmen!,kreuz!,art)
  COLOR 1
  SELECT ed_zoom
  CASE  TO 200
    breite=1
  CASE 201 TO
    breite=3
  ENDSELECT
  IF kreuz!
    DEFLINE 1,breite,0,1
    ' 3d_line(0,0,0,0,0,0)
    3d_line(m,0,0,p,0,0)
    3d_line(0,m,0,0,p,0)
    3d_line(0,0,m,0,0,p)
  ENDIF
  IF rahmen!
    SELECT art
    CASE 1
      DEFLINE 1,breite,0,0
    CASE 2
      DEFLINE &X11111111111111110101010101010110,breite,0,0
    ENDSELECT
    3d_line(m,p,m,p,p,m)
    3d_line(p,m,m,p,m,p)
    3d_line(p,p,m,p,p,p)
    3d_line(p,m,m,p,p,m)
    3d_line(p,m,p,p,p,p)
    3d_line(p,p,p,m,p,p)
    3d_line(m,p,m,m,p,p)
    3d_line(m,m,p,p,m,p)
    3d_line(m,m,p,m,p,p)
    SELECT art
    CASE 1
      DEFLINE &X11111111111111110101010101010110,1,0,0
    CASE 2
      DEFLINE &HFFFF7778,breite,0,0
    ENDSELECT
    3d_line(m,m,m,m,m,p)
    3d_line(m,m,m,p,m,m)
    3d_line(m,m,m,m,p,m)
  ENDIF
RETURN
PROCEDURE innenflaechen
  3d_line(-fein2,m,-fein2,fein2,m,-fein2)
  3d_line(-fein2,m,-fein2,-fein2,m,fein2)
  3d_line(-fein2,m,fein2,fein2,m,fein2)
  3d_line(fein2,m,-fein2,fein2,m,fein2)
  '
  3d_line(m,-fein2,-fein2,m,-fein2,fein2)
  3d_line(m,-fein2,fein2,m,fein2,fein2)
  3d_line(m,fein2,fein2,m,fein2,-fein2)
  3d_line(m,fein2,-fein2,m,-fein2,-fein2)
  '
  3d_line(-fein2,-fein2,m,fein2,-fein2,m)
  3d_line(fein2,-fein2,m,fein2,fein2,m)
  3d_line(fein2,fein2,m,-fein2,fein2,m)
  3d_line(-fein2,fein2,m,-fein2,-fein2,m)
  '
  3d_line(-fein2,p,-fein2,fein2,p,-fein2)
  3d_line(-fein2,p,-fein2,-fein2,p,fein2)
  3d_line(-fein2,p,fein2,fein2,p,fein2)
  3d_line(fein2,p,-fein2,fein2,p,fein2)
  '
  3d_line(p,-fein2,-fein2,p,-fein2,fein2)
  3d_line(p,-fein2,fein2,p,fein2,fein2)
  3d_line(p,fein2,fein2,p,fein2,-fein2)
  3d_line(p,fein2,-fein2,p,-fein2,-fein2)
  '
  3d_line(-fein2,-fein2,p,fein2,-fein2,p)
  3d_line(fein2,-fein2,p,fein2,fein2,p)
  3d_line(fein2,fein2,p,-fein2,fein2,p)
  3d_line(-fein2,fein2,p,-fein2,-fein2,p)
RETURN
PROCEDURE drehwuerfel(rahmen!,kreuz!,art,winkel)
  zoom=32
  DEFLINE 1,2
  COLOR 1
  GRAPHMODE 3
  fxoffset=30
  fzoffset=310
  fyoffset=0
  ed_zoom=60
  xzpos
  count%=1
  multimode=wuerfel
  p=50
  koor_signal(0,0)=p*COSQ(winkel)
  koor_signal(1,0)=40
  koor_signal(2,0)=p*SINQ(winkel)
  koor_signal(4,0)=32
  set_koor
  FOR i=1 TO 3
    line_inputs(i,i+1)
    line_inputs(i+4,i+5)
    line_inputs(i,i+4)
  NEXT i
  line_inputs(1,4)
  line_inputs(5,8)
  line_inputs(4,8)
  merk_koor
RETURN
PROCEDURE line_inputs(i1,i2)
  '  GRAPHMODE 3
  3d_z_line(koor_in_alt(0,i1),koor_in_alt(1,i1),koor_in_alt(2,i1),koor_in_alt(0,i2),koor_in_alt(1,i2),koor_in_alt(2,i2),koor_in_alt(4,i1),koor_in_alt(4,i2))
  3d_z_line(koor_signal(0,i1),koor_signal(1,i1),koor_signal(2,i1),koor_signal(0,i2),koor_signal(1,i2),koor_signal(2,i2),koor_signal(4,i1),koor_signal(4,i1))
RETURN
PROCEDURE linienxyz(x,y,z)
  x!=ABS(x)>32
  y!=ABS(y)>32
  z!=ABS(z)>32
  IF x! OR y!
    liniexy%=linie2%
  ELSE
    liniexy%=linie1%
  ENDIF
  IF x! OR z!
    liniexz%=linie2%
  ELSE
    liniexz%=linie1%
  ENDIF
  IF y! OR z!
    linieyz%=linie2%
  ELSE
    linieyz%=linie1%
  ENDIF
RETURN
'
PROCEDURE disp_mausmodus
  IF window=5 OR window=6
    TEXT ed_set_x0+56,ed_set_y0+40,mausmodus$(mausmodus)
  ENDIF
RETURN
PROCEDURE disp_quant
  IF window=5 OR window=6
    TEXT ed_set_x0+56,ed_set_y0+88,STR$(quant,5)
  ENDIF
RETURN
PROCEDURE sperre(schalt!,disp!)
  IF schalt!
    PRINT CHR$(7);
    sperre!=NOT sperre!
  ENDIF
  IF disp! AND (window=5 OR window=6) AND on_screen!(window)
    GRAPHMODE 1
    IF sperre!
      DEFTEXT ,0
      TEXT ed_set_x0,ed_set_y0+8,"SP: "+STR$(sperre_aussen,2)
    ELSE
      DEFTEXT ,2
      TEXT ed_set_x0,ed_set_y0+8,"SPERRE"
    ENDIF
    GRAPHMODE 3
    DEFTEXT ,0
  ENDIF
RETURN
PROCEDURE cycle(schalt!,disp!)
  IF schalt!
    PRINT CHR$(7);
    cycle!=NOT cycle!
  ENDIF
  IF disp!
    GRAPHMODE 1
    IF cycle!
      DEFTEXT ,0
    ELSE
      DEFTEXT ,2
    ENDIF
    TEXT ed_set_x0,ed_set_y0+24,"CYCLE"
    GRAPHMODE 1
    DEFTEXT ,0
  ENDIF
RETURN
PROCEDURE zeitl(schalt!,disp!)
  IF schalt!
    PRINT CHR$(7);
    zeitl!=NOT zeitl!
  ENDIF
  IF disp!
    GRAPHMODE 1
    IF zeitl!
      DEFTEXT ,0
    ELSE
      DEFTEXT ,2
    ENDIF
    TEXT ed_set_x0+72,ed_set_y0+8,"ZEITLUPE"
    GRAPHMODE 1
    DEFTEXT ,0
  ENDIF
RETURN
PROCEDURE pause(schalt!,disp!)
  IF schalt!
    PRINT CHR$(7);
    pause!=NOT pause!
  ENDIF
  IF disp!
    GRAPHMODE 1
    IF pause!
      DEFTEXT ,0
    ELSE
      DEFTEXT ,2
    ENDIF
    TEXT ed_set_x0+72,ed_set_y0+24,"PAUSE"
    GRAPHMODE 1
    DEFTEXT ,0
  ENDIF
RETURN
PROCEDURE play_inp_status(signal)
  GRAPHMODE 1
  IF signal>0 AND signal=<maxsignals
    IF window=5 OR window=6 AND on_screen!(window)
      IF play_inp!(signal)
        TEXT ed_set_x0+(signal-1)*8,ed_set_y0+156,""
      ELSE
        TEXT ed_set_x0+(signal-1)*8,ed_set_y0+156,"-"
      ENDIF
      IF record!(7,signal)
        TEXT ed_set_x0+(signal-1)*8,ed_set_y0+172,"*"
      ELSE
        TEXT ed_set_x0+(signal-1)*8,ed_set_y0+172,"-"
      ENDIF
    ENDIF
    GRAPHMODE 1
    '    kneu!(3,input)=TRUE               ! Neue Volumes auch nach an/aus
    '    kneu!(4,input)=TRUE               ! Neue Zooms auch nach an/aus
  ENDIF
RETURN
PROCEDURE richtung(mtr!,lfo!,disp!)
  IF mtr!
    MUL mtr_richtung,-1
  ENDIF
  IF lfo!
    MUL lfo_richtung,-1
  ENDIF
  IF disp!
    DEFTEXT ,0
    TEXT ed_set_x0,ed_set_y0+104,"U:"
    IF mtr_richtung=-1
      DEFTEXT ,0
    ELSE
      DEFTEXT ,2
    ENDIF
    TEXT ed_set_x0+16,ed_set_y0+104,"MTR"
    IF lfo_richtung=-1
      DEFTEXT ,0
    ELSE
      DEFTEXT ,2
    ENDIF
    TEXT ed_set_x0+48,ed_set_y0+104,"LFO"
    GRAPHMODE 1
    DEFTEXT ,0
  ENDIF
RETURN
'
PROCEDURE periode
  LOCAL pointer%,lastnode%
  FOR signal=1 TO maxsignals
    lastnode%=@get_last_node(signal)
    DEFMOUSE 2
    pointer%=lastnode%
    FOR count%=1 TO laenge%
      insert_node(lastnode%)
      FOR koor=0 TO 4
        koor(koor,foll%(lastnode%))=koor(koor,pointer%)
      NEXT koor
      pointer%=prev%(pointer%)
    NEXT count%
  NEXT signal
  rufton2
  DEFMOUSE 0
RETURN
PROCEDURE wiederholungen
  IF FALSE
    ~@get_last_node
    IF laenge%>0
      minval=1
      maxval=@maxwiederh
      value=@maxwiederh/2
      dpname$="Wiederholungen"
      dparam
      anz_wiederh=MIN(value,@maxwiederh)
      IF ok!
        DEFMOUSE 2
        DEFFN maxwiederh=(max3devents%/laenge%)-1
        FOR wiederh=1 TO anz_wiederh
          BMOVE V:koor(0,1),V:koor(0,(laenge%*wiederh+1)),V:koor(0,laenge%+1)-V:koor(0,1)
        NEXT wiederh
        koor(0,laenge%*(1+anz_wiederh))=fbreite+1
        rufton
        DEFMOUSE 0
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE in_puffer
  IF FALSE
    ~@get_last_node
    IF laenge%>0 AND laenge%<=maxpufferlaenge
      DEFMOUSE 2
      BMOVE V:koor(0,1),V:koor_p(0,0),V:koor(0,laenge%+1)-V:koor(0,1)
      DEFMOUSE 0
      puffer_laenge=laenge%-1
      PRINT CHR$(7);
    ELSE IF laenge%>maxpufferlaenge
      ALERT 1,"Puffer nicht groû genug",1,"Abbruch",wahl
    ENDIF
  ENDIF
RETURN
'
PROCEDURE midi_out
  ' MIDI Zuordnung:
  ' key 0 (C -2)= X-Koor Input 1
  ' key 1 (C#-2)= Y-Koor Input 1
  ' key 2 (D -2)= Z-Koor Input 1
  ' key 3 (D#-2)= Volume Input 1
  ' key 4 (E -2)= X-Koor Input 2
  ' key 5 (F#-2)= usw.
  LOCAL midi_channel    ! Der Midi Kanal fÅr die Ausgabe
  LOCAL output          ! Die Kanalnummer des Signals
  LOCAL midi_key        ! Die Midi-Key Nummer fÅr Signals+Koordinate
  midibytes%=0          ! ZÑhler fÅr Bytes in midi_out|()
  '  set_koor
  IF count%>0
    FOR signal=1 TO maxsignals
      IF midich(signal)>0 AND midich(signal)<=64
        '
        ' Mididaten fÅr Output berechnen
        IF midich(signal)<=32
          ' KanÑle 1..32 auf Standard-Kanal
          midi_channel=midi_out_channel-1
          output=midich(signal)
        ELSE
          ' KanÑle 33 - 64 auf einem Kanal niedriger
          midi_channel=midi_out_channel-2
          ' output umrechnen auf 1 .. 32 Basis
          output=midich(signal)-32
        ENDIF
        midi_out|(midibytes%)=9*16+midi_channel       ! Note_On
        INC midibytes%
        '
        FOR koor=0 TO 3
          ' Wenn input angeschaltet oder frisch gemutet:
          ' Wenn Zoom neu, alles neu
          kneu!(koor,signal)=kneu!(koor,signal) OR koor_signal(4,signal)<>koor_in_alt(4,signal)
          IF play_inp!(signal) OR (koor=3 AND mute!)
            ' Wenn sich Koor verÑndert hat oder neu vorgegeben wird, oder Input mit Volume Update an der Reihe, oder Zoom neu
            IF (koor_signal(koor,signal)<>koor_in_alt(koor,signal)) OR kneu!(koor,signal) OR (koor=3 AND count% MOD maxsignals=signal-1)
              ' Jedes Mal ein Input mit Vol, Rest ohne
              SELECT koor
              CASE 0 TO 2
                midi_key=4*(output-1)+koor
                midi_out|(midibytes%)=midi_key
                INC midibytes%
                wert=1+fbreit2+(koor_signal(koor,signal)*koor_signal(4,signal)*4)/128 ! Zoom incl.
                IF wert<0
                  midi_out|(midibytes%)=0
                ELSE IF wert>127
                  midi_out|(midibytes%)=127
                ELSE
                  midi_out|(midibytes%)=wert
                ENDIF
                INC midibytes%
                IF sendnoteoff!
                  midi_out|(midibytes%)=midi_key
                  INC midibytes%
                  midi_out|(midibytes%)=0
                  INC midibytes%
                ENDIF
                kneu!(koor,signal)=FALSE
              CASE 3
                ' Volume
                IF volume_ausgabe!
                  midi_key=4*(output-1)+3
                  midi_out|(midibytes%)=midi_key
                  INC midibytes%
                  IF mute! AND NOT play_inp!(signal)
                    ' Wenn Input gemutet wurde, direkt ausschalten, unabhÑngig von Vol-LFO
                    midi_out|(midibytes%)=0
                  ELSE
                    midi_out|(midibytes%)=koor_signal(3,signal)
                  ENDIF
                  kneu!(koor,signal)=FALSE
                  INC midibytes%
                  IF sendnoteoff!
                    midi_out|(midibytes%)=midi_key
                    INC midibytes%
                    midi_out|(midibytes%)=0
                    INC midibytes%
                  ENDIF
                ENDIF
              ENDSELECT ! koor
            ENDIF ! kneu ?
          ENDIF ! play?
        NEXT koor
      ENDIF ! midich?
    NEXT signal
    '    ENDIF
    IF midibytes%>1             ! Mehr als nur Note-On/Off Status
      ~XBIOS(12,midibytes%-1,L:V:midi_out|(0))
    ENDIF
  ENDIF
  mute!=FALSE
  midiout_time%=TIMER-midiout_time%
RETURN
PROCEDURE midi_in
  ' wird in on_menu-Schleife aufgerufen
  ' Midi-Routine aus Cybermove
  midi_in_controller=&HB0+midi_in_channel-1
  midi_in_pitchbend=&HE0+midi_in_channel-1
  WHILE BIOS(1,3) OR midineu>-1  ! Schleife auch wenn Rest da.
    IF midineu=-1                        ! Rest aus XYZ-Routine vorhanden?
      midiin=BIOS(2,3) AND 255          ! Nein? Dann neuen Wert holen
    ELSE
      midiin=midineu                    ! Ja, dann verwenden!
      midineu=-1
    ENDIF
    IF midiin>127
      '      PRINT CHR$(7);
      '      PRINT AT(1,1);STR$(midiin,3)
      SELECT midiin
      CASE 159  !noteon_16
        '       ***   X,Y,Z Steuerung  ***
        sx=1
      CASE midi_in_controller
        ' ***   Controller auf Ch. 16    ***
        sx=2
      CASE midi_in_pitchbend
        ' ***   Pitchbend auf Ch. 16    ***
        sx=3
      CASE &HFB
        ' ***    Midi Stop  ***
        KEYPRESS 48       ! Stop
        '        exit!=TRUE
      CASE 248
        ' ***   Midi-Clock   *
      DEFAULT
        sx=0
      ENDSELECT
    ELSE
      SELECT sx
      CASE 1
        ti%=TIMER
        REPEAT
          IF midiin=-1
            midineu=BIOS(2,3) AND 255
            midiin=midineu
          ENDIF
          EXIT IF midineu>127                   ! Raus bei neuem Status
          signal=DIV(midiin,4)                  ! Input  1..16
          koor=midiin MOD 4                     ! X,Y,Z,Vol
          midineu=BIOS(2,3) AND 255
          EXIT IF midineu>127                   ! Raus bei neuem Status
          midiin=midineu                        ! Sonst verwenden
          '          PRINT CHR$(7);
          IF inmausext! AND signal=0
            ext_koor(koor)=midiin-1-fbreit2     ! Koordinaten merken
          ENDIF
          midineu=-1
          midiin=-1
        UNTIL NOT BIOS(1,3)                     ! Steuern, wenn keine Daten mehr da
      CASE 2
        controller=midiin                       ! Controller-Nummer merken
        midineu=BIOS(2,3) AND 255
        EXIT IF midineu>127                     ! Raus bei neuem Status
        midiin=midineu                          ! Sonst verwenden
        cont_val=midiin                         ! Controller Wert merken
        midineu=-1
        midiin=-1
        FOR lfo_group=0 TO max_lfo_groups
          FOR lfo=0 TO maxlfos
            IF lfo_param(1,lfo,lfo_setup(lfo_group))=3          ! Controller als Quelle?
              IF lfo_param(8,lfo,lfo_setup(lfo_group))=controller       ! Wenn einem LFO der Cont zugewiesen ist,
                lfo_midiin_val(lfo,lfo_group)=cont_val             ! Cont-Wert an LFO
              ENDIF
            ENDIF
          NEXT lfo
        NEXT lfo_group
        '        PRINT CHR$(7);
        '        PRINT AT(1,1);STR$(midiin&,3)
      CASE 3
        value1=midiin                           ! Controller-Nummer merken
        midineu=BIOS(2,3) AND 255
        EXIT IF midineu>127                     ! Raus bei neuem Status
        midiin=midineu                          ! Sonst verwenden
        value2=midiin                           ! Controller Wert merken
        midineu=-1
        midiin=-1
        FOR lfo_group=0 TO max_lfo_groups
          FOR lfo=0 TO maxlfos
            IF lfo_param(1,lfo,lfo_setup(lfo_group))=10        ! Wenn einem LFO der PB zugewiesen ist,
              lfo_midiin_val(lfo,lfo_group)=value2           ! Pitchbend-Wert an LFO
            ENDIF
          NEXT lfo
        NEXT lfo_group
      ENDSELECT
    ENDIF
  WEND
RETURN
PROCEDURE send_start
  IF sendstart!
    IF count%=0
      OUT 3,midi_start
    ELSE
      OUT 3,midi_cont
    ENDIF
  ENDIF
  IF sendclock!
    '    OUT 3,&HF0,&H7F,&H7F,&H1,&H1,&X100000,0,0,0,&HF7
  ENDIF
RETURN
PROCEDURE send_timec
  IF full!
    OUT 3,&HF0,&H7F,&H7F,1,1,&X100000 OR hh,mm,ss,ff,&HF7
  ELSE
    SELECT qframes% MOD 8
    CASE 0
      mtc_out|(1)=ff MOD 16
    CASE 1
      mtc_out|(1)=&H10+DIV(ff,16)
    CASE 2
      mtc_out|(1)=&H20+ss MOD 16
    CASE 3
      mtc_out|(1)=&H30+DIV(ss,16)
    CASE 4
      mtc_out|(1)=&H40+mm MOD 16
    CASE 5
      mtc_out|(1)=&H50+DIV(mm,16)
    CASE 6
      mtc_out|(1)=&H60+hh MOD 16
    CASE 7
      mtc_out|(1)=&H72+DIV(hh,16)
    ENDSELECT
    ~XBIOS(12,1,L:V:mtc_out|(0))
  ENDIF
RETURN
'
PROCEDURE delete_events(count%,anz_events%)
  LOCAL counter%
  reset_pointers
  ' Vorlauf
  FOR counter%=1 TO count%
    FOR signal=1 TO maxsignals
      IF play_inp!(signal)
        pointer%(signal)=foll%(pointer%(signal))
        INC event_number(signal)
      ENDIF
    NEXT signal
  NEXT counter%
  ' Lîschen
  FOR counter%=1 TO anz_events%
    exit!=TRUE
    FOR signal=1 TO maxsignals
      IF record!(7,signal)        ! aber nur wenn Kanal-Rec an
        ' Node an Empty-List zurÅckgeben
        IF foll%(pointer%(signal))<>header(signal)
          delete_node(foll%(pointer%(signal)))
          exit!=FALSE
        ENDIF
      ENDIF
    NEXT signal
    ' Wenn alle fertig sind
    EXIT IF exit!
  NEXT counter%
  rufton2
RETURN
PROCEDURE mausmodus(mode)
  mausmodus=mode
  disp_mausmodus
RETURN
'
' * * *  Editor-Dialoge   * * *
'
PROCEDURE input_parameter
  stop_3d_timer
  rscaddress(dinppara,0)
  fill_ip_dialog
  dialogbox(ipspinr,4)
  SELECT exitbutton%
  CASE ipende
    spiegelsetup=@setup_num(maxspisetups,VAL(@editedtxt$(ipspinr)))
    do_spiegel_setup(spiegelsetup)
    FOR signal=1 TO maxsignals
      play_inp!(signal)=@selected(ipausgabe(signal))
    NEXT signal
    mtr_doppeln!=@selected(ipmtrdop)
  ENDSELECT
  updatemenu
  fill_window(5,FALSE)
  fill_window(6,FALSE)
RETURN
PROCEDURE te_ip_dialog
  LOCAL input_orig
  IF exitbutton%=ipspidec
    DEC spiegelsetup
    IF spiegelsetup<0
      spiegelsetup=maxspisetups
    ENDIF
    fill_ip_dialog
  ELSE IF exitbutton%=ipspiinc
    INC spiegelsetup
    IF spiegelsetup>maxspisetups
      spiegelsetup=0
    ENDIF
    fill_ip_dialog
  ELSE IF exitbutton%=ipspinr
    spiegelsetup=@setup_num(maxspisetups,VAL(@editedtxt$(ipspinr)))
    fill_ip_dialog
  ELSE IF exitbutton%=ipstore
    rufton2
    edit_spisetup=@setup_num(maxspisetups,@dzahl(edit_spisetup))
    copy_spi_setup(spiegelsetup,edit_spisetup)
    spiegelsetup=edit_spisetup
    set_text(ipspinr,STR$(spiegelsetup))
    spi_aenderung!=TRUE
  ELSE IF exitbutton%=iprecall
    IF spiegelsetup=0
      ' Darf aus SicherheitsgrÅnden nicht zum VerÑndern der Setups
      ' verwendet werden!
      PRINT CHR$(7);
      copy_spi_setup(@dzahl(@setup_num(maxspisetups,edit_spisetup)),spiegelsetup)
      fill_ip_dialog
    ENDIF
  ELSE
    temp_spi_setup
    set_text(ipspinr,STR$(spiegelsetup))
    FOR signal=1 TO maxsignals
      IF exitbutton%=ipincs(signal)
        spiegel_setup(signal,spiegelsetup)=@get_makronr(signal)+1
        IF spiegel_setup(signal,spiegelsetup)>2^6
          spiegel_setup(signal,spiegelsetup)=0
        ENDIF
        set_makronr(signal,spiegel_setup(signal,spiegelsetup))
        fill_ip_input(signal)
      ELSE IF exitbutton%=ipdecs(signal)
        spiegel_setup(signal,spiegelsetup)=@get_makronr(signal)-1
        IF spiegel_setup(signal,spiegelsetup)<0
          spiegel_setup(signal,spiegelsetup)=2^6-1
        ENDIF
        set_makronr(signal,spiegel_setup(signal,spiegelsetup))
        fill_ip_input(signal)
      ELSE IF exitbutton%=ipsetup(signal)
        spiegel_setup(signal,spiegelsetup)=MIN(2^6-1,MAX(0,@dzahl(VAL(@editedtxt$(ipsetup(signal))))))
        set_makronr(signal,spiegel_setup(signal,spiegelsetup))
        fill_ip_input(signal)
      ELSE IF exitbutton%>=ipspiegx(signal) AND exitbutton%<=iptauschyz(signal)
        get_ip_input(signal)
        spiegel_setup(signal,spiegel_setup)=@get_makronr(signal)
        set_text(ipsetup(signal),STR$(spiegel_setup(signal,spiegel_setup)))
      ELSE
        FOR koor=0 TO 2
          IF exitbutton%=ipdreh(koor,signal)
            dreh_setup(koor,signal,spiegelsetup)=MIN(270,MAX(-270,@dzahl(VAL(@editedtxt$(ipdreh(koor,signal))))))
            set_text(ipdreh(koor,signal),STR$(dreh_setup(koor,signal,spiegelsetup)))
          ELSE IF exitbutton%=ipoffs(koor,signal)
            offset_setup(koor,signal,spiegelsetup)=MIN(fbreite,MAX(-fbreite,@dzahl(VAL(@editedtxt$(ipoffs(koor,signal))))))
            set_text(ipoffs(koor,signal),STR$(offset_setup(koor,signal,spiegelsetup)))
          ENDIF
        NEXT koor
      ENDIF
    NEXT signal
    IF exitbutton%=ipmausmo
      spiegel_setup(0,spiegelsetup)=@dmausmodus
      set_text(ipmausmo,mausmodus$(spiegel_setup(0,spiegelsetup)))
    ENDIF
  ENDIF
  '  firstedit%=ipspinr
RETURN
PROCEDURE fill_ip_dialog
  LOCAL flag!
  rscaddress(dinppara,0)
  set_text(ipspinr,STR$(spiegelsetup))
  set_text(ipmausmo,mausmodus$(spiegel_setup(0,spiegelsetup)))
  FOR signal=1 TO maxsignals
    set_makronr(signal,spiegel_setup(signal,spiegelsetup))
    fill_ip_input(signal)
  NEXT signal
RETURN
PROCEDURE fill_ip_input(signal)
  FOR koor=0 TO 2
    set_text(ipdreh(koor,signal),STR$(dreh_setup(koor,signal,spiegelsetup)))
    set_text(ipoffs(koor,signal),STR$(offset_setup(koor,signal,spiegelsetup)))
  NEXT koor
  set_text(ipsetup(signal),STR$(@get_makronr(signal)))
  select(iptauschxy(signal),tausch!(0,signal))
  select(iptauschxz(signal),tausch!(1,signal))
  select(iptauschyz(signal),tausch!(2,signal))
  select(ipspiegx(signal),ko(0,signal)=TRUE)
  select(ipspiegy(signal),ko(1,signal)=TRUE)
  select(ipspiegz(signal),ko(2,signal)=TRUE)
  select(ipausgabe(signal),play_inp!(signal))
RETURN
PROCEDURE get_ip_input(signal)
  ' Hier nur alles, was nicht Åber Touchexit+dzahl verÑndert wird
  IF @selected(ipspiegx(signal))
    ko(0,signal)=-1
  ELSE
    ko(0,signal)=1
  ENDIF
  IF @selected(ipspiegy(signal))
    ko(1,signal)=-1
  ELSE
    ko(1,signal)=1
  ENDIF
  IF @selected(ipspiegz(signal))
    ko(2,signal)=-1
  ELSE
    ko(2,signal)=1
  ENDIF
  tausch!(0,signal)=@selected(iptauschxy(signal))
  tausch!(1,signal)=@selected(iptauschxz(signal))
  tausch!(2,signal)=@selected(iptauschyz(signal))
RETURN
FUNCTION get_makronr(signal)
  makronr=0
  FOR koor=0 TO 2
    IF ko(koor,signal)=-1
      makronr=BSET(makronr,koor)
    ELSE
      makronr=BCLR(makronr,koor)
    ENDIF
    IF tausch!(koor,signal)
      makronr=BSET(makronr,koor+3)
    ELSE
      makronr=BCLR(makronr,koor+3)
    ENDIF
  NEXT koor
  RETURN makronr
ENDFUNC
PROCEDURE set_makronr(signal,nr)
  makronr=nr
  FOR koor=0 TO 2
    IF BTST(makronr,koor)
      ko(koor,signal)=-1
    ELSE
      ko(koor,signal)=1
    ENDIF
    IF BTST(makronr,koor+3)
      tausch!(koor,signal)=TRUE
    ELSE
      tausch!(koor,signal)=FALSE
    ENDIF
  NEXT koor
RETURN
PROCEDURE do_spiegel_setup(spiegelsetup)
  mausmodus=spiegel_setup(0,spiegelsetup)
  FOR signal=1 TO maxsignals
    set_makronr(signal,spiegel_setup(signal,spiegelsetup))
  NEXT signal
  disp_mausmodus
RETURN
PROCEDURE temp_spi_setup
  IF spiegelsetup>0
    ' Setup muû erst in 0-Setup kopiert werden, bevor es bearbeitet werden darf!
    copy_spi_setup(spiegelsetup,0)
    edit_spisetup=spiegelsetup
    spiegelsetup=0
  ENDIF
RETURN
PROCEDURE copy_spi_setup(source,dest)
  ' Mausmodus
  spiegel_setup(0,dest)=spiegel_setup(0,source)
  IF dest=0
    mausmodus=spiegel_setup(0,source)
  ENDIF
  FOR signal=1 TO maxsignals
    spiegel_setup(signal,dest)=spiegel_setup(signal,source)
    FOR koor=0 TO 2
      dreh_setup(koor,signal,dest)=dreh_setup(koor,signal,source)
      offset_setup(koor,signal,dest)=offset_setup(koor,signal,source)
    NEXT koor
  NEXT signal
RETURN
FUNCTION dmausmodus
  te!=FALSE
  tree_alt=tree
  rscaddress(dmausmod,0)
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  preselect=1+spiegel_setup(0,spiegelsetup)
  popupbox(preselect,1)
  te!=TRUE
  rscaddress(tree_alt,0)
  ' obj_draw(0,max_depth)
  IF exitbutton%>0
    RETURN exitbutton%-1
  ELSE
    STOP
    RETURN spiegel_setup(0,spiegelsetup)
  ENDIF
ENDFUNC
'
PROCEDURE inputchange_dialog
  stop_3d_timer
  REM inpchtit=1 !Obj in #18
  REM dcok=2 !Obj in #18
  REM inpchanr=4 !Obj in #18
  REM inpchdec=5 !Obj in #18
  REM inpchinc=6 !Obj in #18
  rscaddress(dcminput,0)
  fill_inputchange_dialog
  dialogbox(0,3)
  SELECT exitbutton%
  CASE dcok
    inputsetup=@setup_num(maxinpsetups,VAL(@editedtxt$(inpchanr)))
    do_inputset(inputsetup)
    find_top_window
    IF window=5 OR window=6
      editor_parameter_feld
      disp_mausmodus
    ENDIF
  DEFAULT
  ENDSELECT
RETURN
PROCEDURE fill_inputchange_dialog
  rscaddress(dcminput,0)
  set_text(inpchanr,STR$(inputsetup))
  FOR signal=1 TO maxsignals
    set_text(dcinp(signal),RIGHT$("0"+STR$(input_setup|(signal,inputsetup)),2))
    '    select(dcan(input),play_inp!(input))
  NEXT signal
RETURN
PROCEDURE get_inputchange_dialog
  inputsetneu=@setup_num(maxinpsetups,VAL(@editedtxt$(inpchanr)))
  FOR signal=1 TO maxsignals
    input_setup|(signal,inputsetneu)=input_setup|(signal,inputsetup)
  NEXT signal
  inputsetup=inputsetneu
RETURN
PROCEDURE te_inputchange_dialog
  '  PRINT CHR$(7);
  SELECT exitbutton%
  CASE inpchanr
    inputsetup=@setup_num(maxinpsetups,VAL(@editedtxt$(inpchanr)))
    rscaddress(dinpchan,0)
    fill_inputchange_dialog
  CASE inpchdec
    DEC inputsetup
    IF inputsetup<0
      inputsetup=maxinpsetups
    ENDIF
    fill_inputchange_dialog
  CASE inpchinc
    INC inputsetup
    IF inputsetup>maxinpsetups
      inputsetup=0
    ENDIF
    fill_inputchange_dialog
  CASE dcstore
    rufton2
    edit_inpsetup=@setup_num(maxinpsetups,@dzahl(edit_inpsetup))
    copy_inp_setup(inputsetup,edit_inpsetup)
    inputsetup=edit_inpsetup
    set_text(inpchanr,STR$(inputsetup))
    inp_aenderung!=TRUE
  CASE dcrecall
    IF inputsetup=0
      ' Darf aus SicherheitsgrÅnden nicht zum VerÑndern der Setups
      ' verwendet werden!
      PRINT CHR$(7);
      copy_inp_setup(@dzahl(@setup_num(maxinpsetups,edit_inpsetup)),inputsetup)
      fill_inputchange_dialog
    ENDIF
  CASE dcinp1 TO dcinp8
    temp_inp_setup
    set_text(inpchanr,STR$(inputsetup))
    FOR signal=1 TO maxsignals
      EXIT IF exitbutton%=dcinp(signal)
    NEXT signal
    input_setup|(signal,inputsetup)=@ipmidich(input_setup|(signal,inputsetup))
    set_text(dcinp(signal),RIGHT$("0"+STR$(input_setup|(signal,inputsetup)),2))
  ENDSELECT
  rscaddress(dcminput,0)
RETURN
FUNCTION ipmidich(signal)
  ' local channel
  te!=FALSE
  tree_alt=tree
  rscaddress(dinput,0)
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  preselect=dcminput(signal)
  popupbox(preselect,1)
  FOR signal=1 TO 64
    EXIT IF exitbutton%=dcminput(signal)
  NEXT signal
  rscaddress(tree_alt,0)
  ' obj_draw(0,max_depth)
  te!=TRUE
  RETURN signal MOD 65
ENDFUNC
PROCEDURE temp_inp_setup
  IF inputsetup>0
    ' Setup muû erst in 0-Setup kopiert werden, bevor es bearbeitet werden darf!
    copy_inp_setup(inputsetup,0)
    edit_inpsetup=inputsetup
    inputsetup=0
  ENDIF
RETURN
PROCEDURE copy_inp_setup(source,dest)
  FOR signal=1 TO maxsignals
    input_setup|(signal,dest)=input_setup|(signal,source)
  NEXT signal
RETURN
PROCEDURE do_inputset(inputsetup)
  FOR signal=1 TO maxsignals
    midich(signal)=MAX(1,MIN(64,input_setup|(signal,inputsetup)))
  NEXT signal
RETURN
'
PROCEDURE signaltausch_dialog
  stop_3d_timer
  REM sigchtit=1 !Obj in #18
  REM dcok=2 !Obj in #18
  REM signummer=4 !Obj in #18
  REM sigchdec=5 !Obj in #18
  REM sigchinc=6 !Obj in #18
  rscaddress(dsigtau,0)
  fill_signaltausch_dialog
  dialogbox(0,3)
  SELECT exitbutton%
  CASE diok
    get_signaltausch_dialog
    '    do_inputset(inputsetup)
    sig_aenderung!=TRUE
  DEFAULT
  ENDSELECT
RETURN
PROCEDURE fill_signaltausch_dialog
  rscaddress(dsigtau,0)
  set_text(signumm,STR$(signalsetup))
  FOR signal=1 TO maxsignals
    set_text(dsignal(signal),RIGHT$("0"+STR$(signal_setup|(signal,signalsetup)),2))
  NEXT signal
RETURN
PROCEDURE get_signaltausch_dialog
  signalsetneu=@setup_num(maxinpsetups,VAL(@editedtxt$(signumm)))
  FOR signal=1 TO maxsignals
    signal_setup|(signal,signalsetneu)=signal_setup|(signal,signalsetup)
  NEXT signal
  signalsetup=signalsetneu
RETURN
PROCEDURE te_signaltausch_dialog
  SELECT exitbutton%
  CASE signumm
    signalsetup=@setup_num(maxsigsetups,VAL(@editedtxt$(inpchanr)))
    rscaddress(dsigtau,0)
    fill_signaltausch_dialog
  CASE sigdec
    DEC signalsetup
    IF signalsetup<0
      signalsetup=maxsigsetups
    ENDIF
    fill_signaltausch_dialog
  CASE siginc
    INC signalsetup
    IF signalsetup>maxsigsetups
      signalsetup=0
    ENDIF
    fill_signaltausch_dialog
  CASE diout1 TO diout8
    FOR signal=1 TO maxsignals
      EXIT IF exitbutton%=dsignal(signal)
    NEXT signal
    signal_setup|(signal,signalsetup)=@ipmidich(signal_setup|(signal,signalsetup))
    rscaddress(dsigtau,0)
    set_text(dsignal(signal),RIGHT$("0"+STR$(signal_setup|(signal,signalsetup)),2))
  ENDSELECT
  rscaddress(dsigtau,0)
RETURN
FUNCTION int_signal(signal)
  ' Erlaubt die Auswahl von Signal 1 bis maxsignals
  te!=FALSE
  rscaddress(dsignal,0)
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  preselect(dcminput(signal))
  dialogbox(0,1)
  FOR signal=1 TO maxsignals
    EXIT IF exitbutton%=dcminput(signal)
  NEXT signal
  te!=TRUE
  RETURN signal MOD 9
ENDFUNC
'
PROCEDURE gesamt_parameter
  stop_3d_timer
  signal=0
  makronr=@get_makronr(signal)
  rscaddress(dgespara,0)
  fill_dg_dialog
  dialogbox(dgdrehx,2)
  SELECT exitbutton%
  CASE dgok
    get_dg_dialog
  ENDSELECT
  updatemenu
  fill_window(5,FALSE)
  fill_window(6,FALSE)
  signal=1
RETURN
PROCEDURE fill_dg_dialog
  LOCAL flag!
  set_text(dgdrehx,STR$(dreh(0,0)))
  set_text(dgdrehy,STR$(dreh(1,0)))
  set_text(dgdrehz,STR$(dreh(2,0)))
  set_text(dgsetup,STR$(makronr))
  select(dgvert0,NOT (tausch!(0,0) OR tausch!(1,0) OR tausch!(2,0)))
  select(dgvertxy,tausch!(0,0))
  select(dgvertxz,tausch!(1,0))
  select(dgvertyz,tausch!(2,0))
RETURN
PROCEDURE get_dg_dialog
  editedtext(dgdrehx,TRUE)
  dreh(0,0)=VAL(edtext$)
  editedtext(dgdrehy,TRUE)
  dreh(1,0)=VAL(edtext$)
  editedtext(dgdrehz,TRUE)
  dreh(2,0)=VAL(edtext$)
  tausch!(0,0)=@selected(dgvertxy)
  tausch!(1,0)=@selected(dgvertxz)
  tausch!(2,0)=@selected(dgvertyz)
RETURN
PROCEDURE te_dg_dialog
  SELECT exitbutton%
    '  CASE dgsetinc
    '    set_makronr(input,makronr+1)
    '    fill_dg_dialog
    '  CASE ipsetdec
    '    '      makronr=MAX(0,makronr-1)
    '    set_makronr(input,MAX(0,makronr-1))
    '    fill_dg_dialog
  CASE dgsetup
    editedtext(dgsetup,TRUE)
    '      makronr=MAX(0,VAL(edtext$))
    set_makronr(signal,MAX(0,VAL(edtext$)))
    fill_dg_dialog
    firstedit%=dgsetup
  ENDSELECT
RETURN
'
PROCEDURE ed_help
  gprint(1,1," Record              *")
  gprint(1,2," Play               Ret")
  gprint(1,3," Stop             Space/0")
  gprint(1,4," Cycle               /")
  gprint(1,5," Input 1-8 an/aus 1,2,..,8")
  gprint(1,6," NÑchster Event      (")
  gprint(1,7," Vorheriger Event    )")
  gprint(1,8," Sperre              s")
  gprint(1,9," Zeitlupe            z")
  gprint(1,10," Ende               Esc")
  gprint(1,12," ^ bedeutet CONTROL-Taste")
  gprint(1,13,"  bedeutet ALTERNATE-Taste")
RETURN
'
PROCEDURE mtr_parameter
  stop_3d_timer
  rscaddress(dallrot,0)
  fill_mtr_dialog
  signal=1
  dialogbox(damtrnr,2)
  SELECT exitbutton%
  CASE daok
    '    get_mtr_dialog
    mtr_setup=@setup_num(max_mtr_setups,VAL(@editedtxt$(damtrnr)))
  ENDSELECT
  FOR signal=1 TO maxsignals
    IF signal>0 AND mtr_richtung(signal,mtr_setup)<>2
      ' 2=Stop
      play_inp!(signal)=TRUE
    ENDIF
  NEXT signal
  mtr_reset
  signal=1
  updatemenu
  fill_window(5,FALSE)
  fill_window(6,FALSE)
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
RETURN
PROCEDURE fill_mtr_dialog
  set_text(damtrnr,STR$(mtr_setup))
  select(dasinus,mtr_form(mtr_setup)=0)
  select(datriang,mtr_form(mtr_setup)=1)
  FOR signal=1 TO maxsignals
    set_text(daebene(signal),mtr_ebene$(mtr_dreh(signal,mtr_setup)))
    set_text(daphase(signal),STR$(mtr_phase(signal,mtr_setup)))
    set_text(dasekum(signal),STR$(mtr_seku(signal,mtr_setup)))
    IF mtr_seku(signal,mtr_setup)>0
      set_text(dausek(signal),STR$(@suus(mtr_seku(signal,mtr_setup))))
    ENDIF
    set_text(dawinkel(signal),STR$(mtr_wausschnitt%(signal,mtr_setup)))
    IF mtr_modus(signal,mtr_setup)=0
      ' Durchlauf
      mtr_modus(signal,mtr_setup)=2
    ENDIF
    set_text(damodus(signal),mtr_modus$(mtr_modus(signal,mtr_setup)))
    IF mtr_richtung(signal,mtr_setup)=0
      ' Stop
      mtr_richtung(signal,mtr_setup)=2
    ENDIF
    set_text(daricht(signal),mtr_richtung$(mtr_richtung(signal,mtr_setup)))
  NEXT signal
RETURN
PROCEDURE get_mtr_dialog
  LOCAL richtung
  rotation_triang!=@selected(datriang)
  FOR signal=0 TO maxsignals
    FOR dadreh=0 TO 14
      IF @selected(dadreh(signal,dadreh))
        mtr_dreh(signal,mtr_setup)=dadreh
      ENDIF
    NEXT dadreh
    daricht$=@editedtxt$(daricht(signal))
    FOR richtung=1 TO 3
      IF daricht$=mtr_richtung$(richtung)
        mtr_richtung(signal,mtr_setup)=richtung
      ENDIF
    NEXT richtung
    damodus$=@editedtxt$(damodus(signal))
    FOR modus=1 TO 3
      IF damodus$=mtr_modus$(modus)
        mtr_modus(signal,mtr_setup)=modus
      ENDIF
    NEXT modus
    mtr_seku(signal,mtr_setup)=VAL(@editedtxt$(dasekum(signal)))
    mtr_phase(signal,mtr_setup)=VAL(@editedtxt$(daphase(signal)))
    mtr_wausschnitt%(signal,mtr_setup)=VAL(@editedtxt$(dawinkel(signal)))
  NEXT signal
RETURN
PROCEDURE te_mtr_dialog
  LOCAL fe%,hilf#
  ' fe%=exitbutton%
  IF exitbutton%=damtrdec
    '    get_mtr_dialog
    DEC mtr_setup
    IF mtr_setup<0
      mtr_setup=max_mtr_setups
    ENDIF
    fill_mtr_dialog
  ELSE IF exitbutton%=damtrinc
    '    get_mtr_dialog
    INC mtr_setup
    IF mtr_setup>max_mtr_setups
      mtr_setup=0
    ENDIF
    fill_mtr_dialog
  ELSE IF exitbutton%=damtrnr
    '      get_mtr_dialog
    mtr_setup=@setup_num(max_mtr_setups,VAL(@editedtxt$(damtrnr)))
    fill_mtr_dialog
  ELSE IF exitbutton%=dastore
    rufton2
    edit_mtr_setup=@setup_num(max_mtr_setups,@dzahl(edit_mtr_setup))
    copy_mtr_setup(mtr_setup,edit_mtr_setup)
    mtr_setup=edit_mtr_setup
    set_text(damtrnr,STR$(mtr_setup))
    mtr_aenderung!=TRUE
  ELSE IF exitbutton%=darecall
    IF mtr_setup=0
      ' Darf aus SicherheitsgrÅnden nicht zum VerÑndern der Setups
      ' verwendet werden!
      PRINT CHR$(7);
      copy_mtr_setup(@setup_num(max_mtr_setups,@dzahl(edit_mtr_setup)),mtr_setup)
      fill_mtr_dialog
    ENDIF
  ELSE
    temp_mtr_setup
    set_text(damtrnr,STR$(mtr_setup))
    IF exitbutton%=dasinus
      mtr_form(mtr_setup)=0
    ELSE IF exitbutton%=datriang
      mtr_form(mtr_setup)=1
    ENDIF
    FOR signal=1 TO maxsignals
      IF exitbutton%=dasekum(signal)
        mtr_seku(signal,mtr_setup)=@dzahl(mtr_seku(signal,mtr_setup))
        set_text(dasekum(signal),STR$(mtr_seku(signal,mtr_setup)))
        IF mtr_seku(signal,mtr_setup)>0
          set_text(dausek(signal),STR$(@suus(mtr_seku(signal,mtr_setup))))
        ENDIF
      ELSE IF exitbutton%=dausek(signal)
        mtr_seku(signal,mtr_setup)=@ussu(@dzahl(@suus(mtr_seku(signal,mtr_setup))))
        set_text(dasekum(signal),STR$(mtr_seku(signal,mtr_setup)))
        IF mtr_seku(signal,mtr_setup)>0
          set_text(dausek(signal),STR$(@suus(mtr_seku(signal,mtr_setup))))
        ENDIF
      ELSE IF exitbutton%=daphase(signal)
        mtr_phase(signal,mtr_setup)=@dzahl(mtr_phase(signal,mtr_setup))
        set_text(daphase(signal),STR$(mtr_phase(signal,mtr_setup)))
      ELSE IF exitbutton%=daebene(signal)
        mtr_dreh(signal,mtr_setup)=@debene
        set_text(daebene(signal),mtr_ebene$(mtr_dreh(signal,mtr_setup)))
      ELSE IF exitbutton%=damodus(signal)
        mtr_modus(signal,mtr_setup)=@dmodus
        set_text(damodus(signal),mtr_modus$(mtr_modus(signal,mtr_setup)))
      ELSE IF exitbutton%=daricht(signal)
        mtr_richtung(signal,mtr_setup)=@drichtung
        set_text(daricht(signal),mtr_richtung$(mtr_richtung(signal,mtr_setup)))
      ELSE IF exitbutton%=dawinkel(signal)
        mtr_wausschnitt%(signal,mtr_setup)=@dzahl(mtr_wausschnitt%(signal,mtr_setup))
        set_text(dawinkel(signal),STR$(mtr_wausschnitt%(signal,mtr_setup)))
      ENDIF
    NEXT signal
  ENDIF
RETURN
PROCEDURE temp_mtr_setup
  IF mtr_setup>0
    ' Setup muû erst in 0-Setup kopiert werden, bevor es bearbeitet werden darf!
    copy_mtr_setup(mtr_setup,0)
    edit_mtr_setup=mtr_setup
    mtr_setup=0
  ENDIF
RETURN
PROCEDURE copy_mtr_setup(source,dest)
  LOCAL signal
  FOR signal=0 TO maxsignals
    mtr_dreh(signal,dest)=mtr_dreh(signal,source)
    mtr_richtung(signal,dest)=mtr_richtung(signal,source)
    mtr_modus(signal,dest)=mtr_modus(signal,source)
    mtr_seku(signal,dest)=mtr_seku(signal,source)
    mtr_phase(signal,dest)=mtr_phase(signal,source)
    mtr_wausschnitt%(signal,dest)=mtr_wausschnitt%(signal,source)
  NEXT signal
  mtr_form(dest)=mtr_form(source)
RETURN
PROCEDURE do_mtr_setup(setup)
  mtr_setup=setup
  mtr_reset
RETURN
PROCEDURE mtr_reset
  FOR signal=0 TO maxsignals
    mtr_wpos#(signal)=mtr_phase(signal,mtr_setup)
    mtr_winkel(signal)
  NEXT signal
  IF relation_mtrlfo>0
    reset_lfos
  ENDIF
RETURN
PROCEDURE mtr_winkel(signal)
  mtr_winkel#(signal)=@stepwinkel(mtr_seku(signal,mtr_setup))
  SELECT mtr_richtung(signal,mtr_setup)
  CASE 0,2
    mtr_winkel#(signal)=0
  CASE 1
    MUL mtr_winkel#(signal),-1
  ENDSELECT
  '  ALERT 1,"Rot: "+STR$(signal)+"|"+STR$(mtr_winkel#(signal)),1," OK ",wahl
RETURN
FUNCTION dmodus
  te!=FALSE
  tree_alt=tree
  rscaddress(drotmod,0)
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  preselect=mtr_modus(signal,mtr_setup)
  popupbox(preselect,1)
  te!=TRUE
  rscaddress(tree_alt,0)
  ' obj_draw(0,max_depth)
  IF exitbutton%>0
    RETURN exitbutton%
  ELSE
    RETURN mtr_modus(signal,mtr_setup)
  ENDIF
ENDFUNC
FUNCTION drichtung
  te!=FALSE
  tree_alt=tree
  rscaddress(drotrich,0)
  preselect=mtr_richtung(signal,mtr_setup)
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  popupbox(preselect,1)
  te!=TRUE
  rscaddress(tree_alt,0)
  ' obj_draw(0,max_depth)
  IF exitbutton%>0
    RETURN exitbutton%
  ELSE
    RETURN mtr_richtung(signal,mtr_setup)
  ENDIF
ENDFUNC
FUNCTION debene
  te!=FALSE
  tree_alt=tree
  '  treeaddr%=adr_rotrsc%
  '  tree=0
  rscaddress(droteben,0)
  preselect=mtr_dreh(signal,mtr_setup)+1
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  popupbox(preselect,1)
  te!=TRUE
  rscaddress(tree_alt,0)
  ' obj_draw(0,max_depth)
  IF exitbutton%>0
    RETURN exitbutton%-1
  ELSE
    RETURN mtr_dreh(signal,mtr_setup)
  ENDIF
ENDFUNC
'
PROCEDURE rts_dialog
  IF FALSE
    ' Dialogbox zum Benennen und Merken von MTR/RTM-Setups
    stop_3d_timer
    rscaddress(dfkeys,0)
    fill_rts_dialog
    dialogbox(dypres1,1)
    IF exitbutton%=dyok
      get_rts_dialog
    ENDIF
  ENDIF
RETURN
PROCEDURE fill_rts_dialog
  IF FALSE
    REM dyabbr=2 !Obj in #12
    REM dyok=3 !Obj in #12
    REM dynumakt=4 !Obj in #12
    REM dytxtakt=5 !Obj in #12
    REM dynumdec=6 !Obj in #12
    REM dynuminc=7 !Obj in #12
    REM dyuebern=8 !Obj in #12
    OB_FLAGS(treeaddr%,dytxtakt)=OB_FLAGS(treeaddr%,dytxtakt) OR &H40
    set_text(dynumakt,STR$(setupnr))
    IF setupnr<=maxsetups/2
      set_text(dytxtakt,setup$(setupnr)+SPACE$(60))
    ELSE
      set_text(dytxtakt,setup2$(setupnr-maxsetups/2)+SPACE$(60))
    ENDIF
  ENDIF
RETURN
PROCEDURE get_rts_dialog
  IF FALSE
    keyn=VAL(@editedtxt$(dynumakt))
    IF setupnr<>0
      do_setup(setupnr)
    ENDIF
  ENDIF
RETURN
PROCEDURE te_rts_dialog
  IF FALSE
    SELECT exitbutton%
    CASE dynumakt
      firstedit%=exitbutton%
      setupnr=MIN(maxsetups,MAX(0,VAL(@editedtxt$(dynumakt))))
      set_text(dynumakt,STR$(setupnr))
      IF setupnr<=maxsetups/2
        set_text(dytxtakt,setup$(setupnr)+SPACE$(60))
      ELSE
        set_text(dytxtakt,setup2$(setupnr-maxsetups/2)+SPACE$(60))
      ENDIF
    CASE dyuebern
      ' Neue Einstellung Åbernehmen
      setupnr=MIN(maxsetups,VAL(@editedtxt$(dynumakt)))
      get_setup(setupnr)
      rscaddress(dfkeys,0)
      fill_rts_dialog
      preset_aenderung!=TRUE
    CASE dynuminc
      setupnr=VAL(@editedtxt$(dynumakt))
      setupnr=(setupnr+1) MOD maxsetups
      set_text(dynumakt,STR$(setupnr))
      IF setupnr<=maxsetups/2
        set_text(dytxtakt,setup$(setupnr)+SPACE$(60))
      ELSE
        set_text(dytxtakt,setup2$(setupnr-maxsetups/2)+SPACE$(60))
      ENDIF
    CASE dynumdec
      setupnr=setupnr-1
      IF setupnr<0
        setupnr=maxsetups
      ENDIF
      set_text(dynumakt,STR$(setupnr))
      IF setupnr<=maxsetups/2
        set_text(dytxtakt,setup$(setupnr)+SPACE$(60))
      ELSE
        set_text(dytxtakt,setup2$(setupnr-maxsetups/2)+SPACE$(60))
      ENDIF
    CASE dytxtakt
      IF doubleclick!
        IF setupnr<=maxsetups/2
          setup$(setupnr)=@fktext$(setupnr)
        ELSE
          setup2$(setupnr-maxsetups/2)=@fktext$(setupnr)
        ENDIF
        rscaddress(dfkeys,0)
        fill_rts_dialog
        preset_aenderung!=TRUE
      ELSE
        IF setupnr<=maxsetups/2
          set_text(dytxtakt,setup$(setupnr)+SPACE$(60))
        ELSE
          set_text(dytxtakt,setup2$(setupnr-maxsetups/2)+SPACE$(60))
        ENDIF
      ENDIF
      firstedit%=dynumakt
    ENDSELECT
  ENDIF
RETURN
FUNCTION fktext$(setupnr)
  LOCAL te_alt!,setup$
  IF FALSE
    te_alt!=te!
    te!=FALSE
    IF setupnr<=maxsetups/2
      setup$=setup$(setupnr)
    ELSE
      setup$=setup2$(setupnr-maxsetups/2)
    ENDIF
    rscaddress(dfkname,0)
    OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
    IF setup$=""
      setup$=lastsetup$
    ENDIF
    set_text(dfktxt,setup$)
    dialogbox(dfktxt,1)
    SELECT exitbutton%
    CASE dfkok
      te!=te_alt!
      editedtext(dfktxt,TRUE)
      lastsetup$=LEFT$(edtext$,LEN(edtext$)-1)+"*"
      RETURN edtext$
    CASE dfkabbr
      te!=te_alt!
      RETURN setup$
    ENDSELECT
  ENDIF
ENDFUNC
PROCEDURE get_setup(setupnr)
  IF FALSE
    IF setupnr<=maxsetups/2
      setup(setupnr,0)=makro
      setup(setupnr,1)=multimode
      setup$(setupnr)=@fktext$(setupnr)
      FOR signal=1 TO maxsignals
        IF play_inp!(signal)
          setup(setupnr,2)=BSET(setup(setupnr,2),signal)
        ELSE
          setup(setupnr,2)=BCLR(setup(setupnr,2),signal)
        ENDIF
      NEXT signal
      setup(setupnr,3)=mausmodus
      FOR signal=0 TO maxsignals
        setup(setupnr,4+signal*7)=mtr_phase(signal,mtr_setup)
        setup(setupnr,5+signal*7)=mtr_seku(signal,mtr_setup)
        setup(setupnr,6+signal*7)=mtr_richtung(signal,mtr_setup)
        setup(setupnr,7+signal*7)=mtr_modus(signal,mtr_setup)
        setup(setupnr,8+signal*7)=mtr_wausschnitt%(signal,mtr_setup)
        setup(setupnr,9+signal*7)=mtr_dreh(signal,mtr_setup)
        setup(setupnr,10+signal*7)=@get_makronr(signal)
      NEXT signal
    ELSE
      setup2nr=setupnr-maxsetups/2
      setup2(setup2nr,0)=makro
      setup2(setup2nr,1)=multimode
      setup2$(setup2nr)=@fktext$(setup2nr)
      FOR signal=1 TO maxsignals
        IF play_inp!(signal)
          setup2(setup2nr,2)=BSET(setup2(setup2nr,2),signal)
        ELSE
          setup2(setup2nr,2)=BCLR(setup2(setup2nr,2),signal)
        ENDIF
      NEXT signal
      setup2(setup2nr,3)=mausmodus
      FOR signal=0 TO maxsignals
        setup2(setup2nr,4+signal*7)=mtr_phase(signal,mtr_setup)
        setup2(setup2nr,5+signal*7)=mtr_seku(signal,mtr_setup)
        setup2(setup2nr,6+signal*7)=mtr_richtung(signal,mtr_setup)
        setup2(setup2nr,7+signal*7)=mtr_modus(signal,mtr_setup)
        setup2(setup2nr,8+signal*7)=mtr_wausschnitt%(signal,mtr_setup)
        setup2(setup2nr,9+signal*7)=mtr_dreh(signal,mtr_setup)
        setup2(setup2nr,10+signal*7)=@get_makronr(signal)
      NEXT signal
    ENDIF
    signal=1
  ENDIF
RETURN
PROCEDURE do_setup(setupnr)
  stop_3d_timer
  IF setupnr<=maxsetups/2
    makro=setup(setupnr,0)
    IF makro>0
      ' inp_makro
    ENDIF
    '    multi(setup(setupnr,1))
    FOR signal=1 TO maxsignals
      play_inp!(signal)=BTST(setup(setupnr,2),signal)
      play_inp_status(signal)
    NEXT signal
    mausmodus=setup(setupnr,3)
    FOR signal=0 TO maxsignals
      mtr_phase(signal,mtr_setup)=setup(setupnr,4+signal*7)
      mtr_seku(signal,mtr_setup)=setup(setupnr,5+signal*7)
      mtr_richtung(signal,mtr_setup)=setup(setupnr,6+signal*7)
      mtr_modus(signal,mtr_setup)=setup(setupnr,7+signal*7)
      mtr_wausschnitt%(signal,mtr_setup)=setup(setupnr,8+signal*7)
      mtr_dreh(signal,mtr_setup)=setup(setupnr,9+signal*7)
      set_makronr(signal,setup(setupnr,10+signal*7))
    NEXT signal
  ELSE
    setup2nr=setupnr-maxsetups/2
    makro=setup2(setup2nr,0)
    IF makro>0
      ' inp_makro
    ENDIF
    '    multi(setup2(setup2nr,1))
    FOR signal=1 TO maxsignals
      play_inp!(signal)=BTST(setup2(setup2nr,2),signal)
      play_inp_status(signal)
    NEXT signal
    mausmodus=setup2(setup2nr,3)
    FOR signal=0 TO maxsignals
      mtr_phase(signal,mtr_setup)=setup2(setup2nr,4+signal*7)
      mtr_seku(signal,mtr_setup)=setup2(setup2nr,5+signal*7)
      mtr_richtung(signal,mtr_setup)=setup2(setup2nr,6+signal*7)
      mtr_modus(signal,mtr_setup)=setup2(setup2nr,7+signal*7)
      mtr_wausschnitt%(signal,mtr_setup)=setup2(setup2nr,8+signal*7)
      mtr_dreh(signal,mtr_setup)=setup2(setup2nr,9+signal*7)
      set_makronr(signal,setup2(setup2nr,10+signal*7))
    NEXT signal
  ENDIF
  FOR signal=0 TO maxsignals
    mtr_winkel(signal)
  NEXT signal
  mtr_reset
  updatemenu
  signal=1
  '  editor_feld
  IF window=5 OR window=6
    TEXT 480,208,STR$(setupnr,4)
  ENDIF
  IF mode<>stop
    start_3d_timer(edtimer)
  ENDIF
RETURN
'
PROCEDURE midi_setup
  stop_3d_timer
  rscaddress(dmidi,0)
  fill_midi_setup
  select(dmsstart,syncstart!)
  select(dmsstop,syncstop!)
  select(dmstimec,synctimec!)
  set_text(dmikanal,STR$(midi_in_channel))
  select(dmostart,sendstart!)
  select(dmostop,sendstop!)
  select(dmotimec,sendtimec!)
  select(dmnoteof,sendnoteoff!)
  set_text(dmokanal,STR$(midi_out_channel))
  dialogbox(0,2)
  SELECT exitbutton%
  CASE dmok
    syncstart!=@selected(dmsstart)
    syncstop!=@selected(dmsstop)
    synctimec!=@selected(dmstimec)
    editedtext(dmstimes,TRUE)
    intimec_offset%=VAL(edtext$)
    inmausext!=@selected(dmsmaus)
    sendstart!=@selected(dmostart)
    sendstop!=@selected(dmostop)
    sendtimec!=@selected(dmotimec)
    sendnoteoff!=@selected(dmnoteof)
    sendmausext!=@selected(dmomaus)
    IF sendtimec!
      edtimer=4
    ELSE
      edtimer=2
    ENDIF
    editedtext(dmotimes,TRUE)
    timec_offset%=VAL(edtext$)
    midi_in_channel=VAL(@editedtxt$(dmikanal))
    midi_out_channel=VAL(@editedtxt$(dmokanal))
  ENDSELECT
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
RETURN
PROCEDURE te_midi_setup
  step=1
  SELECT exitbutton%
  CASE dmikanal
    set_text(dmikanal,STR$(@dzahl(VAL(@editedtxt$(dmikanal)))))
  CASE dmokanal
    set_text(dmokanal,STR$(@dzahl(VAL(@editedtxt$(dmokanal)))))
  CASE dmstimes
    editedtext(dmstimes,TRUE)
    intimec_offset%=VAL(edtext$)
    ~@smpte_f(intimec_offset%)
    SELECT shiftstate%
    CASE 0
      ADD ff,step
    CASE 1,2
      ADD ss,step
    CASE 4
      ADD mm,step
    CASE 8
      ADD hh,step
    ENDSELECT
    '    intimec_offset%=MAX(0,intimec_offset%)
    intimec_offset%=@smpte_d(hh,mm,ss,ff)
  CASE dmotimes
    editedtext(dmotimes,TRUE)
    timec_offset%=VAL(edtext$)
    ~@smpte_f(timec_offset%)
    SELECT shiftstate%
    CASE 0
      ADD ff,step
    CASE 1,2
      ADD ss,step
    CASE 4
      ADD mm,step
    CASE 8
      ADD hh,step
    ENDSELECT
    '    timec_offset%=MAX(0,timec_offset%)
    timec_offset%=@smpte_d(hh,mm,ss,ff)
  ENDSELECT
  firstedit%=exitbutton%
  fill_midi_setup
RETURN
PROCEDURE fill_midi_setup
  set_text(dmstimes,RIGHT$("0000000"+STR$(intimec_offset%),8))
  set_text(dmotimes,RIGHT$("0000000"+STR$(timec_offset%),8))
RETURN
'
PROCEDURE anz_parameter
  stop_3d_timer
  rscaddress(dparaman,0)
  select(anzpanpo,disp_panpos!)
  select(anzpanbr,disp_panbreite!)
  select(anzmtrsp,disp_mtrspeed!)
  select(anzvorun,disp_vorzur!)
  select(anzvol,disp_volume!)
  select(anzxyz,disp_xyzkoor!)
  select(anzzoom,disp_zoom!)
  select(anzcount,disp_count!)
  select(anzzeit,disp_zeit!)
  dialogbox(0,1)
  disp_panpos!=@selected(anzpanpo)
  disp_panbreite!=@selected(anzpanbr)
  disp_mtrspeed!=@selected(anzmtrsp)
  disp_vorzur!=@selected(anzvorun)
  disp_volume!=@selected(anzvol)
  disp_xyzkoor!=@selected(anzxyz)
  disp_zoom!=@selected(anzzoom)
  disp_count!=@selected(anzcount)
  disp_zeit!=@selected(anzzeit)
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
RETURN
'
PROCEDURE presetbox(xmouse,ymouse,doubleclick!)
  rscaddress(dpresets,0)
  '  LET doubleclick!=(MENU(15)=2)
  object=OBJC_FIND(treeaddr%,0,5,xmouse,ymouse)
  IF object>0
    stop_3d_timer
    SELECT object
    CASE presgen
      pres_change_type=0
    CASE presmtr
      pres_change_type=1
    CASE presspi
      pres_change_type=2
    CASE preslfo1
      pres_change_type=3
    CASE preslfo2
      pres_change_type=3
    CASE presinp
      pres_change_type=5
    CASE presitt
      pres_change_type=6
    ENDSELECT
    disp_dpresets
  ENDIF
RETURN
PROCEDURE change_preset_type(inc!)
  IF inc!
    INC pres_change_type
  ELSE
    DEC pres_change_type
  ENDIF
  pres_change_type=(7+pres_change_type) MOD 7
  disp_dpresets
RETURN
PROCEDURE disp_dpresets
  IF window=5 OR window=6
    rscaddress(dpresets,0)
    OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
    @movable(tree)
    OB_X(treeaddr%,0)=xbox+3
    OB_Y(treeaddr%,0)=ybox+3
    wbox=OB_W(treeaddr%,0)+6
    hbox=OB_H(treeaddr%,0)+6
    set_text(presgen,STR$(generalsetup))
    set_text(presmtr,STR$(mtr_setup))
    set_text(presspi,STR$(spiegelsetup))
    set_text(preslfo1,STR$(lfo_setup(0)))
    set_text(preslfo2,STR$(lfo_setup(1)))
    set_text(presinp,STR$(inputsetup))
    set_text(presitt,STR$(signalsetup))
    deselect(presgen,preslfo2)
    preselect(@pres_change_type_obj(pres_change_type))
    obj_draw(0,max_depth)
  ENDIF
RETURN
FUNCTION pres_change_type_obj(pres_change_type)
  SELECT pres_change_type
  CASE 0
    object=presgen
  CASE 1
    object=presmtr
  CASE 2
    object=presspi
  CASE 3
    object=preslfo1
  CASE 4
    object=preslfo2
  CASE 5
    object=presinp
  CASE 6
    object=presitt
  ENDSELECT
  RETURN object
ENDFUNC
PROCEDURE change_presets(inc!)
  ' Erlaubt Erhîhung/Erniedrigung d. aktuellen Wertes
  ' EVERY STOP
  rscaddress(dpresets,0)
  te!=FALSE
  SELECT pres_change_type
  CASE 0
    IF inc!
      generalsetup=(generalsetup+maxgensetups+2) MOD (1+maxgensetups)
    ELSE
      generalsetup=(generalsetup+maxgensetups-0) MOD (1+maxgensetups)
    ENDIF
    set_text(presgen,STR$(generalsetup))
    do_general_setup(generalsetup)
  CASE 1
    IF inc!
      mtr_setup=(mtr_setup+max_mtr_setups+2) MOD (1+max_mtr_setups)
    ELSE
      mtr_setup=(mtr_setup+max_mtr_setups-0) MOD (1+max_mtr_setups)
    ENDIF
    temp_gen_setup
    general_setup(0,generalsetup)=mtr_setup
    do_mtr_setup(mtr_setup)
    set_text(presmtr,STR$(mtr_setup))
  CASE 2
    IF inc!
      spiegelsetup=(spiegelsetup+maxspisetups+2) MOD (1+maxspisetups)
    ELSE
      spiegelsetup=(spiegelsetup+maxspisetups-0) MOD (1+maxspisetups)
    ENDIF
    set_text(presspi,STR$(spiegelsetup))
    do_spiegel_setup(spiegelsetup)
    temp_gen_setup
    general_setup(3,generalsetup)=spiegelsetup
  CASE 3
    IF inc!
      lfo_setup(0)=(lfo_setup(0)+maxlfosetups+2) MOD (1+maxlfosetups)
    ELSE
      lfo_setup(0)=(lfo_setup(0)+maxlfosetups-0) MOD (1+maxlfosetups)
    ENDIF
    set_text(preslfo1,STR$(lfo_setup(0)))
    do_lfo_setup(lfo_setup(0),0)
    temp_gen_setup
    general_setup(1,generalsetup)=lfo_setup(0)
  CASE 4
    IF inc!
      lfo_setup(1)=(lfo_setup(1)+maxlfosetups+2) MOD (1+maxlfosetups)
    ELSE
      lfo_setup(1)=(lfo_setup(1)+maxlfosetups-0) MOD (1+maxlfosetups)
    ENDIF
    set_text(preslfo2,STR$(lfo_setup(1)))
    do_lfo_setup(lfo_setup(1),1)
    ' keine GEN-Einbindung
    ' temp_gen_setup
    ' general_setup(1,generalsetup)=lfo_setup(0)
  CASE 5
    IF inc!
      inputsetup=(inputsetup+maxinpsetups+2) MOD (1+maxinpsetups)
    ELSE
      inputsetup=(inputsetup+maxinpsetups-0) MOD (1+maxinpsetups)
    ENDIF
    set_text(presinp,STR$(inputsetup))
    do_inputset(inputsetup)
    temp_gen_setup
    general_setup(2,generalsetup)=inputsetup
  CASE 6
    IF FALSE
      IF inc!
        signalsetup=(signalsetup+maxsigsetups+2) MOD (1+maxsigsetups)
      ELSE
        signalsetup=(signalsetup+maxsigsetups-0) MOD (1+maxsigsetups)
      ENDIF
      set_text(presitt,STR$(signalsetup))
      temp_gen_setup
      general_setup(4,generalsetup)=signalsetup
    ENDIF
  ENDSELECT
  relation_mtrlfo=general_setup(5,generalsetup)
  disp_dpresets
  ueberblend_aktiv  ! incl. 3d_timer-Start
RETURN
PROCEDURE set_presets
  ' Erlaubt Tastatureingabe fÅr aktuellen Wert
  rscaddress(dpresets,0)
  x=VAL(CHR$(ascii%))
  te!=TRUE
  IF a!=FALSE
    setupnr%=x
    set_text(@pres_change_type_obj(pres_change_type),RIGHT$("0"+STR$(setupnr%)+"____",5))
    a!=TRUE
  ELSE IF b!=FALSE
    MUL setupnr%,10
    ADD setupnr%,x
    set_text(@pres_change_type_obj(pres_change_type),RIGHT$("00"+STR$(setupnr%)+"___",5))
    b!=TRUE
  ELSE IF c!=FALSE
    MUL setupnr%,10
    ADD setupnr%,x
    set_text(@pres_change_type_obj(pres_change_type),RIGHT$("000"+STR$(setupnr%)+"__",5))
    c!=TRUE
  ELSE IF d!=FALSE
    MUL setupnr%,10
    ADD setupnr%,x
    set_text(@pres_change_type_obj(pres_change_type),RIGHT$("000"+STR$(setupnr%)+"_",5))
    d!=TRUE
  ELSE
    MUL setupnr%,10
    ADD setupnr%,x
    ' EVERY STOP
    SELECT pres_change_type
    CASE 0
      generalsetup=@setup_num(maxgensetups,setupnr%)
      set_text(@pres_change_type_obj(pres_change_type),STR$(generalsetup))
      do_general_setup(generalsetup)
      relation_mtrlfo=general_setup(5,generalsetup)
    CASE 1
      mtr_setup=@setup_num(max_mtr_setups,setupnr%)
      set_text(@pres_change_type_obj(pres_change_type),STR$(mtr_setup))
      temp_gen_setup
      general_setup(0,generalsetup)=mtr_setup
      do_mtr_setup(mtr_setup)
    CASE 2
      spiegelsetup=@setup_num(maxspisetups,setupnr%)
      set_text(@pres_change_type_obj(pres_change_type),STR$(spiegelsetup))
      do_spiegel_setup(spiegelsetup)
      temp_gen_setup
      general_setup(3,generalsetup)=spiegelsetup
    CASE 3
      lfo_setup(0)=@setup_num(maxlfosetups,setupnr%)
      set_text(@pres_change_type_obj(pres_change_type),STR$(lfo_setup(0)))
      reset_lfos
      calc_lfos
      temp_gen_setup
      general_setup(1,generalsetup)=lfo_setup(0)
    CASE 4
      lfo_setup(1)=@setup_num(maxlfosetups,setupnr%)
      set_text(@pres_change_type_obj(pres_change_type),STR$(lfo_setup(1)))
      reset_lfos
      calc_lfos
      ' temp_gen_setup
      ' general_setup(1,generalsetup)=lfo_setup(1)
    CASE 5
      inputsetup=@setup_num(maxinpsetups,setupnr%)
      set_text(@pres_change_type_obj(pres_change_type),STR$(inputsetup))
      do_inputset(inputsetup)
      temp_gen_setup
      general_setup(2,generalsetup)=inputsetup
    CASE 6
      signalsetup=@setup_num(maxsigsetups,setupnr%)
      set_text(@pres_change_type_obj(pres_change_type),STR$(signalsetup))
      temp_gen_setup
      general_setup(4,generalsetup)=signalsetup
    ENDSELECT
    a!=FALSE
    b!=FALSE
    c!=FALSE
    d!=FALSE
    mtr_angabe!=FALSE
    te!=FALSE
    disp_dpresets
    ueberblend_aktiv
  ENDIF
RETURN
PROCEDURE disp_mtr_setupnr(mtr_setup)
  rscaddress(dpresets,0)
  set_text(presmtr,STR$(mtr_setup))
RETURN
FUNCTION setup_num(maxsetup%,setup%)
  SELECT setup%
  CASE &H0 TO maxsetup%
    ' nix
  CASE maxsetup% TO
    ' WORD overflow
    setup%=maxsetup%
  CASE  TO -1
    ' WORD underflow
    setup%=maxsetup%
  ENDSELECT
  RETURN setup%
ENDFUNC
'
PROCEDURE general_setup_dialog
  stop_3d_timer
  rscaddress(dgenset,0)
  REM gensetit=1 !Obj in #23
  REM gensemtr=3 !Obj in #23
  REM genselfo=4 !Obj in #23
  REM gensenum=5 !Obj in #23
  REM gensedec=6 !Obj in #23
  REM genseinc=7 !Obj in #23
  REM genseich=8 !Obj in #23
  REM genseok=9 !Obj in #23
  fill_genset_dialog
  dialogbox(gensenum,2)
  IF exitbutton%=genseok
    generalsetup=@setup_num(maxgensetups,VAL(@editedtxt$(gensenum)))
    do_general_setup(generalsetup)
  ENDIF
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
RETURN
PROCEDURE te_genset_dialog
  SELECT exitbutton%
  CASE gensenum
    generalsetup=@setup_num(maxgensetups,VAL(@editedtxt$(gensenum)))
    fill_genset_dialog
  CASE gensedec
    DEC generalsetup
    IF generalsetup<0
      generalsetup=maxgensetups
    ENDIF
    fill_genset_dialog
  CASE genseinc
    INC generalsetup
    IF generalsetup>maxgensetups
      generalsetup=0
    ENDIF
    fill_genset_dialog
  CASE genstore
    rufton2
    edit_gensetup=@setup_num(maxgensetups,@dzahl(edit_gensetup))
    copy_gen_setup(generalsetup,edit_gensetup)
    generalsetup=edit_gensetup
    set_text(gensenum,STR$(generalsetup))
    gen_aenderung!=TRUE
  CASE genrecal
    IF generalsetup=0
      ' Darf aus SicherheitsgrÅnden nicht zum VerÑndern der Setups
      ' verwendet werden!
      PRINT CHR$(7);
      copy_gen_setup(@dzahl(@setup_num(maxgensetups,edit_gensetup)),generalsetup)
      fill_genset_dialog
    ENDIF
  DEFAULT
    temp_gen_setup
    set_text(gensenum,STR$(generalsetup))
    SELECT exitbutton%
    CASE gensemtr
      ' MTR-Setup
      general_setup(0,generalsetup)=@setup_num(max_mtr_setups,@dzahl(general_setup(0,generalsetup)))
    CASE genselfo
      ' LFO-Setup
      general_setup(1,generalsetup)=@setup_num(maxlfosetups,@dzahl(general_setup(1,generalsetup)))
    CASE genseich
      ' CM-Input-Setups
      general_setup(2,generalsetup)=@setup_num(maxinpsetups,@dzahl(general_setup(2,generalsetup)))
    CASE gensespi
      ' Spiegel-Setups
      general_setup(3,generalsetup)=@setup_num(maxspisetups,@dzahl(general_setup(3,generalsetup)))
    CASE gensesig
      ' Signal-Tausch-Setups
      general_setup(4,generalsetup)=@setup_num(maxsigsetups,@dzahl(general_setup(4,generalsetup)))
    CASE genrelmt
      ' Relation MTR-LFO-Speed
      general_setup(5,generalsetup)=@setup_num(999,@dzahl(general_setup(5,generalsetup)))
    ENDSELECT
    fill_genset_dialog
  ENDSELECT
RETURN
PROCEDURE fill_genset_dialog
  set_text(gensenum,STR$(generalsetup))
  set_text(gensemtr,STR$(general_setup(0,generalsetup)))
  set_text(genselfo,STR$(general_setup(1,generalsetup)))
  set_text(genseich,STR$(general_setup(2,generalsetup)))
  set_text(gensespi,STR$(general_setup(3,generalsetup)))
  set_text(gensesig,STR$(general_setup(4,generalsetup)))
  set_text(genrelmt,STR$(general_setup(5,generalsetup)))
RETURN
PROCEDURE get_genset_dialog
  generalsetup=@setup_num(maxgensetups,VAL(@editedtxt$(gensenum)))
  ' MTR-Setup
  general_setup(0,generalsetup)=@setup_num(maxsetups,VAL(@editedtxt$(gensemtr)))
  ' LFO-Setup
  general_setup(1,generalsetup)=@setup_num(maxlfosetups,VAL(@editedtxt$(genselfo)))
  ' CM-Input-Sets
  general_setup(2,generalsetup)=@setup_num(maxinpsetups,VAL(@editedtxt$(genseich)))
  ' Spiegel-Sets
  general_setup(3,generalsetup)=@setup_num(maxspisetups,VAL(@editedtxt$(gensespi)))
  ' Intern-Tausch
  general_setup(4,generalsetup)=@setup_num(maxsigsetups,VAL(@editedtxt$(gensesig)))
  ' Relation MTR-LFO lÑuft extra
RETURN
PROCEDURE do_general_setup(generalsetup)
  relation_mtrlfo=general_setup(5,source)
  ' MTR-Setup
  IF general_setup(0,generalsetup)>0
    do_mtr_setup(general_setup(0,generalsetup))
  ENDIF
  IF general_setup(1,generalsetup)>0
    do_lfo_setup(general_setup(1,generalsetup),0)
    ' LFO-Parameter werden direkt Åbernommen
  ENDIF
  IF general_setup(2,generalsetup)>0
    inputsetup=general_setup(2,generalsetup)
    do_inputset(inputsetup)
  ENDIF
  IF general_setup(3,generalsetup)>0
    spiegelsetup=general_setup(3,generalsetup)
    do_spiegel_setup(spiegelsetup)
  ENDIF
  IF general_setup(4,generalsetup)>0
    signalsetup=general_setup(4,generalsetup)
    '    do_signalset(signalsetup)
  ENDIF
RETURN
PROCEDURE temp_gen_setup
  IF generalsetup>0
    ' Setup muû erst in 0-Setup kopiert werden, bevor es bearbeitet werden darf!
    copy_gen_setup(generalsetup,0)
    edit_gensetup=generalsetup
    generalsetup=0
  ENDIF
RETURN
PROCEDURE copy_gen_setup(source,dest)
  FOR x=0 TO 5
    general_setup(x,dest)=general_setup(x,source)
  NEXT x
  IF dest=0
    relation_mtrlfo=general_setup(5,source)
  ENDIF
RETURN
'
PROCEDURE balance
  rscaddress(dbalance,0)
  fill_balance
  FOR signal=1 TO maxsignals
    koor_in_alt(3,signal)=koor_signal(3,signal)
  NEXT signal
  dialogbox(0,2)
  IF exitbutton%=dbabbr
    FOR signal=1 TO maxsignals
      koor_signal(3,signal)=koor_in_alt(3,signal)
    NEXT signal
  ENDIF
RETURN
PROCEDURE fill_balance
  blr=-(koor_signal(3,1)+koor_signal(3,4)+koor_signal(3,5)+koor_signal(3,8)-(koor_signal(3,2)+koor_signal(3,3)+koor_signal(3,6)+koor_signal(3,7)))/4
  bvh=(koor_signal(3,1)+koor_signal(3,2)+koor_signal(3,5)+koor_signal(3,6)-(koor_signal(3,3)+koor_signal(3,4)+koor_signal(3,7)+koor_signal(3,8)))/4
  bou=(koor_signal(3,1)+koor_signal(3,2)+koor_signal(3,3)+koor_signal(3,4)-(koor_signal(3,5)+koor_signal(3,6)+koor_signal(3,7)+koor_signal(3,8)))/4
  b12=-koor_signal(3,1)+koor_signal(3,2)
  b34=-koor_signal(3,3)+koor_signal(3,4)
  b56=-koor_signal(3,5)+koor_signal(3,6)
  b78=-koor_signal(3,7)+koor_signal(3,8)
  set_bal_slider(dbslb12,dbsli12,b12)
  set_bal_slider(dbslb34,dbsli34,b34)
  set_bal_slider(dbslb56,dbsli56,b56)
  set_bal_slider(dbslb78,dbsli78,b78)
  set_bal_slider(dbslblr,dbslilr,blr)
  set_bal_slider(dbslbvh,dbslivh,bvh)
  set_bal_slider(dbslbou,dbsliou,bou)
  set_text(dbvol1,STR$(koor_signal(3,1)))
  set_text(dbvol2,STR$(koor_signal(3,2)))
  set_text(dbvol3,STR$(koor_signal(3,3)))
  set_text(dbvol4,STR$(koor_signal(3,4)))
  set_text(dbvol5,STR$(koor_signal(3,5)))
  set_text(dbvol6,STR$(koor_signal(3,6)))
  set_text(dbvol7,STR$(koor_signal(3,7)))
  set_text(dbvol8,STR$(koor_signal(3,8)))
RETURN
PROCEDURE te_balance
  SELECT exitbutton%
  CASE dbreset
    FOR signal=1 TO maxsignals
      koor_signal(3,signal)=127
    NEXT signal
  CASE dbsli12
    get_bal_slider(dbslb12,dbsli12)
  CASE dbsli34
    get_bal_slider(dbslb34,dbsli34)
  CASE dbsli56
    get_bal_slider(dbslb56,dbsli56)
  CASE dbsli78
    get_bal_slider(dbslb78,dbsli78)
  CASE dbslilr
    ' get_bal_slider(dbslblr,dbslilr)
  CASE dbslivh
    ' get_bal_slider(dbslbvh,dbslivh)
  CASE dbsliou
    ' get_bal_slider(dbslbou,dbsliou)
  ENDSELECT
  fill_balance
RETURN
PROCEDURE set_bal_slider(box,slider,value)
  customslider(box,slider,FALSE,-1,@bal_pos(value))
  set_text(slider,STR$(value))
  IF te!
    obj_draw(box,1)
  ENDIF
RETURN
PROCEDURE get_bal_slider(box,slider)
  graf_slidebox(box,slider,FALSE)
  value=@get_bal(position%)
  set_volume(box)
  '  set_text(text,STR$(value))
  '  set_bal_slider(box,slider,text,value)
  ' customslider(box,slider,FALSE,-1,@bal_pos(value))
  '  obj_draw(box,1)
RETURN
PROCEDURE set_volume(box)
  SELECT box
  CASE dbslb12
    koor_signal(3,1)=MIN(127,127-value)
    koor_signal(3,2)=MIN(127,127+value)
    '    set_text(dbsli12,STR$(value))
  CASE dbslb34
    koor_signal(3,3)=MIN(127,127-value)
    koor_signal(3,4)=MIN(127,127+value)
  CASE dbslb56
    koor_signal(3,5)=MIN(127,127-value)
    koor_signal(3,6)=MIN(127,127+value)
  CASE dbslb78
    koor_signal(3,7)=MIN(127,127-value)
    koor_signal(3,8)=MIN(127,127+value)
  CASE dbslblr
    xyz_8(-value,bou,bvh)
  CASE dbslbvh
    xyz_8(blr,bou,value)
  CASE dbslbou
    xyz_8(blr,value,bvh)
  ENDSELECT
RETURN
PROCEDURE xyz_8(x,y,z)
  x=MAX(-127,MIN(127,x))
  y=MAX(-127,MIN(127,y))
  z=MAX(-127,MIN(127,z))
  fxm=SUB(127,x)
  MUL fxm,fxm
  fym=SUB(127,y)
  MUL fym,fym
  fzm=SUB(127,z)
  MUL fzm,fzm
  fxp=ADD(127,x)
  MUL fxp,fxp
  fyp=ADD(127,y)
  MUL fyp,fyp
  fzp=ADD(127,z)
  MUL fzp,fzp
  koor_signal(3,1)=@voldist(fxp+fzp+fyp)
  koor_signal(3,2)=@voldist(fxm+fzp+fyp)
  koor_signal(3,3)=@voldist(fxm+fzm+fyp)
  koor_signal(3,4)=@voldist(fxp+fzm+fyp)
  koor_signal(3,5)=@voldist(fxp+fzp+fym)
  koor_signal(3,6)=@voldist(fxm+fzp+fym)
  koor_signal(3,7)=@voldist(fxm+fzm+fym)
  koor_signal(3,8)=@voldist(fxp+fzm+fym)
RETURN
PROCEDURE do_balance
  ' Noch nicht eingebunden
RETURN
'
PROCEDURE free_walk
  rscaddress(dfreewal,0)
  select(dfmaus,rand_mode=rand_maus)
  select(dflfo,rand_mode=rand_lfo)
  select(dfaus,rand_mode=0)
  dialogbox(0,2)
  IF exitbutton%=dfok
    IF @selected(dfmaus)
      rand_mode=rand_maus
    ELSE IF @selected(dflfo)
      rand_mode=rand_lfo
    ELSE IF @selected(dfaus)
      rand_mode=0
    ENDIF
  ENDIF
RETURN
PROCEDURE nzeit(frames%)
  hh=DIV(frames%,90000)
  SUB frames%,MUL(hh,90000)
  mm=DIV(frames%,1500)
  SUB frames%,MUL(mm,1500)
  ss=DIV(frames%,25)
  SUB frames%,MUL(ss,25)
  ff=frames%*4 !Quarter-Frames!
  '  RETURN RIGHT$("00"+STR$(hh),2)+":"+RIGHT$("00"+STR$(mm),2)+":"+RIGHT$("00"+STR$(dzeit%),2)
RETURN
'
PROCEDURE ueberblend_aktiv
  ' Aktiviert öberblend-Funktion
  stop_3d_timer
  ueberblend_aktiv!=TRUE
  ueberblend_count%=0   !zur Sicherheit
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
RETURN
PROCEDURE ueberblenden
  '  INC count%
  '  BMOVE V:koor_in_alt(0,1),V:koor_pre_ueberbl(0,1),80
  INC ueberblend_count%
  IF ueberblend>0 ! öberspringen, wenn keine öberblendung an.
    FOR signal=1 TO maxsignals
      IF ueberblend_count%=1
        ' Abstand+Schrittweite feststellen
        FOR koor=0 TO 2
          ueberblend_dist(koor,signal)=ROUND((koor_signal(koor,signal)-koor_in_alt(koor,signal))/ueberblend)
        NEXT koor
      ENDIF
      FOR koor=0 TO 2
        koor_signal(koor,signal)=koor_in_alt(koor,signal)+ueberblend_dist(koor,signal)
      NEXT koor
    NEXT signal
  ENDIF
  '  merk_koor in ed_disp
  IF ueberblend_count%>=ueberblend
    ueberblend_aktiv!=FALSE
    ueberblend_count%=0
  ENDIF
  '  BMOVE V:koor_pre_ueberbl(0,1),V:koor_in_alt(0,1),80
  '  IF mode<>stop
  '  ' EVERY edtimer GOSUB 3d_timer
  ' ENDIF
  ' ENDIF
RETURN
'
PROCEDURE lfo_parameter(x)
  lfo_group=x
  stop_3d_timer
  rscaddress(dlfos,0)
  fill_lfo_dialog(lfo_group)
  dialogbox(0,4)
  SELECT exitbutton%
  CASE lfok
    lfo_setup(lfo_group)=VAL(@editedtxt$(lfsetnr))
    reset_lfos
  ENDSELECT
  updatemenu
  fill_window(5,FALSE)
  fill_window(6,FALSE)
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
RETURN
PROCEDURE fill_lfo_dialog(lfo_group)
  LOCAL lfo,ziel
  set_text(lftitle,"LFO-Setup Gruppe: "+STR$(lfo_group+1))
  set_text(lfsetnr,STR$(lfo_setup(lfo_group)))
  FOR lfo=0 TO maxlfos
    set_text(dlfo(lf1quell,lfo),lfo_quell$(lfo_param(1,lfo,lfo_setup(lfo_group))))
    select(dlfo(lf1quell,lfo),lfo_param(1,lfo,lfo_setup(lfo_group))>0)
    set_text0(dlfo(lf1speed,lfo),STR$(lfo_param(2,lfo,lfo_setup(lfo_group))))
    set_text0(dlfo(lf1phase,lfo),STR$(lfo_param(3,lfo,lfo_setup(lfo_group))))
    set_text0(dlfo(lf1ampl,lfo),STR$(lfo_param(4,lfo,lfo_setup(lfo_group))))
    set_text0(dlfo(lf1offs,lfo),STR$(lfo_param(5,lfo,lfo_setup(lfo_group))))
    set_text0(dlfo(lf1pauso,lfo),STR$(lfo_param(6,lfo,lfo_setup(lfo_group))))
    set_text0(dlfo(lf1pausu,lfo),STR$(lfo_param(7,lfo,lfo_setup(lfo_group))))
    set_text(dlfo(lf1ctin,lfo),STR$(lfo_param(8,lfo,lfo_setup(lfo_group))))
    set_text0(dlfo(lf1ctout,lfo),STR$(lfo_param(9,lfo,lfo_setup(lfo_group))))
  NEXT lfo
  FOR ziel=0 TO 3
    set_text0(dlplfo(dlfstbas,ziel),STR$(lfo_ziel(1,ziel,lfo_setup(lfo_group))))
    set_text0(dlplfo(dlfpanpo,ziel),STR$(lfo_ziel(2,ziel,lfo_setup(lfo_group))))
  NEXT ziel
  FOR ziel=0 TO maxsignals-1
    set_text0(dlplfo(dlfmtrspd,ziel),STR$(lfo_ziel(3,ziel,lfo_setup(lfo_group))))
    set_text0(dlplfo(dlfvolume,ziel),STR$(lfo_ziel(4,ziel,lfo_setup(lfo_group))))
    set_text0(dlplfo(dlfzoom,ziel),STR$(lfo_ziel(5,ziel,lfo_setup(lfo_group))))
    set_text0(dlplfo(dlffree,ziel),STR$(lfo_ziel(6,ziel,lfo_setup(lfo_group))))
    set_text0(dlplfo(dlfposx,ziel),STR$(lfo_ziel(7,ziel,lfo_setup(lfo_group))))
    set_text0(dlplfo(dlfposy,ziel),STR$(lfo_ziel(8,ziel,lfo_setup(lfo_group))))
    set_text0(dlplfo(dlfposz,ziel),STR$(lfo_ziel(9,ziel,lfo_setup(lfo_group))))
  NEXT ziel
RETURN
PROCEDURE get_lfo_dialog(lfo_group)
  panbreite_lfo=-1             ! Default -1=Kein LFO dafÅr da.
  panpos_lfo=-1                ! Default -1=Kein LFO dafÅr da.
  neulfosetup=VAL(@editedtxt$(lfsetnr))
  IF lfo_setup(lfo_group)<>neulfosetup
    ' Methode, um LFO-Daten zu kopieren: Beim Rausgehen andere Nummer eintragen
    ' Quelle muû extra kopiert werden, Rest von alleine
    FOR lfo=0 TO maxlfos
      lfo_param(1,lfo,neulfosetup)=lfo_param(1,lfo,lfo_setup(lfo_group))
    NEXT lfo
  ENDIF
  lfo_setup(lfo_group)=neulfosetup
  FOR lfo=0 TO maxlfos
    ' Quelle wird in lfoq_dialog eingestellt
    lfo_param(2,lfo,lfo_setup(lfo_group))=VAL(@editedtxt$(dlfo(lf1speed,lfo)))
    lfo_param(3,lfo,lfo_setup(lfo_group))=VAL(@editedtxt$(dlfo(lf1phase,lfo)))
    lfo_param(4,lfo,lfo_setup(lfo_group))=VAL(@editedtxt$(dlfo(lf1ampl,lfo)))
    lfo_param(5,lfo,lfo_setup(lfo_group))=VAL(@editedtxt$(dlfo(lf1offs,lfo)))
    lfo_param(6,lfo,lfo_setup(lfo_group))=VAL(@editedtxt$(dlfo(lf1pauso,lfo)))
    lfo_param(7,lfo,lfo_setup(lfo_group))=VAL(@editedtxt$(dlfo(lf1pausu,lfo)))
    lfo_param(8,lfo,lfo_setup(lfo_group))=VAL(@editedtxt$(dlfo(lf1ctin,lfo)))
    lfo_param(9,lfo,lfo_setup(lfo_group))=VAL(@editedtxt$(dlfo(lf1ctout,lfo)))
  NEXT lfo
  FOR ziel=0 TO 3
    lfo_ziel(1,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlfstbas,ziel)))
    lfo_ziel(2,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlfpanpo,ziel)))
  NEXT ziel
  FOR ziel=0 TO maxsignals-1
    lfo_ziel(3,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlfmtrspd,ziel)))
    lfo_ziel(4,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlfvolume,ziel)))
    lfo_ziel(5,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlfzoom,ziel)))
    lfo_ziel(6,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlffree,ziel)))
    lfo_ziel(7,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlfposx,ziel)))
    lfo_ziel(8,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlfposy,ziel)))
    lfo_ziel(9,ziel,lfo_setup(lfo_group))=VAL(@editedtxt$(dlplfo(dlfposz,ziel)))
  NEXT ziel
RETURN
PROCEDURE te_lfo_dialog(lfo_group)
  LOCAL x,lfdialexitb%
  lfdialexitb%=exitbutton%      ! Speichern wg. Zwischenaufrufen @dialogbox
  IF lfdialexitb%=lfsetinc
    INC lfo_setup(lfo_group)
    IF lfo_setup(lfo_group)>maxlfosetups
      lfo_setup(lfo_group)=0
    ENDIF
    fill_lfo_dialog(lfo_group)
  ELSE IF lfdialexitb%=lfsetdec
    DEC lfo_setup(lfo_group)
    IF lfo_setup(lfo_group)<0
      lfo_setup(lfo_group)=maxlfosetups
    ENDIF
    fill_lfo_dialog(lfo_group)
  ELSE IF lfdialexitb%=lfsetnr
    lfo_setup(lfo_group)=@setup_num(maxlfosetups,VAL(@editedtxt$(lfsetnr)))
    fill_lfo_dialog(lfo_group)
  ELSE IF lfdialexitb%=lfstore
    rufton2
    edit_lfosetup=@setup_num(maxlfosetups,@dzahl(edit_lfosetup))
    copy_lfo_setup(lfo_setup(lfo_group),edit_lfosetup)
    lfo_setup(lfo_group)=edit_lfosetup
    lfo_aenderung!=TRUE
    set_text(lfsetnr,STR$(lfo_setup(lfo_group)))
  ELSE IF lfdialexitb%=lfrecall
    IF lfo_setup(lfo_group)=0
      ' Darf aus SicherheitsgrÅnden nicht zum VerÑndern der Setups
      ' verwendet werden!
      PRINT CHR$(7);
      copy_lfo_setup(@dzahl(@setup_num(maxlfosetups,edit_lfosetup)),lfo_setup(lfo_group))
      fill_lfo_dialog(lfo_group)
    ENDIF
  ELSE
    temp_lfo_setup
    set_text(lfsetnr,STR$(lfo_setup(lfo_group)))
    FOR lfo=0 TO maxlfos
      IF lfdialexitb%=dlfo(lf1quell,lfo)
        lfo_param(1,lfo,lfo_setup(lfo_group))=@lfoq_dialog(lfo_param(1,lfo,lfo_setup(lfo_group)))
        set_text(dlfo(lf1quell,lfo),lfo_quell$(lfo_param(1,lfo,lfo_setup(lfo_group))))
        select(dlfo(lf1quell,lfo),lfo_param(1,lfo,lfo_setup(lfo_group))>0)
      ELSE IF lfdialexitb%=dlfo(lf1speed,lfo)
        lfo_param(2,lfo,lfo_setup(lfo_group))=@dzahl(lfo_param(2,lfo,lfo_setup(lfo_group)))
        set_text0(dlfo(lf1speed,lfo),STR$(lfo_param(2,lfo,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlfo(lf1phase,lfo)
        lfo_param(3,lfo,lfo_setup(lfo_group))=@dzahl(lfo_param(3,lfo,lfo_setup(lfo_group)))
        lfo_param(3,lfo,lfo_setup(lfo_group))=MIN(359,MAX(0,lfo_param(3,lfo,lfo_setup(lfo_group))))
        set_text0(dlfo(lf1phase,lfo),STR$(lfo_param(3,lfo,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlfo(lf1ampl,lfo)
        lfo_param(4,lfo,lfo_setup(lfo_group))=@dzahl(lfo_param(4,lfo,lfo_setup(lfo_group)))
        set_text0(dlfo(lf1ampl,lfo),STR$(lfo_param(4,lfo,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlfo(lf1offs,lfo)
        lfo_param(5,lfo,lfo_setup(lfo_group))=@dzahl(lfo_param(5,lfo,lfo_setup(lfo_group)))
        set_text0(dlfo(lf1offs,lfo),STR$(lfo_param(5,lfo,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlfo(lf1pauso,lfo)
        lfo_param(6,lfo,lfo_setup(lfo_group))=MAX(0,@dzahl(lfo_param(6,lfo,lfo_setup(lfo_group))))
        set_text0(dlfo(lf1pauso,lfo),STR$(lfo_param(6,lfo,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlfo(lf1pausu,lfo)
        lfo_param(7,lfo,lfo_setup(lfo_group))=MAX(0,@dzahl(lfo_param(7,lfo,lfo_setup(lfo_group))))
        set_text0(dlfo(lf1pausu,lfo),STR$(lfo_param(7,lfo,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlfo(lf1ctin,lfo)
        lfo_param(8,lfo,lfo_setup(lfo_group))=MAX(0,MIN(127,@dzahl(lfo_param(8,lfo,lfo_setup(lfo_group)))))
        set_text(dlfo(lf1ctin,lfo),STR$(lfo_param(8,lfo,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlfo(lf1ctout,lfo)
        lfo_param(9,lfo,lfo_setup(lfo_group))=MAX(0,MIN(127,@dzahl(lfo_param(9,lfo,lfo_setup(lfo_group)))))
        set_text0(dlfo(lf1ctout,lfo),STR$(lfo_param(9,lfo,lfo_setup(lfo_group))))
      ENDIF
    NEXT lfo
    FOR ziel=0 TO 3
      IF lfdialexitb%=dlplfo(dlfstbas,ziel)
        lfo_ziel(1,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(1,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlfstbas,ziel),STR$(lfo_ziel(1,ziel,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlplfo(dlfpanpo,ziel)
        lfo_ziel(2,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(2,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlfpanpo,ziel),STR$(lfo_ziel(2,ziel,lfo_setup(lfo_group))))
      ENDIF
    NEXT ziel
    FOR ziel=0 TO maxsignals-1
      IF lfdialexitb%=dlplfo(dlfmtrspd,ziel)
        lfo_ziel(3,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(3,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlfmtrspd,ziel),STR$(lfo_ziel(3,ziel,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlplfo(dlfvolume,ziel)
        lfo_ziel(4,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(4,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlfvolume,ziel),STR$(lfo_ziel(4,ziel,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlplfo(dlfzoom,ziel)
        lfo_ziel(5,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(5,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlfzoom,ziel),STR$(lfo_ziel(5,ziel,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlplfo(dlffree,ziel)
        lfo_ziel(6,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(6,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlffree,ziel),STR$(lfo_ziel(6,ziel,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlplfo(dlfposx,ziel)
        lfo_ziel(7,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(7,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlfposx,ziel),STR$(lfo_ziel(7,ziel,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlplfo(dlfposy,ziel)
        lfo_ziel(8,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(8,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlfposy,ziel),STR$(lfo_ziel(8,ziel,lfo_setup(lfo_group))))
      ELSE IF lfdialexitb%=dlplfo(dlfposz,ziel)
        lfo_ziel(9,ziel,lfo_setup(lfo_group))=@lfoz_dialog(lfo_ziel(9,ziel,lfo_setup(lfo_group)))
        set_text0(dlplfo(dlfposz,ziel),STR$(lfo_ziel(9,ziel,lfo_setup(lfo_group))))
      ENDIF
    NEXT ziel
  ENDIF
RETURN
FUNCTION lfoq_dialog(quelle)
  LOCAL quelle
  ' Legt LFO-Waveform fest
  te!=FALSE
  tree_alt=tree
  rscaddress(dlfoquel,0)
  preselect=dlqlfo(quelle)
  ' Movable
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  popupbox(preselect,1)
  rscaddress(tree_alt,0)
  ' obj_draw(0,max_depth)
  te!=TRUE
  FOR quelle=0 TO maxlfoquellen
    EXIT IF exitbutton%=dlqlfo(quelle)
  NEXT quelle
  RETURN quelle MOD (maxlfoquellen+1)
ENDFUNC
FUNCTION lfoz_dialog(quelle)
  ' Legt LFO-Quelle in Patchbay fest
  te!=FALSE
  tree_alt=tree
  rscaddress(dlfosel,0)
  ' Movable
  preselect=dlzlfo(quelle)
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  popupbox(preselect,1)
  rscaddress(tree_alt,0)
  ' obj_draw(0,max_depth)
  te!=TRUE
  FOR quelle=0 TO maxlfos+1
    EXIT IF exitbutton%=dlzlfo(quelle)
  NEXT quelle
  RETURN quelle MOD (maxlfos+2)
ENDFUNC
PROCEDURE lfo_opt_radio(lfo,object,parameter,lfo_group)
  LOCAL x
  ' Schaltet diese Option fÅr alle anderen LFO's aus
  FOR x=0 TO maxlfos
    select(dlfo(object,x,lfo_setup(lfo_group)),x=lfo)
    obj_draw(dlfo(object,x),1)
    lfo_param(parameter,lfo,lfo_setup(lfo_group))=x=lfo
  NEXT x
RETURN
PROCEDURE calc_lfos
  ' LFO-Parameter:
  ' 1: Herkunft
  '     0=Aus
  '     1=Maus x
  '     2=Maus Y
  '     3=Midi-Controller
  '     4=Sinus
  '     5=Dreieck
  '     6=SÑgezahn aufwÑrts
  '     7=SÑgezahn abwÑrts
  '     8=Zufallszahl
  '     9=Rechteck
  '    10=Pitchbend
  ' 2: Speed
  ' 3: Phase
  ' 4: Amplitude
  ' 5: Offset
  ' 6: Pause nach 90 Grad
  ' 7: Pause nach 270 Grad
  ' 8: ... Angabe Åber Midi-Controller als Eingang
  ' 9: ... Angabe Åber Midi-Controller als Ausgang
  ' Verwendung:
  ' 1: ... als Stereobasis-Regler
  ' 2: ... als Panpot
  ' 3: ... als Geschwindigkeitsfaktor fÅr Multirotationen
  ' 4: ... als Volume-Wert
  ' 5: ... als Zoom-Faktor
  ' 6: ... als Vor-und-ZurÅck Ausleseposition
  ' 7 ... als X-FÅhrungspunkt
  ' 8 ... als Y-FÅhrungspunkt
  ' 9 ... als Z-FÅhrungspunkt
  '
  ARRAYFILL panbreite(),100                     ! ZurÅcksetzen
  ARRAYFILL panpos(),0                          ! ZurÅcksetzen
  ARRAYFILL rand_koor#(),0                      ! ZurÅcksetzen
  ARRAYFILL koor_add_lfo(),0                    ! ZurÅcksetzen
  '
  DEFTEXT ,,,4                                  ! wegen Textausgaben
  FOR lfo_group=0 TO max_lfo_groups
    IF lfo_setup(lfo_group)<maxlfosetups
      FOR lfo=0 TO maxlfos
        IF lfo_param(1,lfo,lfo_setup(lfo_group))>0               ! An?
          SELECT lfo_param(1,lfo,lfo_setup(lfo_group))
          CASE 1
            ' Maussteuerung X-Koordinate
            lfo_val#(1,lfo,lfo_group)=MIN(wwork(0)/2,MAX(-wwork(0)/2,(MOUSEX-wwork(0)/2)))*lfo_param(4,lfo,lfo_setup(lfo_group))*2/wwork(0)+lfo_param(5,lfo,lfo_setup(lfo_group))
          CASE 2
            ' Maussteuerung Y-Koordinate
            lfo_val#(1,lfo,lfo_group)=MIN(hwork(0)/2,MAX(-hwork(0)/2,(hwork(0)/2-MOUSEY)))*2*lfo_param(4,lfo,lfo_setup(lfo_group))/hwork(0)+lfo_param(5,lfo,lfo_setup(lfo_group))
          CASE 3
            ' Steuerung Åber Midi-Controller
            ' wird in midi_in erledigt
            lfo_val#(1,lfo,lfo_group)=lfo_midiin_val(lfo,lfo_group)*lfo_param(4,lfo,lfo_setup(lfo_group))/128+lfo_param(5,lfo,lfo_setup(lfo_group))
          CASE 4,5,6,7
            ' Sinus, Dreieck, Saw Up, Saw Down
            lfo_val#(1,lfo,lfo_group)=wave(ROUND(720+lfo_val#(0,lfo,lfo_group)+lfo_param(3,lfo,lfo_setup(lfo_group))) MOD 360,lfo_param(1,lfo,lfo_setup(lfo_group))-4)*lfo_param(4,lfo,lfo_setup(lfo_group))/waveampl/2+lfo_param(5,lfo,lfo_setup(lfo_group))
          CASE 8
            ' Random
            ' Bei speed=100 Berechnung bei jedem count
            IF count% MOD (100/lfo_param(2,lfo,lfo_setup(lfo_group)))=0
              ' Zufallszahl zwischen -50 und 50 als Prozentwert multipl. mit Amplitude + Offset
              lfo_val#(1,lfo,lfo_group)=50-RANDOM(100)/100*lfo_param(4,lfo,lfo_setup(lfo_group))+lfo_param(5,lfo,lfo_setup(lfo_group))
            ENDIF
          CASE 9
            ' Rechteck
            lfo_val#(1,lfo,lfo_group)=wave(lfo_val#(0,lfo,lfo_group)+lfo_param(3,lfo,lfo_setup(lfo_group)),4)*lfo_param(4,lfo,lfo_setup(lfo_group))/waveampl/2+lfo_param(5,lfo,lfo_setup(lfo_group))
          ENDSELECT
          ' LFO-Volume fÅr einzelne KanÑle
          '      lfo_volume=MAX(0,MIN(127,(lfo_val#(1,lfo)+50)*127/100))
        ENDIF
        ' LFO-Weiterstellen
        IF lfo_an!(lfo,lfo_group) AND pauso_cumul(lfo,lfo_group)=0 AND pausu_cumul(lfo,lfo_group)=0
          lfo_val#(0,lfo,lfo_group)=lfo_val#(0,lfo,lfo_group)+lfo_richtung*lfo_winkel#(lfo,lfo_group)*lfo_geschw_koeff(lfo,lfo_group)/100
        ENDIF
        IF lfo_val#(0,lfo,lfo_group)>=360
          lfo_val#(0,lfo,lfo_group)=lfo_val#(0,lfo,lfo_group)-360
        ELSE IF lfo_val#(0,lfo,lfo_group)<0
          lfo_val#(0,lfo,lfo_group)=360-lfo_val#(0,lfo,lfo_group)
        ENDIF
        IF lfo_pauso_winkel#(lfo,lfo_group)>0
          IF (lfo_val#(0,lfo,lfo_group)<270 AND lfo_val#(0,lfo,lfo_group)>=90) AND NOT pauso!(lfo,lfo_group)
            IF pauso_cumul(lfo,lfo_group)=0
              ' Merke alte Position
              lfo_val_alt#(lfo,lfo_group)=lfo_val#(0,lfo,lfo_group)
              lfo_val#(0,lfo,lfo_group)=90
            ENDIF
            IF pauso_cumul(lfo,lfo_group)>=359
              pauso!(lfo,lfo_group)=TRUE
              pauso_cumul(lfo,lfo_group)=0
              pausu!(lfo,lfo_group)=FALSE
              ' Alte Position wieder einstellen, fÅr glatten Durchlauf
              lfo_val#(0,lfo,lfo_group)=lfo_val_alt#(lfo,lfo_group)
            ELSE
              ADD pauso_cumul(lfo,lfo_group),lfo_pauso_winkel#(lfo,lfo_group)*lfo_geschw_koeff(lfo,lfo_group)/100
            ENDIF
          ENDIF
        ELSE IF (lfo_val#(0,lfo,lfo_group)<270 AND lfo_val#(0,lfo,lfo_group)>=90)
          ' Wenn keine Pause eingestellt ist, Pause als abgelaufen betrachten
          ' aber nur, wenn LFO gerade im entspr. Pausenbereich ist.
          pauso!(lfo,lfo_group)=TRUE
          pausu!(lfo,lfo_group)=FALSE
        ENDIF
        IF lfo_pausu_winkel#(lfo,lfo_group)>0
          IF (lfo_val#(0,lfo,lfo_group)>=270 OR lfo_val#(0,lfo,lfo_group)<90) AND NOT pausu!(lfo,lfo_group)
            IF pausu_cumul(lfo,lfo_group)=0
              ' Merke alte Position
              lfo_val_alt#(lfo,lfo_group)=lfo_val#(0,lfo,lfo_group)
              lfo_val#(0,lfo,lfo_group)=270
            ENDIF
            IF pausu_cumul(lfo,lfo_group)>=359
              pausu!(lfo,lfo_group)=TRUE
              pausu_cumul(lfo,lfo_group)=0
              pauso!(lfo,lfo_group)=FALSE
              lfo_val#(0,lfo,lfo_group)=lfo_val_alt#(lfo,lfo_group)
            ELSE
              ADD pausu_cumul(lfo,lfo_group),lfo_pausu_winkel#(lfo,lfo_group)*lfo_geschw_koeff(lfo,lfo_group)/100
            ENDIF
          ENDIF
        ELSE IF (lfo_val#(0,lfo,lfo_group)>=270 OR lfo_val#(0,lfo,lfo_group)<90)
          ' Wenn keine Pause eingestellt ist, Pause als abgelaufen betrachten
          ' s. o.
          pauso!(lfo,lfo_group)=FALSE
          pausu!(lfo,lfo_group)=TRUE
        ENDIF
      NEXT lfo
      FOR ziel=0 TO 3
        IF lfo_ziel(1,ziel,lfo_setup(lfo_group))>0
          ' Panorama-Breite fÅr Stereo-Panoramen
          ' LFO-Standard: Ampl 100= Panpos: -50% .. 50%
          ADD panbreite(ziel),lfo_val#(1,lfo_ziel(1,ziel,lfo_setup(lfo_group))-1,lfo_group)
        ENDIF
        IF lfo_ziel(2,ziel,lfo_setup(lfo_group))>0
          ' Pan-Pos fÅr Stereo-Panoramen
          ' LFO-Standard: Ampl 100= Panpos: -50% .. 50%
          ADD panpos(ziel),lfo_val#(1,lfo_ziel(2,ziel,lfo_setup(lfo_group))-1,lfo_group)
        ENDIF
      NEXT ziel
      FOR ziel=0 TO maxsignals-1
        IF lfo_ziel(3,ziel,lfo_setup(lfo_group))>0
          ' MTR-Speed
          mtr_geschw_koeff(1+ziel)=lfo_val#(1,lfo_ziel(3,ziel,lfo_setup(lfo_group))-1,lfo_group)
        ENDIF
        IF lfo_ziel(4,ziel,lfo_setup(lfo_group))>0
          ' Volume
          koor_signal(3,1+ziel)=MAX(0,MIN(127,(lfo_val#(1,lfo_ziel(4,ziel,lfo_setup(lfo_group))-1,lfo_group)+50)*127/100))
        ENDIF
        IF lfo_ziel(5,ziel,lfo_setup(lfo_group))>0
          ' Zoom
          koor_signal(4,1+ziel)=lfo_val#(1,lfo_ziel(5,ziel,lfo_setup(lfo_group))-1,lfo_group)*128/400
        ENDIF
        IF lfo_ziel(6,ziel,lfo_setup(lfo_group))>0
          ' Free-Walking, Vor-und-ZurÅck
          '      ALERT 1,"Vor- und zurÅck |in dieser Version|nicht eingebaut.",1,"Abbruch",wahl
          '      stop_3d_timer
          IF FALSE
            ADD rand_koor#(ziel),lfo_val#(1,lfo_ziel(6,ziel,lfo_setup(lfo_group))-1,lfo_group)
            ' evtl. X,Y,Z-Koordinaten festlegen?
            FOR koor=0 TO 2
              koor_signal(koor,ziel)=koor_p(koor,(puffer_laenge+ROUND(rand_koor#(ziel)) MOD puffer_laenge))
            NEXT koor
          ENDIF
        ENDIF
        FOR koor=0 TO 2
          ' Koordinaten Offset herstellen
          IF lfo_ziel(7+koor,ziel,lfo_setup(lfo_group))>0
            ADD koor_add_lfo(koor,ziel+1),lfo_val#(1,lfo_ziel(7+koor,ziel,lfo_setup(lfo_group))-1,lfo_group)
          ENDIF
        NEXT koor
      NEXT ziel
    ENDIF ! PrÅfung lfosetup<maxlfosetup
  NEXT lfo_group
  DEFTEXT ,,,13                                  ! wegen Textausgaben
RETURN
PROCEDURE do_lfo_setup(setup,lfo_group)
  lfo_setup(lfo_group)=setup
  reset_lfos
RETURN
PROCEDURE reset_lfos
  '  ARRAYFILL lfo_geschw_koeff(),100
  LOCAL lfo_group,flag!
  winkel_lfos
  FOR lfo_group=0 TO max_lfo_groups
    FOR lfo=0 TO maxlfos
      lfo_val#(0,lfo,lfo_group)=0
      lfo_val#(1,lfo,lfo_group)=0
      lfo_an!(lfo,lfo_group)=lfo_param(1,lfo,lfo_setup(lfo_group))>0
      lfo_status(lfo)
      pauso!(lfo,lfo_group)=FALSE
      pausu!(lfo,lfo_group)=FALSE
      pauso_cumul(lfo,lfo_group)=0
      pausu_cumul(lfo,lfo_group)=0
    NEXT lfo
    FOR ziel=0 TO 3
      panbreite(ziel)=100
      panpos(ziel)=0
      IF lfo_ziel(3,ziel,lfo_setup(lfo_group))>0
        ' nur zurÅcksetzen, wenn mtrspeed tatsÑchlich von LFO's gesteuert wird
        mtr_geschw_koeff(1+ziel*2)=100
        mtr_geschw_koeff(2+ziel*2)=100
      ENDIF
      IF lfo_ziel(4,ziel,lfo_setup(lfo_group))>0
        koor_signal(3,1+ziel*2)=127
        koor_signal(3,2+ziel*2)=127
      ENDIF
    NEXT ziel
    FOR ziel=0 TO maxsignals
      IF lfo_ziel(5,ziel,lfo_setup(lfo_group))>0
        '      koor_input(4,1+ziel*2)=127
        '      koor_input(4,2+ziel*2)=127
      ENDIF
      FOR koor=0 TO 4
        koor_add_lfo(koor,ziel)=0
      NEXT koor
    NEXT ziel
    calc_lfos
  NEXT lfo_group
  FOR signal=1 TO maxsignals
    rand_mode=0
    rand_koor#(signal)=0
    kneu!(3,signal)=TRUE
    koor_signal(4,signal)=32
    kneu!(4,signal)=TRUE
    flag!=FALSE         ! VOL-Steuerung Åber LFO?
    FOR lfo_group=0 TO max_lfo_group
      ' Flag setzen, wenn VOL Steuerung in erster oder zweiter LFO-Gruppe
      flag!=flag! OR lfo_ziel(4,signal-1,lfo_setup(lfo_group))>0
      IF NOT flag!
        ' STOP
      ENDIF
    NEXT lfo_group
    IF flag!=FALSE
      ' Keine VOl-Steuerung Åber LFO, also VOL-Reset
      koor_signal(3,signal)=127
    ENDIF
  NEXT signal
  x=0
  y=0
  z=0
RETURN
PROCEDURE winkel_lfos
  LOCAL lfo_group
  FOR lfo_group=0 TO max_lfo_groups
    FOR lfo=0 TO maxlfos
      '  IF relation_mtrlfo=0
      lfo_winkel#(lfo,lfo_group)=@stepwinkel(lfo_param(2,lfo,lfo_setup(lfo_group)))
      '  ELSE
      '    lfo_winkel#(lfo)=relation_mtrlfo*@stepwinkel(mtr_seku(1,mtr_setup))/100
      '  ENDIF
      '    ALERT 1,"LFO: "+STR$(lfo)+"| "+STR$(lfo_winkel#(lfo)),1," OK ",wahl
      lfo_pauso_winkel#(lfo,lfo_group)=@stepwinkel(lfo_param(6,lfo,lfo_setup(lfo_group)))
      lfo_pausu_winkel#(lfo,lfo_group)=@stepwinkel(lfo_param(7,lfo,lfo_setup(lfo_group)))
    NEXT lfo
  NEXT lfo_group
RETURN
FUNCTION stepwinkel(seku_u)
  ' Berechnet den Winkel pro Step, anhand der vorgegebenen Geschwindigkeit
  LOCAL winkel#
  IF seku_u<>0
    ' winkel#=360*quant/seku_u/4
    ' Speed halbier auf BK's Wunsch vom 9.6.94
    winkel#=360*quant/seku_u/8
  ELSE
    winkel#=0
  ENDIF
  RETURN winkel#
ENDFUNC
PROCEDURE lfo_status(lfo)
  GRAPHMODE 1
  LOCAL lfo_group
  lfo_group=0
  IF lfo>=0 AND lfo<=maxlfos
    IF window=5 OR window=6 AND on_screen!(window)
      IF lfo_an!(lfo,lfo_group) AND lfo_param(1,lfo,lfo_setup(lfo_group))>0
        TEXT ed_set_x0+lfo*8,ed_set_y0+188,"	"
      ELSE
        TEXT ed_set_x0+lfo*8,ed_set_y0+188,"-"
      ENDIF
    ENDIF
    GRAPHMODE 1
  ENDIF
RETURN
PROCEDURE temp_lfo_setup
  IF lfo_setup(lfo_group)>0
    ' Setup muû erst in 0-Setup kopiert werden, bevor es bearbeitet werden darf!
    copy_lfo_setup(lfo_setup(lfo_group),0)
    edit_lfosetup=lfo_setup(lfo_group)
    lfo_setup(lfo_group)=0
  ENDIF
RETURN
PROCEDURE copy_lfo_setup(source,dest)
  LOCAL x,lfo,ziel
  FOR lfo=0 TO maxlfos
    FOR x=0 TO 9
      lfo_param(x,lfo,dest)=lfo_param(x,lfo,source)
    NEXT x
  NEXT lfo
  FOR ziel=0 TO maxsignals-1
    FOR x=0 TO 10
      lfo_ziel(x,ziel,dest)=lfo_ziel(x,ziel,source)
    NEXT x
  NEXT ziel
RETURN
'
PROCEDURE grafik_mode
  stop_3d_timer
  rscaddress(dgrafikm,0)
  deselect(dgmsingl,dgmaus)
  SELECT grafikmode
  CASE single
    preselect(dgmsingl)
  CASE pan
    preselect(dgm12pan)
  CASE quadro
    preselect(dgmquad)
  CASE grafik_aus
    preselect(dgmaus)
  ENDSELECT
  dialogbox(0,2)
  SELECT exitbutton%
  CASE dgmsingl
    grafikmode=single
  CASE dgm12pan
    grafikmode=pan
  CASE dgmquad
    grafikmode=quadro
  CASE dgmaus
    grafikmode=grafik_aus
  ENDSELECT
RETURN
PROCEDURE record_parameter
  stop_3d_timer
  rscaddress(drecordp,0)
  fill_record_parameter
  dialogbox(0,2)
  SELECT exitbutton%
  CASE drecok
  ENDSELECT
  updatemenu
  fill_window(5,FALSE)
  fill_window(6,FALSE)
  signal=1
RETURN
PROCEDURE fill_record_parameter
  rscaddress(drecordp,0)
  FOR signal=1 TO maxsignals
    ' RECORD an/aus
    select(drec(7,signal),record!(7,signal))
    FOR koor=0 TO 6
      select(drec(koor,signal),record!(koor,signal) AND record!(7,signal))
      '     hide(drec(koor,signal),NOT record!(7,signal))
      enable_button(drec(koor,signal),record!(7,signal))
    NEXT koor
  NEXT signal
RETURN
PROCEDURE te_record_parameter
  '  PRINT CHR$(7);
  FOR koor=0 TO 7
    IF exitbutton%=drec(koor,0)
      FOR signal=1 TO maxsignals
        record!(koor,signal)=NOT record!(koor,signal)
        select(drec(koor,signal),record!(koor,signal) AND record!(7,signal))
        obj_draw(drec(koor,signal),1)
        IF koor=7
          te_rec_anaus(signal)
        ENDIF
      NEXT signal
    ENDIF
  NEXT koor
  FOR signal=1 TO maxsignals
    IF exitbutton%=drec(7,signal)
      record!(7,signal)=@selected(drec(7,signal))
      te_rec_anaus(signal)
    ELSE IF record!(7,signal)
      ' Nur wenn Record an ist
      IF exitbutton%=drec(6,signal)
        te_rec_overdub(signal)
      ELSE
        FOR koor=0 TO 5
          ' Alle Koordinaten und Cycle-Rec bedienen
          record!(koor,signal)=@selected(drec(koor,signal))
        NEXT koor
      ENDIF
    ENDIF
  NEXT signal
RETURN
PROCEDURE te_rec_anaus(signal)
  ' Rec an/aus
  FOR koor=0 TO 6
    select(drec(koor,signal),record!(koor,signal) AND record!(7,signal))
    '        hide(drec(koor,signal),NOT record!(7,signal))
    enable_button(drec(koor,signal),record!(7,signal))
    obj_draw(drec(koor,signal),1)
  NEXT koor
RETURN
PROCEDURE te_rec_overdub(signal)
  ' Overdub
  record!(6,signal)=@selected(drec(6,signal))
  FOR koor=0 TO 4
    ' Alle aufnehmbaren Koordinaten umschalten
    record!(koor,signal)=NOT record!(koor,signal)
    select(drec(koor,signal),record!(koor,signal) AND record!(7,signal))
    obj_draw(drec(koor,signal),1)
  NEXT koor
RETURN
'
' * * *   Event-öbersichts-Fenster  * * *
'
PROCEDURE event_uebersicht
  fill_window(3,TRUE)
RETURN
FUNCTION uebers_yoffset(koor,signal)
  LOCAL y
  SELECT uebers_mode
  CASE 0
    y=uebers_yoffset+((signal-1)*6+koor+1)*uebers_ydist
  CASE 1
    y=uebers_yoffset+(signal+koor*(maxsignals+1))*uebers_ydist
  ENDSELECT
  RETURN y
ENDFUNC
PROCEDURE uebers_init
  CLIP xwork(window),ywork(window),wwork(window),hwork(window)
  GRAPHMODE 1
  DEFLINE 1,0,0
  uebers_xoffset=40
  uebers_yoffset=20
  uebers_ydist=uebers_amplitude+2
  count%=0
  reset_pointers
  DEFTEXT ,,,6
  FOR signal=1 TO maxsignals
    FOR koor=0 TO 4
      y=@uebers_yoffset(koor,signal)
      LINE uebers_xoffset,y,max3devents%/2,y
      ' Text x,y,z
      text$=STR$(signal,2)+" "
      SELECT koor
      CASE 0 TO 2
        text$=text$+CHR$(120+koor)
      CASE 3
        text$=text$+"v"
      CASE 4
        text$=text$+"Z"
      ENDSELECT
      TEXT 4,y+4,text$
    NEXT koor
  NEXT signal
RETURN
PROCEDURE uebers_draw(von,bis)
  ' Peillinie
  exit!=FALSE
  REPEAT
    INC count%
    x=uebers_xoffset+count%*uebers_stepbreite
    playing!=FALSE
    FOR signal=1 TO maxsignals
      IF foll%(pointer%(signal))<>header(signal)
        ' Normal weiter im Text
        playing!=TRUE
        pointer%(signal)=foll%(pointer%(signal))
        INC event_number(signal)
      ELSE
        ' Beim letzten Event bleiben
        IF cycle!
          playing!=TRUE
          pointer%(signal)=foll%(header(signal))
          event_number(signal)=1
        ENDIF
      ENDIF
    NEXT signal
    IF x>hor% AND x<hor%+wwork(window) AND playing!
      IF (count%*uebers_stepbreite) MOD 50<uebers_stepbreite OR count%=1
        y=uebers_yoffset/2
        LINE x,y,x,uebers_ydist*maxsignals*6
        TEXT x,y+4,STR$(count%)
        nzeit(count%*qkoeff/2)
        TEXT x,y+12,STR$(mm,2)+":"+STR$(ss,2)
      ENDIF
      IF playing!
        FOR signal=1 TO maxsignals
          IF foll%(pointer%(signal))<>header(signal)
            ' Normaler Ablauf
            FOR koor=0 TO 4
              y=@uebers_yoffset(koor,signal)
              SELECT koor
              CASE 0,1,2,4
                foll_y=y-koor(koor,foll%(pointer%(signal)))*uebers_amplitude/fbreite
                y=y-koor(koor,pointer%(signal))*uebers_amplitude/fbreite
              CASE 3
                foll_y=y-koor(koor,foll%(pointer%(signal)))*uebers_amplitude/fbreite/2
                y=y-koor(koor,pointer%(signal))*uebers_amplitude/fbreite/2
              ENDSELECT
              LINE x,y,x+uebers_stepbreite,foll_y
            NEXT koor
          ELSE IF cycle!
            ' Cycle-Anfang Ablauf
            FOR koor=0 TO 4
              y=@uebers_yoffset(koor,signal)
              SELECT koor
              CASE 0,1,2,4
                foll_y=y-koor(koor,foll%(header(signal)))*uebers_amplitude/fbreite
                y=y-koor(koor,pointer%(signal))*uebers_amplitude/fbreite
              CASE 3
                foll_y=y-koor(koor,foll%(header(signal)))*uebers_amplitude/fbreite/2
                y=y-koor(koor,pointer%(signal))*uebers_amplitude/fbreite/2
              ENDSELECT
              LINE x,y,x+uebers_stepbreite,foll_y
            NEXT koor
          ENDIF
        NEXT signal
        KEYTEST a
        exit!=a=27
      ELSE
        ' Wenn alle KanÑle fertig sind
        exit!=TRUE
      ENDIF
    ELSE IF x>=hor%+wwork(window)
      exit!=TRUE
    ENDIF
  UNTIL exit!
  exit!=FALSE
RETURN
PROCEDURE event_uebers_ampl
  ' Dialogbox fÅr Einstellung der Amplitude der Event-öbersicht
  ' EVERY STOP
  dpname$="Amplitude Event-öbersicht"
  value=uebers_amplitude
  maxval=1000
  minval=1
  valslider=uebers_amplitude
  dparam
  IF ok!
    uebers_amplitude=value
  ENDIF
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
  fill_window(3,FALSE)
RETURN
PROCEDURE event_uebers_breite
  ' Dialogbox fÅr Einstellung der Breite der Event-öbersicht
  ' EVERY STOP
  dpname$="Breite Event-öbersicht"
  value=uebers_stepbreite
  maxval=1000
  minval=1
  valslider=uebers_stepbreite
  dparam
  IF ok!
    uebers_stepbreite=value
  ENDIF
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
  fill_window(3,FALSE)
RETURN
'
' * * *   Kleine Ein- und Ausgaben   * * *
'
PROCEDURE ende
  IF mtr_aenderung!
    ALERT 3,"Sollen geÑnderte|MTR-Setups|gespeichert werden?  ",2,"Nein| Ja ",x
    IF x=2
      speichern_multirot
    ENDIF
  ENDIF
  IF spi_aenderung!
    ALERT 3,"Sollen geÑnderte|Spiegelungs-Setups|gespeichert werden?  ",2,"Nein| Ja ",x
    IF x=2
      speichern_spiegel
    ENDIF
  ENDIF
  IF lfo_aenderung!
    ALERT 3,"Sollen geÑnderte|LFO-Setups|gespeichert werden?  ",2,"Nein| Ja ",x
    IF x=2
      speichern_lfos
    ENDIF
  ENDIF
  IF inp_aenderung!
    ALERT 3,"Sollen geÑnderte|Input-Change-Setups|gespeichert werden?  ",2,"Nein| Ja ",x
    IF x=2
      speichern_inputsets
    ENDIF
  ENDIF
  IF gen_aenderung!
    ALERT 3,"Sollen geÑnderte|General-Setups|gespeichert werden?  ",2,"Nein| Ja ",x
    IF x=2
      speichern_general_setups
    ENDIF
  ENDIF
  ALERT 3,"| Wollen sie wirklich aufhîren?  ",2," Nein |  Ja  ",x
  IF x=2
    exit
  ENDIF
RETURN
PROCEDURE maus_zoom
  dpname$="Maus-Zoom"
  value=maus_zoom
  valslider=maus_zoom
  minval=1
  maxval=1000
  dparam
  IF ok!
    maus_zoom=MAX(1,value)
  ENDIF
RETURN
PROCEDURE relation_mtrlfo
  ' Dialogbox fÅr Einstellung der AbhÑngigkeit
  ' der LFO-Geschwindigkeit von den MTR-Speeds
  ' EVERY STOP
  general_setup_dialog
  IF FALSE
    dpname$="Relation LFO-Speed <- MTR"
    value=relation_mtrlfo                      ! Letzter Zeitbedarf +4
    maxval=1000
    minval=0
    valslider=relation_mtrlfo
    dparam
    IF ok!
      relation_mtrlfo=value
    ENDIF
  ENDIF
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
RETURN
PROCEDURE quant
  ' Dialogbox fÅr Quantisierungs-Einstellung
  ' EVERY STOP
  dpname$="Quantisierung"
  value=q                      ! Letzter Zeitbedarf
  maxval=150
  minval=4
  valslider=quant
  dparam
  IF ok!
    setquant(value)
    disp_quant
  ENDIF
  IF mode<>stop
    ' EVERY edtimer GOSUB 3d_timer
  ENDIF
RETURN
PROCEDURE sperren(mode)
  SELECT mode
  CASE 0
    ' Aussensperre
    dpname$="Aussensperre"
    value=sperre_aussen
    valslider=sperre_aussen
  ENDSELECT
  minval=0
  maxval=1+SQR(2*fbreit2^2)
  dparam
  IF ok!
    SELECT mode
    CASE 0
      sperre_aussen=MAX(0,MIN(SQR(2*fbreit2^2),value))
      sperre!=TRUE
      sperre(FALSE,TRUE)
    ENDSELECT
  ENDIF
RETURN
PROCEDURE setquant(value)
  ' Proc setzt notwendige parameter auf neuen Quant-Wert
  quant=4*INT(0.75+value/4)
  qkoeff=quant/4
  IF qkoeff<1
    qkoeff=1
  ENDIF
  FOR signal=0 TO maxsignals
    mtr_winkel(signal)
  NEXT signal
  winkel_lfos
RETURN
PROCEDURE ueberblend_parameter
  dpname$="öberblenden"
  value=ueberblend
  valslider=ueberblend
  maxval=50
  minval=0
  valslider=value
  dparam
  IF ok!
    ueberblend=value
  ENDIF
RETURN
PROCEDURE fadenkreuz_parameter
  dpname$="Fadenkreuz-Zuordnung"
  value=fdk_signal
  valslider=fdk_signal
  maxval=maxsignals
  minval=0
  valslider=value
  dparam
  IF ok!
    fdk_signal=value
  ENDIF
RETURN
PROCEDURE gprint(x,y,text$)
  MUL x,8
  MUL y,16
  TEXT x,y,text$
RETURN
PROCEDURE dparam
  rscaddress(dparam,0)
  set_text(dpareing,dpname$)
  set_text(dpwert,STR$(value))
  set_text(dpslide,STR$(valslider))
  set_text(dpminval,STR$(minval))
  set_text(dpmaxval,STR$(maxval))
  position%=@set_position
  customslider(dpslbox,dpslide,FALSE,150,position%)
  dialogbox(dpwert,2)
  SELECT exitbutton%
  CASE dpok
    editedtext(dpwert,TRUE)
    value=MIN(&HFFFF,VAL(edtext$)) ! WORD-Maximum
    value=VAL(edtext$)
    ok!=TRUE
  CASE dpabbr
    ok!=FALSE
  ENDSELECT
  updatemenu
  fill_window(5,FALSE)
  fill_window(6,FALSE)
RETURN
FUNCTION dzahl(wert#)
  te!=FALSE
  tree_alt=tree
  rscaddress(dzahl,0)
  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  set_text0(dzzahl,STR$(wert#))
  dialogbox(dzzahl,1)
  te!=TRUE
  wert#=VAL(@editedtxt$(dzzahl))
  rscaddress(tree_alt,0)
  ' obj_draw(0,max_depth)
  RETURN wert#
ENDFUNC
PROCEDURE te_dparam
  IF shiftstate% AND 1 OR shiftstate% AND 2
    vinc=10
  ELSE
    vinc=1
  ENDIF
  SELECT exitbutton%
  CASE dpslide
    graf_slidebox(dpslbox,dpslide,FALSE)
    value=@get_value
    position%=@set_position
    set_text(dpwert,STR$(value))
    set_text(dpslide,STR$(value))
    customslider(dpslbox,dpslide,FALSE,-1,position%)
    obj_draw(dpslbox,1)
  CASE dpinc
    value=MIN(maxval,value+vinc)
    set_text(dpwert,STR$(value))
    set_text(dpslide,STR$(value))
    obj_draw(dpwert,1)
    position%=@set_position
    customslider(dpslbox,dpslide,FALSE,-1,position%)
    obj_draw(dpslbox,1)
  CASE dpdec
    value=MAX(minval,value-vinc)
    set_text(dpwert,STR$(value))
    set_text(dpslide,STR$(value))
    obj_draw(dpwert,1)
    position%=@set_position
    customslider(dpslbox,dpslide,FALSE,-1,position%)
    obj_draw(dpslbox,1)
  CASE dpwert
    editedtext(dpwert,TRUE)
    value=VAL(edtext$)
    position%=@set_position
    set_text(dpslide,STR$(value))
    customslider(dpslbox,dpslide,FALSE,-1,position%)
    obj_draw(dpslbox,1)
  ENDSELECT
RETURN
PROCEDURE dtext
  rscaddress(dtext,0)
  set_text(dtname,tname$)
  set_text(dtext,text$)
  dialogbox(dtext,1)
  SELECT exitbutton%
  CASE dtok
    editedtext(dtext,FALSE)
    text$=edtext$
    ok!=TRUE
  CASE dtabbr
    ok!=FALSE
  ENDSELECT
RETURN
PROCEDURE copyright
  ALERT 1,"Realtimer "+version$+" |Freie Events: "+STR$(prev%(header(0)))+"|Freier Speicher: "+STR$(FRE(0))+" |Copyright Cybernetic Arts",1," OK ",a
RETURN
'
' * * *   Umrechnungen   * * *
'
PROCEDURE get_array_adr
  adr_setup=*setup()                            ! Adresse des Arrays
  adr_setup2=*setup2()                          ! Adresse des Arrays
  adr_setup_string=*setup$()                    ! Adresse des Arrays
  adr_setup2_string=*setup2$()                  ! Adresse des Arrays
RETURN
PROCEDURE rufton
  dauer=3
  oktav=3
  SOUND 2,15,1,oktav,dauer
  SOUND 2,0,0,0,dauer
  SOUND 2,15,5,oktav,dauer
  SOUND 2,0,0,0,dauer
  SOUND 2,15,8,oktav,dauer
  SOUND 2,0,0,0,dauer
  SOUND 2,15,1,oktav+1,dauer*3
  SOUND 2,0,0,0,dauer
  SOUND 2,15,8,oktav,dauer
  SOUND 2,0,0,0,dauer
  SOUND 2,15,1,oktav+1,dauer*3
  SOUND 2,0,0,0,dauer
RETURN
PROCEDURE rufton2
  dauer=3
  oktav=4
  SOUND 2,15,5,oktav,dauer
  SOUND 2,0,0,0,dauer
  SOUND 2,15,1,oktav,dauer
  SOUND 2,0,0,0,dauer
  SOUND 2,15,5,oktav,dauer
  SOUND 2,0,0,0,dauer
  IF FALSE
    SOUND 2,15,8,oktav,dauer
    SOUND 2,0,0,0,dauer
    SOUND 2,15,1,oktav+1,dauer*3
    SOUND 2,0,0,0,dauer
    SOUND 2,15,8,oktav,dauer
    SOUND 2,0,0,0,dauer
    SOUND 2,15,1,oktav+1,dauer*3
    SOUND 2,0,0,0,dauer
  ENDIF
RETURN
PROCEDURE rufton3
  dauer=3
  oktav=4
  SOUND 2,15,1,oktav,dauer
  SOUND 2,0,0,0,dauer
  SOUND 2,15,5,oktav,dauer
  SOUND 2,0,0,0,dauer
  IF FALSE
    SOUND 2,15,5,oktav,dauer
    SOUND 2,0,0,0,dauer
    SOUND 2,15,8,oktav,dauer
    SOUND 2,0,0,0,dauer
    SOUND 2,15,1,oktav+1,dauer*3
    SOUND 2,0,0,0,dauer
    SOUND 2,15,8,oktav,dauer
    SOUND 2,0,0,0,dauer
    SOUND 2,15,1,oktav+1,dauer*3
    SOUND 2,0,0,0,dauer
  ENDIF
RETURN
PROCEDURE altpart_3d
  IF FALSE
    DEFMOUSE 2
    count%=0
    '  koor(0,count%)=0
    '  koor(1,count%)=0
    '  koor(2,count%)=0
    '  koor(3,count%)=126
    ' koor(4,count%)=31
    ' INC count%
    FOR event=1 TO laenge%
      WHILE @zeit(event)=akt_zeit AND event<laenge%
        signal=@input(event)
        value(signal,@output(event))=wert(event,velocity)+1
        zeichnen(signal)=TRUE
        INC event
      WEND
      IF event<laenge%
        FOR signal=1 TO 1
          IF zeichnen(signal)
            akt_zeit(signal)=akt_zeit
            koor(0,count%)=@akx(1)/6
            koor(1,count%)=@aky(1)/6
            koor(2,count%)=@akz(1)/6
            koor(3,count%)=127
            koor(4,count%)=32
            INC count%
            '          grafik_ausgabe
            zeichnen(signal)=FALSE
          ENDIF
        NEXT signal
      ENDIF
      signal=@input(event)
      value(signal,@output(event))=wert(event,velocity)
      zeichnen(signal)=TRUE
      akt_zeit=@zeit(event)
    NEXT event
    FOR koor=0 TO 4
      koor(koor,count%)=koor(koor,0)
    NEXT koor
    INC count%
    koor(3,0)=126
    koor(0,MIN(max3devents%,count%))=fbreite+1
    count%=0
    multimode=mirror
    ARRAYFILL play_inp!(),FALSE
    play_inp!(1)=TRUE
    DEFMOUSE 0
  ENDIF
RETURN
'
' * * *   Disk I/O   * * *
'
PROCEDURE load_save_merge_box(mode)
  ' 1= Laden, 2=Merge, 3=Save
  rscaddress(dsaveloa,0)
  ' Movable
  '  OB_FLAGS(treeaddr%,0)=OB_FLAGS(treeaddr%,0) OR &H400
  SELECT mode
  CASE 1
    set_text(dlstitel,"Laden ...")
  CASE 2
    set_text(dlstitel,"Merge ...")
  CASE 3
    set_text(dlstitel,"Speichern ...")
  CASE 4
    set_text(dlstitel,"Exporte ...")
  ENDSELECT
  dialogbox(0,1)
  SELECT exitbutton%
  CASE dls3dneu
    ' 3D neu
    SELECT mode
    CASE 1
      lade_xyz(0)
    CASE 2
      lade_xyz(1)
    CASE 3
      speichern_xyz
    ENDSELECT
  CASE dls3dalt
    ' 3DS altes Format
    SELECT mode
    CASE 1
      lade_xyz(0)
    CASE 2
      lade_xyz(1)
    CASE 3
      speichern_xyz_alt
    ENDSELECT
  CASE dlsmulti
    ' Multirotation Setups
    SELECT mode
    CASE 1
      laden_multirot(TRUE)
    CASE 3
      speichern_multirot
    CASE 4
      export_mtr
    ENDSELECT
  CASE dlshand
    ' Spiegel-Setups
    SELECT mode
    CASE 1
      laden_spiegel(TRUE)
    CASE 3
      speichern_spiegel
    CASE 4
      export_spi
    ENDSELECT
  CASE dlslfose
    ' LFO Setups
    SELECT mode
    CASE 1
      laden_lfos(TRUE)
    CASE 3
      speichern_lfos
    CASE 4
      export_lfo
    ENDSELECT
  CASE dlsinpch
    ' Input-Change-Setups
    SELECT mode
    CASE 1
      laden_inputsets(TRUE)
    CASE 3
      speichern_inputsets
    CASE 4
      export_inp
    ENDSELECT
  CASE dlsgense
    ' General-Setups
    SELECT mode
    CASE 1
      laden_general_setups(TRUE)
    CASE 3
      speichern_general_setups
    CASE 4
      export_gen
    ENDSELECT
  CASE dlsallse
    ' Alle Setups
    SELECT mode
    CASE 1
      laden_alle_setups(FALSE)
    CASE 3
      speichern_alle_setups
    ENDSELECT
  DEFAULT
    ' Abbruch
  ENDSELECT
RETURN
PROCEDURE speichern_presets
  LOCAL x,y
  IF FALSE
    sdname$=name$
    FILESELECT #"Presets speichern in",presdir$,@dname$(presdname$),presdname$
    IF presdname$>""
      IF NOT RIGHT$(presdname$,4)=".RTS"
        presdname$=@dname$(presdname$)+".RTS"
      ENDIF
      prespfad$=@path$(presdname$)
      '    CHDIR spfad$
      DEFMOUSE 2
      OPEN "o",#1,presdname$
      preset_datei_version$="2.16"
      PRINT #1,preset_datei_version$
      BPUT #1,VARPTR(setup(0,0)),DIM?(setup())*2
      BPUT #1,VARPTR(setup2(0,0)),DIM?(setup2())*2
      BPUT #1,VARPTR(fkeyn(0)),DIM?(fkeyn())*2
      '    STORE #1,setup$()
      '    STORE #1,setup2$()
      CLOSE #1
      DEFMOUSE 0
      '  r=GEMDOS(62,1)
      '  IF r=37
      '    ALERT 1,"Es ist ein Fehler aufgetreten!|"+STR$(r),1,"OK",a
      '  ENDIF
      preset_aenderung!=FALSE
    ENDIF
  ENDIF
RETURN
PROCEDURE speichern_lfos
  FILESELECT #"LFO-Parameter speichern in",lfodir$,@dnames$(lfodname$),lfodname$
  IF lfodname$>""
    IF NOT @ext$(lfodname$)=".L1O"
      lfodname$=@dnames$(lfodname$)+".L1O"
    ENDIF
    lfopfad$=@path$(lfodname$)
    DEFMOUSE 2
    IF EXIST(lfodname$)
      IF replace!
        KILL lfodname$
      ELSE
        lfodnamebak$=LEFT$(lfodname$,LEN(lfodname$)-1)+"B"
        IF EXIST(lfodnamebak$)
          KILL lfodnamebak$
        ENDIF
        IF lfodname$<>lfodnamebak$
          ' wenn jemand extra ".LFB" abspeichert keine Umbenennung
          RENAME lfodname$ AS lfodnamebak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,lfodname$
    lfo_datei_version$="1.05"
    PRINT #1,lfo_datei_version$
    BPUT #1,VARPTR(lfo_param(0,0,0)),DIM?(lfo_param())*2
    CLOSE #1
    OPEN "o",#1,@dnames$(lfodname$)+".L2O"
    BPUT #1,VARPTR(lfo_ziel(0,0,0)),DIM?(lfo_ziel())*2
    CLOSE #1
    DEFMOUSE 0
    '  r=GEMDOS(62,1)
    '  IF r=37
    '    ALERT 1,"Es ist ein Fehler aufgetreten!|"+STR$(r),1,"OK",a
    '  ENDIF
    lfo_aenderung!=FALSE
  ENDIF
RETURN
PROCEDURE speichern_inputsets
  FILESELECT #"Input-Sets speichern in",inpdir$,@dname$(inpdname$),inpdname$
  IF inpdname$>""
    IF NOT RIGHT$(inpdname$,4)=".INP"
      inpdname$=@dname$(inpdname$)+".INP"
    ENDIF
    inppfad$=@path$(inpdname$)
    DEFMOUSE 2
    IF EXIST(inpdname$)
      IF replace!
        KILL inpdname$
      ELSE
        inpdnamebak$=LEFT$(inpdname$,LEN(inpdname$)-1)+"B"
        IF EXIST(inpdnamebak$)
          KILL inpdnamebak$
        ENDIF
        IF inpdname$<>inpdnamebak$
          ' wenn jemand extra ".INB" abspeichert keine Umbenennung
          RENAME inpdname$ AS inpdnamebak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,inpdname$
    inp_datei_version$="1.00"
    PRINT #1,inp_datei_version$
    BPUT #1,VARPTR(input_setup|(0,0)),DIM?(input_setup|())
    CLOSE #1
    DEFMOUSE 0
    '  r=GEMDOS(62,1)
    '  IF r=37
    '    ALERT 1,"Es ist ein Fehler aufgetreten!|"+STR$(r),1,"OK",a
    '  ENDIF
    inp_aenderung!=FALSE
  ENDIF
RETURN
PROCEDURE speichern_multirot
  FILESELECT #"Multirotationen speichern in",mtrdir$,@dname$(mtrdname$),mtrdname$
  IF mtrdname$>""
    IF NOT RIGHT$(mtrdname$,4)=".MTR"
      mtrdname$=@dname$(mtrdname$)+".MTR"
    ENDIF
    mtrpfad$=@path$(mtrdname$)
    DEFMOUSE 2
    IF EXIST(mtrdname$)
      IF replace!
        KILL mtrdname$
      ELSE
        mtrdnamebak$=LEFT$(mtrdname$,LEN(mtrdname$)-1)+"B"
        IF EXIST(mtrdnamebak$)
          KILL mtrdnamebak$
        ENDIF
        IF mtrdname$<>mtrdnamebak$
          ' wenn jemand extra ".MTB" abspeichert keine Umbenennung
          RENAME mtrdname$ AS mtrdnamebak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,mtrdname$
    mtr_datei_version$="1.01"
    PRINT #1,mtr_datei_version$
    BPUT #1,VARPTR(mtr_phase(0,0)),DIM?(mtr_phase())*2
    BPUT #1,VARPTR(mtr_seku(0,0)),DIM?(mtr_seku())*2
    BPUT #1,VARPTR(mtr_richtung(0,0)),DIM?(mtr_richtung())*2
    BPUT #1,VARPTR(mtr_modus(0,0)),DIM?(mtr_modus())*2
    BPUT #1,VARPTR(mtr_wausschnitt%(0,0)),DIM?(mtr_wausschnitt%())*4
    BPUT #1,VARPTR(mtr_dreh(0,0)),DIM?(mtr_dreh())*2
    BPUT #1,VARPTR(mtr_form(0)),DIM?(mtr_form())*2
    CLOSE #1
    DEFMOUSE 0
    '  r=GEMDOS(62,1)
    '  IF r=37
    '    ALERT 1,"Es ist ein Fehler aufgetreten!|"+STR$(r),1,"OK",a
    '  ENDIF
    mtr_aenderung!=FALSE
  ENDIF
RETURN
PROCEDURE speichern_spiegel
  FILESELECT #"Spiegel-Sets speichern in",spidir$,@dname$(spidname$),spidname$
  IF spidname$>""
    IF NOT RIGHT$(spidname$,4)=".SPI"
      spidname$=@dname$(spidname$)+".SPI"
    ENDIF
    spipfad$=@path$(spidname$)
    DEFMOUSE 2
    IF EXIST(spidname$)
      IF replace!
        KILL spidname$
      ELSE
        spidnamebak$=LEFT$(spidname$,LEN(spidname$)-1)+"B"
        IF EXIST(spidnamebak$)
          KILL spidnamebak$
        ENDIF
        IF spidname$<>spidnamebak$
          ' wenn jemand extra ".SPB" abspeichert keine Umbenennung
          RENAME spidname$ AS spidnamebak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,spidname$
    spi_datei_version$="1.01"
    PRINT #1,spi_datei_version$
    BPUT #1,VARPTR(spiegel_setup(0,0)),DIM?(spiegel_setup())*2
    BPUT #1,VARPTR(dreh_setup(0,0,0)),DIM?(dreh_setup())*2
    BPUT #1,VARPTR(offset_setup(0,0,0)),DIM?(offset_setup())*2
    CLOSE #1
    DEFMOUSE 0
    '  r=GEMDOS(62,1)
    '  IF r=37
    '    ALERT 1,"Es ist ein Fehler aufgetreten!|"+STR$(r),1,"OK",a
    '  ENDIF
    spi_aenderung!=FALSE
  ENDIF
RETURN
PROCEDURE speichern_general_setups
  FILESELECT #"General-Sets speichern in",gendir$,@dname$(gendname$),gendname$
  IF gendname$>""
    IF NOT RIGHT$(gendname$,4)=".GEN"
      gendname$=@dname$(gendname$)+".GEN"
    ENDIF
    genpfad$=@path$(gendname$)
    DEFMOUSE 2
    IF EXIST(gendname$)
      IF replace!
        KILL gendname$
      ELSE
        gendnamebak$=LEFT$(gendname$,LEN(gendname$)-1)+"B"
        IF EXIST(gendnamebak$)
          KILL gendnamebak$
        ENDIF
        IF gendname$<>gendnamebak$
          ' wenn jemand extra ".GEB" abspeichert keine Umbenennung
          RENAME gendname$ AS gendnamebak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,gendname$
    gen_datei_version$="1.03"
    PRINT #1,gen_datei_version$
    BPUT #1,VARPTR(general_setup(0,0)),DIM?(general_setup())*2
    CLOSE #1
    DEFMOUSE 0
    '  r=GEMDOS(62,1)
    '  IF r=37
    '    ALERT 1,"Es ist ein Fehler aufgetreten!|"+STR$(r),1,"OK",a
    '  ENDIF
    gen_aenderung!=FALSE
  ENDIF
RETURN
PROCEDURE speichern_xyz
  LOCAL x,y
  sdname$=name$
  FILESELECT #"3D-Part speichern in",xyzdir$,@dname$(xyzdname$),xyzdname$
  IF xyzdname$>""
    IF NOT RIGHT$(xyzdname$,4)=".3DS"
      '    sdname$=LEFT$(spfad$,RINSTR(spfad$,"\"))+sdname$+".3DS"
      xyzdname$=@dname$(xyzdname$)+".3DS"
    ENDIF
    xyzpfad$=@path$(xyzdname$)
    '    CHDIR spfad$
    DEFMOUSE 2
    xyz_version$="1.02"
    OPEN "o",#1,xyzdname$
    PRINT #1,xyz_version$
    PRINT #1,quant*3
    FOR signal=1 TO maxsignals
      IF play_inp!(signal)
        ~@get_last_node(signal)
        pointer%(signal)=foll%(header(signal))
        PRINT #1,midich(signal)
        PRINT #1,laenge%
        FOR x=1 TO laenge%
          FOR koor=0 TO 4
            PRINT #1,koor(koor,pointer%(signal))
          NEXT koor
          pointer%(signal)=foll%(pointer%(signal))
        NEXT x
      ENDIF
    NEXT signal
    CLOSE #1
    DEFMOUSE 0
    '  r=GEMDOS(62,1)
    '  IF r=37
    '    ALERT 1,"Es ist ein Fehler aufgetreten!|"+STR$(r),1,"OK",a
    '  ENDIF
  ENDIF
RETURN
PROCEDURE speichern_xyz_alt
  LOCAL x,y
  sdname$=name$
  FILESELECT #"3D-Part speichern in",xyzdir$,@dname$(xyzdname$),xyzdname$
  IF xyzdname$>""
    IF NOT RIGHT$(xyzdname$,4)=".3DS"
      '    sdname$=LEFT$(spfad$,RINSTR(spfad$,"\"))+sdname$+".3DS"
      xyzdname$=@dname$(xyzdname$)+".3DS"
    ENDIF
    xyzpfad$=@path$(xyzdname$)
    '    CHDIR spfad$
    DEFMOUSE 2
    xyz_version$="1.01"
    OPEN "o",#1,xyzdname$
    PRINT #1,xyz_version$
    FOR signal=1 TO maxsignals
      ~@get_last_node(signal)
      pointer%(signal)=foll%(header(signal))
      PRINT #1,midich(signal)
      PRINT #1,laenge%
      FOR x=1 TO laenge%
        FOR koor=0 TO 4
          PRINT #1,koor(koor,pointer%(signal))
        NEXT koor
        pointer%(signal)=foll%(pointer%(signal))
      NEXT x
    NEXT signal
    CLOSE #1
    DEFMOUSE 0
    '  r=GEMDOS(62,1)
    '  IF r=37
    '    ALERT 1,"Es ist ein Fehler aufgetreten!|"+STR$(r),1,"OK",a
    '  ENDIF
  ENDIF
RETURN
PROCEDURE speichern_preset_exp
  LOCAL setupnr
  OPEN "o",#1,"RTS_TEXT.EXP"
  FOR setupnr=1 TO maxsetups
    IF setup$(setupnr)>" "
      PRINT #1,setup$(setupnr)
      PRINT #1,"RTS"+STR$(setupnr,4)
    ENDIF
  NEXT setupnr
  CLOSE #1
RETURN
PROCEDURE speichern_alle_setups
  speichern_lfos
  speichern_inputsets
  speichern_multirot
  speichern_spiegel
  speichern_general_setups
RETURN
PROCEDURE lade_alt(mode)
  abort!=TRUE
  IF abort!
    REM mode 0 = laden
    REM mode 1 = merge
    SELECT mode
    CASE 0
      laenge%=0
    CASE 1
      ~@get_last_node(0)
    ENDSELECT
    lpfad$=@path$(ldname$)+"*.PRT"
    ldname$=RIGHT$(ldname$,LEN(ldname$)-RINSTR(ldname$,"\"))
    FILESELECT #"Daten laden",lpfad$,ldname$,ldname$
    '  ~FSEL_INPUT(lpfad$,ldname$,button)
    IF ldname$>""
      IF EXIST(ldname$)
        lpfad$=@path$(ldname$)+"*.PRT"
        DEFMOUSE 2
        '      CHDIR lpfad$
        IF UPPER$(@ext$(ldname$))=".PRT"
          OPEN "I",#1,ldname$
          dlaenge%=LOF(#1)
          IF mode=0
            laenge%=0
            zaehler=0
          ELSE
            laenge_alt%=laenge%
          ENDIF
          IF NOT dlaenge%<kopflaenge
            FOR x=1 TO kopflaenge
              kopf(x)=INP(#1)
            NEXT x
            REPEAT
              wert=INP(#1)
              IF wert<>255
                wert(laenge%+1,1)=wert
                FOR counter=2 TO 12
                  wert=INP(#1)
                  EXIT IF wert=255
                  wert(laenge%+1,counter)=wert
                NEXT counter
                mwert(laenge%+1,0)=wert(laenge%+1,key)
              ENDIF
              EXIT IF wert=255
              INC laenge%
            UNTIL wert=255
            ente(1)=0
            ente(2)=0
            ente(3)=wert
            ente(4)=INP(#1)
            ente(5)=INP(#1)
            nullbytes=0
            WHILE NOT EOF(#1)
              ~INP(#1)
              INC nullbytes
            WEND
            CLOSE #1
          ENDIF
          DEFMOUSE 0
          IF mode=1
            '      sort
            nullbytes=(16*laenge%/12)-laenge%-5
          ENDIF
          partname$=""
          FOR x=65 TO 74
            EXIT IF kopf(x)=0
            partname$=partname$+CHR$(kopf(x))
          NEXT x
          partname$=TRIM$(partname$)
          '    bezeichnung$(0)=partname$
          variation=0
          zeigen!=TRUE
          altpart_3d
          nlines(2)=laenge%
          fill_window(1,FALSE)
          fill_window(2,FALSE)
          fill_window(3,FALSE)
          CLOSE #1
          DEFMOUSE 0
        ELSE
          ALERT 2,"Falsches Dateiformat ",1,"Abbruch",x
        ENDIF
      ELSE
        ALERT 2,"  Datei |  "+ldname$+"|  nicht gefunden!  ",1,"Abbruch",x
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE lade_xyz(mode)
  LOCAL x$      ! Nur zum Einlesen per Input #1
  abort!=TRUE
  REM mode 0 = laden
  REM mode 1 = merge
  SELECT mode
  CASE 0
    ' Alle Nodes lîschen
    FOR signal=1 TO maxsignals
      ' restliche Nodes an Empty-List zurÅckgeben
      WHILE foll%(header(signal))<>header(signal)
        delete_node(foll%(header(signal)))
      WEND
    NEXT signal
  CASE 1
    FOR signal=1 TO maxsignals
      ' Pointer auf letzten Node feststellen
      pointer%(signal)=@get_last_node(signal)
    NEXT signal
  ENDSELECT
  xyzpfad$=@path$(xyzdname$)+"*.3DS"
  xyzdname$=RIGHT$(xyzdname$,LEN(xyzdname$)-RINSTR(xyzdname$,"\"))
  FILESELECT #"3D-Part laden",xyzpfad$,xyzdname$,xyzdname$
  IF xyzdname$>""
    IF EXIST(xyzdname$)
      xyzdir$=@path$(xyzdname$)+"*.3DS"
      DEFMOUSE 2
      IF UPPER$(@ext$(xyzdname$))=".3DS"
        OPEN "I",#1,xyzdname$
        INPUT #1,xyz_version$
        IF xyz_version$>"1.01"
          INPUT #1,quant        ! Quant-Zeit
          DIV quant,3
        ENDIF
        FOR signal=1 TO maxsignals
          IF NOT EOF(#1)
            INPUT #1,x$   ! Spurnummer, ignorieren
            midich(signal)=VAL(x$)
            INPUT #1,x$
            laenge%=VAL(x$)
            pointer%(signal)=header(signal)
            FOR x=1 TO laenge%
              insert_node(pointer%(signal))
              pointer%(signal)=foll%(pointer%(signal))
              FOR koor=0 TO 4
                INPUT #1,x$
                koor(koor,pointer%(signal))=VAL(x$)
              NEXT koor
            NEXT x
            ' Pointer wieder auf Anfang setzen
            pointer%(signal)=header(signal)
          ENDIF
        NEXT signal
        CLOSE #1
        DEFMOUSE 0
      ELSE
        ALERT 2,"Falsches Dateiformat ",1,"Abbruch",x
      ENDIF
    ELSE
      ALERT 2,"  Datei |  "+ldname$+"|  nicht gefunden!  ",1,"Abbruch",x
    ENDIF
  ENDIF
RETURN
PROCEDURE laden_presets(fileselect!)
  IF fileselect!
    presdname$=RIGHT$(presdname$,LEN(presdname$)-RINSTR(presdname$,"\"))
    FILESELECT #"Presets laden",presdir$,presdname$,presdname$
  ENDIF
  IF presdname$>""
    '    IF @ext$(presdname$)<>".RTS"
    '      presdname$=LEFT$(presdname$,LEN(presdname$)-LEN(@ext$(presdname$)))+".RTS"
    '    ENDIF
    IF EXIST(presdname$)
      presdir$=@path$(presdname$)+"*.RTS"
      IF UPPER$(@ext$(presdname$))=".RTS"
        DEFMOUSE 2
        OPEN "I",#1,presdname$
        INPUT #1,preset_datei_version$
        IF preset_datei_version$="2.15" OR preset_datei_version$="2.16"
          BGET #1,VARPTR(setup(0,0)),DIM?(setup())*2
          BGET #1,VARPTR(setup2(0,0)),DIM?(setup2())*2
          '          BGET #1,VARPTR(fkeyn(0)),DIM?(fkeyn())*2
          '          RECALL #1,setup$(),1+maxsetups/2,fkeys%
          '          RECALL #1,setup2$(),maxsetups/2,fkeys%
          spiegelsetup=0
          FOR setupnr=1 TO 126
            INC spiegelsetup
            spiegel_setup(0,spiegelsetup)=setup(setupnr,3)
            FOR signal=0 TO maxsignals
              spiegel_setup(signal,spiegelsetup)=setup(setupnr,10+signal*7)
            NEXT signal
          NEXT setupnr
          mtr_setup=126
          FOR setupnr=127 TO 800
            INC mtr_setup
            FOR signal=0 TO maxsignals
              mtr_phase(signal,mtr_setup)=setup(setupnr,4+signal*7)
              mtr_seku(signal,mtr_setup)=setup(setupnr,5+signal*7)
              mtr_richtung(signal,mtr_setup)=setup(setupnr,6+signal*7)
              mtr_modus(signal,mtr_setup)=setup(setupnr,7+signal*7)
              mtr_wausschnitt%(signal,mtr_setup)=setup(setupnr,8+signal*7)
              mtr_dreh(signal,mtr_setup)=setup(setupnr,9+signal*7)
            NEXT signal
          NEXT setupnr
          FOR setupnr=1 TO 800
            INC mtr_setup
            FOR signal=0 TO maxsignals
              mtr_phase(signal,mtr_setup)=setup2(setupnr,4+signal*7)
              mtr_seku(signal,mtr_setup)=setup2(setupnr,5+signal*7)
              mtr_richtung(signal,mtr_setup)=setup2(setupnr,6+signal*7)
              mtr_modus(signal,mtr_setup)=setup2(setupnr,7+signal*7)
              mtr_wausschnitt%(signal,mtr_setup)=setup2(setupnr,8+signal*7)
              mtr_dreh(signal,mtr_setup)=setup2(setupnr,9+signal*7)
            NEXT signal
          NEXT setupnr
          setupnr=0
          '         mtr_setup=1
          '          spiegelsetup=1
        ELSE IF FALSE !preset_datei_version$="2.15" OR preset_datei_version$="2.16"
          spiegelsetup=1
          mtr_setup=1
          FOR setupnr=0 TO 800
            makro=INP&(#1)
          NEXT setupnr
          FOR setupnr=0 TO 800
            ~INP(#1)    ! Multimode
            ~INP(#1)    ! Input 1-8 an/aus
          NEXT setupnr
          spiegelsetup=0
          FOR setupnr=0 TO 800
            spiegelsetup=MIN(127,setupnr)
            spiegel_setup(0,spiegelsetup)=INP&(#1)    ! Mausmodus
          NEXT setupnr
          FOR signal=0 TO maxsignals
            mtr_setup=0
            FOR setupnr=0 TO 800
              IF setupnr>126
                INC mtr_setup
                mtr_phase(signal,mtr_setup)=INP&(#1)
              ENDIF
            NEXT setupnr
            mtr_setup=0
            FOR setupnr=0 TO 800
              IF setupnr>126
                INC mtr_setup
                mtr_seku(signal,mtr_setup)=INP&(#1)
              ENDIF
            NEXT setupnr
            mtr_setup=0
            FOR setupnr=0 TO 800
              IF setupnr>126
                INC mtr_setup
                mtr_richtung(signal,mtr_setup)=INP&(#1)
              ENDIF
            NEXT setupnr
            mtr_setup=0
            FOR setupnr=0 TO 800
              IF setupnr>126
                INC mtr_setup
                mtr_modus(signal,mtr_setup)=INP&(#1)
              ENDIF
            NEXT setupnr
            mtr_setup=0
            FOR setupnr=0 TO 800
              IF setupnr>126
                INC mtr_setup
                mtr_wausschnitt%(signal,mtr_setup)=INP&(#1)
              ENDIF
            NEXT setupnr
            mtr_setup=0
            FOR setupnr=0 TO 800
              IF setupnr>126
                INC mtr_setup
                mtr_dreh(signal,mtr_setup)=INP&(#1)
              ENDIF
            NEXT setupnr
            spiegelsetup=0
            FOR setupnr=0 TO 800
              spiegelsetup=MIN(127,setupnr)
              spiegel_setup(signal,spiegelsetup)=INP&(#1)
            NEXT setupnr
          NEXT signal
          IF setupnr<=126
            INC spiegelsetup
          ELSE
            INC mtr_setup
          ENDIF
          spiegelsetup=1
          mtr_setup=1
          '          BGET #1,VARPTR(setup(0,0)),DIM?(setup())*2
          '          BGET #1,VARPTR(setup2(0,0)),DIM?(setup2())*2
          '          BGET #1,VARPTR(fkeyn(0)),DIM?(fkeyn())*2
          '          RECALL #1,setup$(),1+maxsetups/2,fkeys%
          '          RECALL #1,setup2$(),maxsetups/2,fkeys%
        ELSE IF preset_datei_version$="2.12"
          IF FALSE
            BGET #1,VARPTR(setup(0,0)),DIM?(setup())*2
            BGET #1,VARPTR(fkeyn(0)),DIM?(fkeyn())*2
            RECALL #1,setup$(),maxsetups/2,fkeys%
          ENDIF
        ELSE
          IF FALSE
            SEEK #1,0 ! ZurÅck zum Dateianfang
            ' alte Version
            FOR y=0 TO 74
              FOR x=0 TO 500
                setup(x,y)=INP&(#1)
              NEXT x
            NEXT y
            BGET #1,VARPTR(fkeyn(0)),DIM?(fkeyn())*2
            RECALL #1,setup$(),500,fkeys%
          ENDIF
        ENDIF
        CLOSE #1
        DEFMOUSE 0
      ELSE
        ALERT 2,"Falsches Dateiformat ",1,"Abbruch",x
      ENDIF
    ELSE
      DEFMOUSE 0
      ALERT 2,"  Preset-Datei |  "+presdname$+"|  nicht gefunden!  ",1,"Abbruch",x
    ENDIF
  ENDIF
RETURN
PROCEDURE laden_lfos(fileselect!)
  IF fileselect!
    lfodname$=RIGHT$(lfodname$,LEN(lfodname$)-RINSTR(lfodname$,"\"))
    FILESELECT #"LFO-Parameter laden",lfodir$,lfodname$,lfodname$
  ENDIF
  akttxt$="LFO-Setups laden ..."
  IF lfodname$>""
    '    IF @ext$(lfodname$)<>".LFO"
    '      lfodname$=LEFT$(lfodname$,LEN(lfodname$)-LEN(@ext$(lfodname$)))+".LFO"
    '    ENDIF
    lfodir$=@path$(lfodname$)+"*.L?O"
    IF EXIST(lfodname$)
    ELSE IF EXIST(@dnames$(lfodname$)+".LFO")
      lfodname$=@dnames$(lfodname$)+".LFO"
    ENDIF
    IF EXIST(lfodname$)
      aktstat_box(TRUE)
      IF UPPER$(@ext$(lfodname$))=".L1O" OR UPPER$(@ext$(lfodname$))=".LFO"
        DEFMOUSE 2
        OPEN "I",#1,lfodname$
        INPUT #1,lfo_datei_version$
        SELECT lfo_datei_version$
        CASE "1.00"
          FOR lfosetup=0 TO 200
            FOR lfo=0 TO 7
              FOR x=0 TO 9
                lfo_param(x,lfo,lfosetup)=INP&(#1)
              NEXT x
            NEXT lfo
          NEXT lfosetup
          FOR lfosetup=0 TO 200
            FOR ziel=0 TO 3
              FOR x=0 TO 10
                lfo_ziel(x,ziel,lfosetup)=INP&(#1)
              NEXT x
            NEXT ziel
          NEXT lfosetup
          lfo_aenderung!=TRUE
        CASE "1.01"
          FOR lfosetup=0 TO 800
            FOR lfo=0 TO 7
              FOR x=0 TO 9
                lfo_param(x,lfo,lfosetup)=INP&(#1)
              NEXT x
            NEXT lfo
          NEXT lfosetup
          FOR lfosetup=0 TO 800
            FOR ziel=0 TO 3
              FOR x=0 TO 10
                lfo_ziel(x,ziel,lfosetup)=INP&(#1)
              NEXT x
            NEXT ziel
          NEXT lfosetup
          lfo_aenderung!=TRUE
        CASE "1.02"
          BGET #1,VARPTR(lfo_param(0,0,0)),DIM?(lfo_param())*2
          FOR lfosetup=0 TO 800
            FOR ziel=0 TO 3
              FOR x=0 TO 10
                SELECT x
                CASE 0 TO 2
                  lfo_ziel(x,ziel,lfosetup)=INP&(#1)
                CASE 3 TO 6
                  lfo_ziel(x,ziel*2,lfosetup)=INP&(#1)
                  lfo_ziel(x,1+ziel*2,lfosetup)=lfo_ziel(x,ziel*2,lfosetup)
                CASE 7 TO 10
                  lfo_ziel(x,ziel*2,lfosetup)=INP&(#1)
                  lfo_ziel(x,1+ziel*2,lfosetup)=lfo_ziel(x,ziel*2,lfosetup)
                ENDSELECT
              NEXT x
            NEXT ziel
          NEXT lfosetup
          lfo_aenderung!=TRUE
        CASE "1.03","1.04"
          SELECT lfo_datei_version$
          CASE "1.03"
            laenge=800
          CASE "1.04"
            laenge=1200
          ENDSELECT
          FOR lfosetup=0 TO laenge
            FOR lfo=0 TO 11
              FOR x=0 TO 9
                lfo_param(x,lfo,lfosetup)=INP&(#1)
              NEXT x
            NEXT lfo
          NEXT lfosetup
          FOR lfosetup=0 TO laenge
            FOR ziel=0 TO 8
              FOR x=0 TO 10
                lfo_ziel(x,ziel,lfosetup)=INP&(#1)
              NEXT x
            NEXT ziel
          NEXT lfosetup
          lfo_aenderung!=TRUE
        CASE "1.05"
          BGET #1,VARPTR(lfo_param(0,0,0)),DIM?(lfo_param())*2
          IF EXIST(@dnames$(lfodname$)+".L2O")
            CLOSE #1
            OPEN "I",#1,@dnames$(lfodname$)+".L2O"
            BGET #1,VARPTR(lfo_ziel(0,0,0)),DIM?(lfo_ziel())*2
          ELSE
            ALERT 1,@dnames$(lfodname$)+".L2O"+"|existiert nicht.",1,"Abbruch",wahl
          ENDIF
        ENDSELECT
        CLOSE #1
        DEFMOUSE 0
        aktstat_box(FALSE)
      ELSE
        ALERT 2,"Falsches Dateiformat |"+lfodname$,1,"Abbruch",x
      ENDIF
    ELSE
      DEFMOUSE 0
      ALERT 2,"  Preset-Datei |  "+lfodname$+"|  nicht gefunden!  ",1,"Abbruch",x
    ENDIF
  ENDIF
RETURN
PROCEDURE laden_inputsets(fileselect!)
  IF fileselect!
    inpdname$=RIGHT$(inpdname$,LEN(inpdname$)-RINSTR(inpdname$,"\"))
    FILESELECT #"Input-Setups laden",inpdir$,inpdname$,inpdname$
  ENDIF
  akttxt$="INP-Setups laden ..."
  IF inpdname$>""
    '    IF @ext$(inpdname$)<>".INP"
    '      inpdname$=LEFT$(inpdname$,LEN(inpdname$)-LEN(@ext$(inpdname$)))+".INP"
    '    ENDIF
    IF EXIST(inpdname$)
      aktstat_box(TRUE)
      inpdir$=@path$(inpdname$)+"*.INP"
      IF UPPER$(@ext$(inpdname$))=".INP"
        DEFMOUSE 2
        OPEN "I",#1,inpdname$
        INPUT #1,inp_datei_version$
        IF inp_datei_version$="1.00"
          BGET #1,VARPTR(input_setup|(0,0)),DIM?(input_setup|())
        ENDIF
        CLOSE #1
        DEFMOUSE 0
        aktstat_box(FALSE)
      ELSE
        ALERT 2,"Falsches Dateiformat ",1,"Abbruch",x
      ENDIF
    ELSE
      DEFMOUSE 0
      ALERT 2,"  Preset-Datei |  "+inpdname$+"|  nicht gefunden!  ",1,"Abbruch",x
    ENDIF
  ENDIF
RETURN
PROCEDURE laden_multirot(fileselect!)
  IF fileselect!
    mtrdname$=RIGHT$(mtrdname$,LEN(mtrdname$)-RINSTR(mtrdname$,"\"))
    FILESELECT #"Multirotationen laden",mtrdir$,mtrdname$,mtrdname$
  ENDIF
  akttxt$="MTR-Setups laden ..."
  IF mtrdname$>""
    '    IF @ext$(mtrdname$)<>".MTR"
    '      mtrdname$=LEFT$(mtrdname$,LEN(mtrdname$)-LEN(@ext$(mtrdname$)))+".MTR"
    '    ENDIF
    IF EXIST(mtrdname$)
      mtrdir$=@path$(mtrdname$)+"*.MTR"
      IF UPPER$(@ext$(mtrdname$))=".MTR"
        aktstat_box(TRUE)
        DEFMOUSE 2
        OPEN "I",#1,mtrdname$
        INPUT #1,mtr_datei_version$
        IF mtr_datei_version$="1.00" OR mtr_datei_version$="1.01"
          BGET #1,VARPTR(mtr_phase(0,0)),DIM?(mtr_phase())*2
          BGET #1,VARPTR(mtr_seku(0,0)),DIM?(mtr_seku())*2
          BGET #1,VARPTR(mtr_richtung(0,0)),DIM?(mtr_richtung())*2
          BGET #1,VARPTR(mtr_modus(0,0)),DIM?(mtr_modus())*2
          BGET #1,VARPTR(mtr_wausschnitt%(0,0)),DIM?(mtr_wausschnitt%())*4
          BGET #1,VARPTR(mtr_dreh(0,0)),DIM?(mtr_dreh())*2
          IF mtr_datei_version$="1.01"
            BGET #1,VARPTR(mtr_form(0)),DIM?(mtr_form())*2
          ELSE
            mtr_aenderung!=TRUE
          ENDIF
        ENDIF
        CLOSE #1
        aktstat_box(FALSE)
        DEFMOUSE 0
      ELSE
        ALERT 2,"Falsches Dateiformat ",1,"Abbruch",x
      ENDIF
    ELSE
      DEFMOUSE 0
      ALERT 2,"  Preset-Datei |  "+mtrdname$+"|  nicht gefunden!  ",1,"Abbruch",x
    ENDIF
  ENDIF
RETURN
PROCEDURE laden_spiegel(fileselect!)
  IF fileselect!
    spidname$=RIGHT$(spidname$,LEN(spidname$)-RINSTR(spidname$,"\"))
    FILESELECT #"Spiegel-Setups laden",spidir$,spidname$,spidname$
  ENDIF
  akttxt$="SPI-Setups laden ..."
  IF spidname$>""
    '    IF @ext$(spidname$)<>".SPI"
    '      spidname$=LEFT$(spidname$,LEN(spidname$)-LEN(@ext$(spidname$)))+".SPI"
    '    ENDIF
    IF EXIST(spidname$)
      aktstat_box(TRUE)
      spidir$=@path$(spidname$)+"*.SPI"
      IF UPPER$(@ext$(spidname$))=".SPI"
        DEFMOUSE 2
        OPEN "I",#1,spidname$
        INPUT #1,spi_datei_version$
        IF spi_datei_version$="1.00" OR spi_datei_version$="1.01"
          BGET #1,VARPTR(spiegel_setup(0,0)),DIM?(spiegel_setup())*2
          BGET #1,VARPTR(dreh_setup(0,0,0)),DIM?(dreh_setup())*2
          IF spi_datei_version$="1.01"
            BGET #1,VARPTR(offset_setup(0,0,0)),DIM?(offset_setup())*2
          ENDIF
        ENDIF
        CLOSE #1
        aktstat_box(FALSE)
        DEFMOUSE 0
      ELSE
        ALERT 2,"Falsches Dateiformat ",1,"Abbruch",x
      ENDIF
    ELSE
      DEFMOUSE 0
      ALERT 2,"  Preset-Datei |  "+spidname$+"|  nicht gefunden!  ",1,"Abbruch",x
    ENDIF
  ENDIF
RETURN
PROCEDURE laden_general_setups(fileselect!)
  IF fileselect!
    gendname$=RIGHT$(gendname$,LEN(gendname$)-RINSTR(gendname$,"\"))
    FILESELECT #"Input-Setups laden",gendir$,gendname$,gendname$
  ENDIF
  akttxt$="GEN-Setups laden ..."
  IF gendname$>""
    '    IF @ext$(gendname$)<>".GEN"
    '      gendname$=LEFT$(gendname$,LEN(gendname$)-LEN(@ext$(gendname$)))+".GEN"
    '    ENDIF
    IF EXIST(gendname$)
      gendir$=@path$(gendname$)+"*.GEN"
      IF UPPER$(@ext$(gendname$))=".GEN"
        aktstat_box(TRUE)
        DEFMOUSE 2
        OPEN "I",#1,gendname$
        INPUT #1,gen_datei_version$
        SELECT gen_datei_version$
        CASE "1.02"
          FOR generalsetup=0 TO 10000
            FOR x=0 TO 5
              general_setup(x,generalsetup)=INP&(#1)
            NEXT x
          NEXT generalsetup
          gen_aenderung!=TRUE
        CASE "1.03"
          BGET #1,VARPTR(general_setup(0,0)),DIM?(general_setup())*2
        DEFAULT
          ALERT 2,"Zu alte *.GEN-Datei ",1,"Abbruch",x
        ENDSELECT
        CLOSE #1
        aktstat_box(FALSE)
        DEFMOUSE 0
      ELSE
        ALERT 2,"Falsches Dateiformat ",1,"Abbruch",x
      ENDIF
    ELSE
      DEFMOUSE 0
      ALERT 2,"  Preset-Datei |  "+gendname$+"|  nicht gefunden!  ",1,"Abbruch",x
    ENDIF
  ENDIF
RETURN
PROCEDURE laden_alle_setups(default!)
  IF default!
    presdir$=DIR$(0)+"\*.RTS"
    presdname$=DIR$(0)+"\DEFAULT.RTS"
    lfodir$=DIR$(0)+"\*.LFO"
    lfodname$=DIR$(0)+"\DEFAULT.L1O"
    inpdir$=DIR$(0)+"\*.INP"
    inpdname$=DIR$(0)+"\DEFAULT.INP"
    gendir$=DIR$(0)+"\*.GEN"
    gendname$=DIR$(0)+"\DEFAULT.GEN"
    mtrdir$=DIR$(0)+"\*.MTR"
    mtrdname$=DIR$(0)+"\DEFAULT.MTR"
    spidir$=DIR$(0)+"\*.SPI"
    spidname$=DIR$(0)+"\DEFAULT.SPI"
  ENDIF
  IF EXIST(presdname$)
    '    laden_presets(FALSE)
  ENDIF
  IF EXIST(lfodname$) OR EXIST(@dnames$(lfodname$)+".LFO")
    laden_lfos(FALSE)
  ENDIF
  IF EXIST(inpdname$)
    laden_inputsets(FALSE)
  ENDIF
  IF EXIST(gendname$)
    laden_general_setups(FALSE)
  ENDIF
  IF EXIST(mtrdname$)
    laden_multirot(FALSE)
  ENDIF
  IF EXIST(spidname$)
    laden_spiegel(FALSE)
  ENDIF
RETURN
PROCEDURE export_gen
  dpname$="Export Anfang"
  value=export_start
  valslider=export_start
  minval=1
  maxval=maxgensetups
  dparam
  IF ok!
    export_start=MAX(1,value)
  ENDIF
  dpname$="Export Ende"
  value=export_ende
  valslider=export_ende
  minval=1
  maxval=maxgensetups
  dparam
  IF ok!
    export_ende=MAX(1,value)
  ENDIF
  IF NOT RIGHT$(genexp$,4)=".EXP"
    genexp$=@dname$(genexp$)+".EXP"
  ENDIF
  FILESELECT #"General-Set-Export in",exppfad$,@dname$(genexp$),genexp$
  IF genexp$>""
    IF NOT RIGHT$(genexp$,4)=".EXP"
      genexp$=@dname$(genexp$)+".EXP"
    ENDIF
    exppfad$=@path$(genexp$)
    DEFMOUSE 2
    IF EXIST(genexp$)
      IF replace!
        KILL genexp$
      ELSE
        genexpbak$=LEFT$(genexp$,LEN(genexp$)-1)+"B"
        IF EXIST(genexpbak$)
          KILL genexpbak$
        ENDIF
        IF genexp$<>genexpbak$
          ' wenn jemand extra ".EXB" abspeichert keine Umbenennung
          RENAME genexp$ AS genexpbak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,genexp$
    FOR x=export_start TO export_ende
      PRINT #1,"GN"+RIGHT$("000000"+STR$(x),6)
      FOR y=0 TO 5
        PRINT #1,general_setup(y,x)
      NEXT y
      PRINT #1
    NEXT x
    CLOSE #1
    DEFMOUSE 0
  ENDIF
RETURN
PROCEDURE export_mtr
  LOCAL signal,setup
  dpname$="Export Anfang"
  value=export_start
  valslider=export_start
  minval=1
  maxval=max_mtr_setups
  dparam
  IF ok!
    export_start=MAX(1,value)
  ENDIF
  dpname$="Export Ende"
  value=export_ende
  valslider=export_ende
  minval=1
  maxval=max_mtr_setups
  dparam
  IF ok!
    export_ende=MAX(1,value)
    export_ende=MIN(value,max_mtr_setups)
  ENDIF
  IF NOT RIGHT$(mtrexp$,4)=".EXP"
    mtrexp$=@dname$(mtrexp$)+".EXP"
  ENDIF
  FILESELECT #"MTR-Set-Export in",exppfad$,@dname$(mtrexp$),mtrexp$
  IF mtrexp$>""
    IF NOT RIGHT$(mtrexp$,4)=".EXP"
      mtrexp$=@dname$(mtrexp$)+".EXP"
    ENDIF
    exppfad$=@path$(mtrexp$)
    DEFMOUSE 2
    IF EXIST(mtrexp$)
      IF replace!
        KILL mtrexp$
      ELSE
        mtrexpbak$=LEFT$(mtrexp$,LEN(mtrexp$)-1)+"B"
        IF EXIST(mtrexpbak$)
          KILL mtrexpbak$
        ENDIF
        IF mtrexp$<>mtrexpbak$
          ' wenn jemand extra ".EXB" abspeichert keine Umbenennung
          RENAME mtrexp$ AS mtrexpbak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,mtrexp$
    FOR setup=export_start TO export_ende
      ' PRINT #1,"GN"+RIGHT$("000000"+STR$(x),6)
      FOR signal=0 TO maxsignals
        PRINT #1,mtr_dreh(signal,setup)
        PRINT #1,mtr_richtung(signal,setup)
        PRINT #1,mtr_modus(signal,setup)
        PRINT #1,mtr_seku(signal,setup)
        PRINT #1,mtr_phase(signal,setup)
        PRINT #1,mtr_wausschnitt%(signal,setup)
      NEXT signal
      PRINT #1,mtr_form(setup)
      PRINT #1
    NEXT setup
    CLOSE #1
    DEFMOUSE 0
  ENDIF
RETURN
PROCEDURE export_lfo
  LOCAL signal,setup,ziel,lfo,parameter
  dpname$="Export Anfang"
  value=export_start
  valslider=export_start
  minval=1
  maxval=maxlfosetups
  dparam
  IF ok!
    export_start=MAX(1,value)
  ENDIF
  dpname$="Export Ende"
  value=export_ende
  valslider=export_ende
  minval=1
  maxval=maxlfosetups
  dparam
  IF ok!
    export_ende=MAX(1,value)
    export_ende=MIN(value,maxlfosetups)
  ENDIF
  IF NOT RIGHT$(lfoexp$,4)=".EXP"
    lfoexp$=@dname$(lfoexp$)+".EXP"
  ENDIF
  FILESELECT #"LFO-Set-Export in",exppfad$,@dname$(lfoexp$),lfoexp$
  IF lfoexp$>""
    IF NOT RIGHT$(lfoexp$,4)=".EXP"
      lfoexp$=@dname$(lfoexp$)+".EXP"
    ENDIF
    exppfad$=@path$(lfoexp$)
    DEFMOUSE 2
    IF EXIST(lfoexp$)
      IF replace!
        KILL lfoexp$
      ELSE
        lfoexpbak$=LEFT$(lfoexp$,LEN(lfoexp$)-1)+"B"
        IF EXIST(lfoexpbak$)
          KILL lfoexpbak$
        ENDIF
        IF lfoexp$<>lfoexpbak$
          ' wenn jemand extra ".EXB" abspeichert keine Umbenennung
          RENAME lfoexp$ AS lfoexpbak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,lfoexp$
    FOR setup=export_start TO export_ende
      ' PRINT #1,"GN"+RIGHT$("000000"+STR$(x),6)
      FOR lfo=0 TO maxlfos
        PRINT #1,lfo_param(0,lfo,setup) ! MÅll
        PRINT #1,lfo_param(1,lfo,setup) ! Quelle
        PRINT #1,lfo_param(2,lfo,setup) ! Speed
        PRINT #1,lfo_param(3,lfo,setup) ! Phase
        PRINT #1,lfo_param(4,lfo,setup) ! Ampl
        PRINT #1,lfo_param(5,lfo,setup) ! Offset
        PRINT #1,lfo_param(6,lfo,setup) ! Pauso
        PRINT #1,lfo_param(7,lfo,setup) ! Pausu
        PRINT #1,lfo_param(8,lfo,setup) ! Ctrl In
        PRINT #1,lfo_param(9,lfo,setup) ! Ctrl Out
      NEXT lfo
      FOR ziel=0 TO maxsignals
        ' LFO-Patches sind intern 1..4 numeriert, in RTM4 aber 1 .. 8
        PRINT #1,lfo_ziel(0,(ziel+0)/2,setup) ! MÅll
        PRINT #1,lfo_ziel(1,(ziel+0)/2,setup) ! Panbreite
        PRINT #1,lfo_ziel(2,(ziel+0)/2,setup) ! Panpos
        ' Signal-bezogene Daten: 0 wird identisch zu 1 gemacht.
        PRINT #1,lfo_ziel(3,MAX(ziel-1,0),setup) ! MTR-Speed
        PRINT #1,lfo_ziel(4,MAX(ziel-1,0),setup) ! Volume
        PRINT #1,lfo_ziel(5,MAX(ziel-1,0),setup) ! Zoom
        PRINT #1,lfo_ziel(6,MAX(ziel-1,0),setup) ! Vor-ZurÅck
        PRINT #1,lfo_ziel(7,MAX(ziel-1,0),setup) ! X
        PRINT #1,lfo_ziel(8,MAX(ziel-1,0),setup) ! Y
        PRINT #1,lfo_ziel(9,MAX(ziel-1,0),setup) ! Z
        PRINT #1,lfo_ziel(10,ziel,setup) ! MÅll
      NEXT ziel
      PRINT #1
    NEXT setup
    CLOSE #1
    DEFMOUSE 0
  ENDIF
RETURN
PROCEDURE export_spi
  LOCAL signal,setup
  dpname$="Export Anfang"
  value=export_start
  valslider=export_start
  minval=1
  maxval=maxspisetups
  dparam
  IF ok!
    export_start=MAX(1,value)
  ENDIF
  dpname$="Export Ende"
  value=export_ende
  valslider=export_ende
  minval=1
  maxval=maxspisetups
  dparam
  IF ok!
    export_ende=MAX(1,value)
    export_ende=MIN(value,maxspisetups)
  ENDIF
  IF NOT RIGHT$(spiexp$,4)=".EXP"
    spiexp$=@dname$(spiexp$)+".EXP"
  ENDIF
  FILESELECT #"SPI-Set-Export in",exppfad$,@dname$(spiexp$),spiexp$
  IF spiexp$>""
    IF NOT RIGHT$(spiexp$,4)=".EXP"
      spiexp$=@dname$(spiexp$)+".EXP"
    ENDIF
    exppfad$=@path$(spiexp$)
    DEFMOUSE 2
    ' SPS
    MID$(spiexp$,LEN(spiexp$)-4)="s"
    IF EXIST(spiexp$)
      IF replace!
        KILL spiexp$
      ELSE
        spiexpbak$=LEFT$(spiexp$,LEN(spiexp$)-1)+"B"
        IF EXIST(spiexpbak$)
          KILL spiexpbak$
        ENDIF
        IF spiexp$<>spiexpbak$
          ' wenn jemand extra ".EXB" abspeichert keine Umbenennung
          RENAME spiexp$ AS spiexpbak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,spiexp$
    FOR setup=export_start TO export_ende
      ' PRINT #1,"GN"+RIGHT$("000000"+STR$(x),6)
      FOR signal=0 TO maxsignals
        SELECT setup
        CASE 1 TO 399
          PRINT #1,spiegel_setup(signal,setup)
          PRINT #1
        ENDSELECT
      NEXT signal
    NEXT setup
    CLOSE #1
    ' SPG
    MID$(spiexp$,LEN(spiexp$)-4)="g"
    IF EXIST(spiexp$)
      IF replace!
        KILL spiexp$
      ELSE
        spiexpbak$=LEFT$(spiexp$,LEN(spiexp$)-1)+"B"
        IF EXIST(spiexpbak$)
          KILL spiexpbak$
        ENDIF
        IF spiexp$<>spiexpbak$
          ' wenn jemand extra ".EXB" abspeichert keine Umbenennung
          RENAME spiexp$ AS spiexpbak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,spiexp$
    FOR setup=export_start TO export_ende
      FOR signal=0 TO maxsignals
        SELECT setup
        CASE 1 TO 499
          FOR koor=0 TO 2
            PRINT #1,dreh_setup(koor,signal,setup)
          NEXT koor
          PRINT #1
        ENDSELECT
      NEXT signal
    NEXT setup
    CLOSE #1
    ' SPO
    MID$(spiexp$,LEN(spiexp$)-4)="o"
    IF EXIST(spiexp$)
      IF replace!
        KILL spiexp$
      ELSE
        spiexpbak$=LEFT$(spiexp$,LEN(spiexp$)-1)+"B"
        IF EXIST(spiexpbak$)
          KILL spiexpbak$
        ENDIF
        IF spiexp$<>spiexpbak$
          ' wenn jemand extra ".EXB" abspeichert keine Umbenennung
          RENAME spiexp$ AS spiexpbak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,spiexp$
    FOR setup=export_start TO export_ende
      FOR signal=0 TO maxsignals
        SELECT setup
        CASE 1 TO 799
          ' SPO
          FOR koor=0 TO 2
            PRINT #1,offset_setup(koor,signal,setup)
          NEXT koor
          PRINT #1
        ENDSELECT
      NEXT signal
    NEXT setup
    CLOSE #1
    DEFMOUSE 0
  ENDIF
RETURN
PROCEDURE export_inp
  LOCAL signal,setup
  dpname$="Export Anfang"
  value=export_start
  valslider=export_start
  minval=1
  maxval=maxinpsetups
  dparam
  IF ok!
    export_start=MAX(1,value)
  ENDIF
  dpname$="Export Ende"
  value=export_ende
  valslider=export_ende
  minval=1
  maxval=maxinpsetups
  dparam
  IF ok!
    export_ende=MAX(1,value)
    export_ende=MIN(value,maxinpsetups)
  ENDIF
  IF NOT RIGHT$(inpexp$,4)=".EXP"
    inpexp$=@dname$(inpexp$)+".EXP"
  ENDIF
  FILESELECT #"INP-Set-Export in",exppfad$,@dname$(inpexp$),inpexp$
  IF inpexp$>""
    IF NOT RIGHT$(inpexp$,4)=".EXP"
      inpexp$=@dname$(inpexp$)+".EXP"
    ENDIF
    exppfad$=@path$(inpexp$)
    DEFMOUSE 2
    IF EXIST(inpexp$)
      IF replace!
        KILL inpexp$
      ELSE
        inpexpbak$=LEFT$(inpexp$,LEN(inpexp$)-1)+"B"
        IF EXIST(inpexpbak$)
          KILL inpexpbak$
        ENDIF
        IF inpexp$<>inpexpbak$
          ' wenn jemand extra ".EXB" abspeichert keine Umbenennung
          RENAME inpexp$ AS inpexpbak$
        ENDIF
      ENDIF
    ENDIF
    OPEN "o",#1,inpexp$
    FOR setup=export_start TO export_ende
      FOR signal=0 TO maxsignals
        PRINT #1,input_setup|(signal,setup)
      NEXT signal
      PRINT #1
    NEXT setup
    CLOSE #1
    DEFMOUSE 0
  ENDIF
RETURN
'
' * * *   Funktionen   * * *
'
DEFFN zeit(laenge)=wert(laenge,3)*quadrat%+wert(laenge,4)*256+wert(laenge,5)
DEFFN zeit$(laenge)=STR$(INT(@zeit(laenge)/(takt*192)),5)+"."+STR$(INT(@zeit(laenge)/192) MOD takt,2)+"."+STR$(@zeit(laenge) MOD 192,3)
DEFFN oinput(event)=TRUNC(mwert(event,0)/8)
DEFFN input(event)=1+TRUNC(mwert(event,variation)/8)
DEFFN ooutput(event)=mwert(event,0) MOD 8
DEFFN output(event)=1+mwert(event,variation) MOD 8
DEFFN kx(signal)=value(signal,1)+value(signal,4)+value(signal,5)+value(signal,8)-value(signal,2)-value(signal,3)-value(signal,6)-value(signal,7)
DEFFN ky(signal)=value(signal,5)+value(signal,6)+value(signal,7)+value(signal,8)-value(signal,1)-value(signal,2)-value(signal,3)-value(signal,4)
DEFFN kz(signal)=value(signal,1)+value(signal,2)+value(signal,5)+value(signal,6)-value(signal,3)-value(signal,4)-value(signal,7)-value(signal,8)
FUNCTION dnames$(fs$)
  LOCAL dname$
  dname$=@dname$(fs$)
  IF RINSTR(dname$,".")>0
    dname$=LEFT$(dname$,RINSTR(dname$,".")-1)
  ENDIF
  RETURN dname$
ENDFUNC
DEFFN dname$(fs$)=RIGHT$(fs$,LEN(fs$)-RINSTR(fs$,"\"))
DEFFN path$(fs$)=LEFT$(fs$,RINSTR(fs$,"\"))
DEFFN event(y)=seite*rows+@zeile(y)
FUNCTION akx(signal)
  sxp=value(signal,2)+value(signal,3)+value(signal,6)+value(signal,7)
  sxm=value(signal,1)+value(signal,4)+value(signal,5)+value(signal,8)
  sx=ADD(sxp,sxm)
  dx=SUB(sxp,sxm)
  RETURN (maxs-sx)/sx*dx
ENDFUNC
FUNCTION aky(signal)
  syp=value(signal,5)+value(signal,6)+value(signal,7)+value(signal,8)
  sym=value(signal,1)+value(signal,2)+value(signal,3)+value(signal,4)
  sy=ADD(syp,sym)
  dy=SUB(syp,sym)
  RETURN (maxs-sy)/sy*dy
ENDFUNC
FUNCTION akz(signal)
  szp=value(signal,3)+value(signal,4)+value(signal,7)+value(signal,8)
  szm=value(signal,1)+value(signal,2)+value(signal,5)+value(signal,6)
  sz=ADD(szp,szm)
  dz=SUB(szp,szm)
  RETURN (maxs-sz)/sz*dz
ENDFUNC
FUNCTION zeile(y)
  zeile=1+INT((y-56)/zhoehe(text_size))
  SELECT zeile
  CASE  TO -1
    RETURN -1
  DEFAULT
    RETURN zeile
  ENDSELECT
ENDFUNC
FUNCTION ext$(fs$)
  ext$=RIGHT$(fs$,1+LEN(fs$)-RINSTR(fs$,"."))
  IF LEN(ext$)=LEN(fs$)
    ext$=""
  ENDIF
  RETURN ext$
ENDFUNC
PROCEDURE asc
  REPEAT
    REPEAT
      KEYGET key%
    UNTIL key%<>0
    PRINT ASC(CHR$(key%)),HEX$(key%,8)
  UNTIL BYTE(key%)=27
RETURN
FUNCTION zinput(zahl%,laenge,x,y)
  LOCAL zahl$
  zahl$=STR$(zahl%)
  LOCATE x,y
  FORM INPUT laenge AS zahl$
  IF zahl$="#"
    abort!=TRUE
  ENDIF
  RETURN VAL(zahl$)
ENDFUNC
FUNCTION vol(box)
  IF FALSE
    fein2=feinh/2
    SELECT box
    CASE 1
      distance=SQR((fein2+koor(0,count%))^2+(fein2+koor(2,count%))^2+(fein2+koor(1,count%))^2)
    CASE 2
      distance=SQR((fein2-koor(0,count%))^2+(fein2+koor(2,count%))^2+(fein2+koor(1,count%))^2)
    CASE 3
      distance=SQR((fein2-koor(0,count%))^2+(fein2-koor(2,count%))^2+(fein2+koor(1,count%))^2)
    CASE 4
      distance=SQR((fein2+koor(0,count%))^2+(fein2-koor(2,count%))^2+(fein2+koor(1,count%))^2)
    CASE 5
      distance=SQR((fein2+koor(0,count%))^2+(fein2+koor(2,count%))^2+(fein2-koor(1,count%))^2)
    CASE 6
      distance=SQR((fein2-koor(0,count%))^2+(fein2+koor(2,count%))^2+(fein2-koor(1,count%))^2)
    CASE 7
      distance=SQR((fein2-koor(0,count%))^2+(fein2-koor(2,count%))^2+(fein2-koor(1,count%))^2)
    CASE 8
      distance=SQR((fein2+koor(0,count%))^2+(fein2-koor(2,count%))^2+(fein2-koor(1,count%))^2)
    ENDSELECT
  ENDIF
  RETURN INT(127*MAX(0,feinh-distance)/feinh)
  '  RETURN (127*MAX(0,feinh-distance^0.5)/feinh)
ENDFUNC
DEFFN xk=MIN(fbreit2,MAX(-fbreit2,(MOUSEX-fxoffset)*100/ed_zoom-fbreit2))
DEFFN zk=MIN(fbreit2,MAX(-fbreit2,(MOUSEY-fzoffset+fyoffset)*100/ed_zoom-fbreit2))
FUNCTION xp(xk)
  IF innenraum!
    RETURN ed_zoom*(xk*3+fbreit2)/100+fxoffset
  ELSE
    RETURN ed_zoom*(xk+fbreit2)/100+fxoffset
  ENDIF
ENDFUNC
FUNCTION zp(zk)
  IF innenraum!
    RETURN ed_zoom*(zk*3+fbreit2)/100-fzoffset
  ELSE
    RETURN ed_zoom*(zk+fbreit2)/100-fzoffset
  ENDIF
ENDFUNC
DEFFN xkoor(x,y,z)=(vx#*x-vz#*z)*zoom#*(1+z*p#)
DEFFN ykoor(x,y,z)=(vy#*y-vz#*z)*zoom#*(1+z*p#)
DEFFN limit(x)=MAX(m,MIN(p,x))
PROCEDURE xzpos
  FOR k=-fbreit2 TO fbreit2
    xp(k+fbreit2)=@xp(k)
    zp(k+fbreit2)=@zp(k)
  NEXT k
RETURN
PROCEDURE xykoor
  LOCAL gleich#
  dname$="realtim3.xyk"
  IF NOT EXIST(dname$)
    zoom#=3
    IF vx#=0 OR vy#=0
      default_3dparam
    ENDIF
    FOR x=-64 TO 64
      FOR z=-64 TO 64
        xk(x+64,z+64)=@xkoor(x,0,z)
        yk(x+64,z+64)=@ykoor(0,x,z)
      NEXT z
    NEXT x
    zoom#=1
    OPEN "o",#1,dname$
    BPUT #1,VARPTR(xk(0,0)),VARPTR(xk(128,128))-VARPTR(xk(0,0))+2
    BPUT #1,VARPTR(yk(0,0)),VARPTR(yk(128,128))-VARPTR(yk(0,0))+2
    CLOSE #1
  ELSE
    OPEN "i",#1,dname$
    BGET #1,VARPTR(xk(0,0)),VARPTR(xk(128,128))-VARPTR(xk(0,0))+2
    BGET #1,VARPTR(yk(0,0)),VARPTR(yk(128,128))-VARPTR(yk(0,0))+2
    CLOSE #1
  ENDIF
RETURN
PROCEDURE koor(x,y,z)
  x=COSQ(rotz)*x-SINQ(rotz)*y
  y=COSQ(rotz)*y+SINQ(rotz)*x
  xg=(vx#*x-vz#*z)*zoom#*(1+z*p#)
  yg=(vy#*y-vz#*z)*zoom#*(1+z*p#)
  '  xg=COSQ(rotz)*xg-SINQ(rotz)*yg
  '  yg=SINQ(rotz)*yg+COSQ(rotz)*yg
  '  PRINT x#,y#,z#
RETURN
FUNCTION nullbytes(laenge)
  v1=kopflaenge+12*laenge+5
  v2=(INT((v1-80)/192)+1)*192
  RETURN v2+80-v1
ENDFUNC
PROCEDURE drehtest
  CLOSEW 0
  CLS
  COLOR 1
  signal=1
  FOR rotz=0 TO 360 STEP 10
    wuerfel(TRUE,TRUE,1)
    KEYGET a
    CLS
  NEXT rotz
RETURN
FUNCTION nzeit(dzeit%)
  LOCAL nzeit$,hh,mm,ss
  '  dzeit%=DIV(frames%,25)
  hh=DIV(dzeit%,3600)
  mm=DIV((SUB(dzeit%,MUL(hh,3600))),60)
  ss=SUB(SUB(dzeit%,MUL(hh,3600)),MUL(mm,60))
  '  ff=VAL(frames%)
  nzeit$=RIGHT$("00"+STR$(hh),2)+RIGHT$("00"+STR$(mm),2)+RIGHT$("00"+STR$(ss),2)
  nzeit%=VAL(nzeit$)
  RETURN nzeit%
ENDFUNC
FUNCTION xnzeit$(dzeit%)
  LOCAL nzeit$,hh,mm,ss
  hh=DIV(dzeit%,3600)
  SUB dzeit%,MUL(hh,3600)
  mm=DIV(dzeit%,60)
  SUB dzeit%,MUL(mm,60)
  '  RETURN RIGHT$("00"+STR$(hh),2)+":"+RIGHT$("00"+STR$(mm),2)+":"+RIGHT$("00"+STR$(dzeit%),2)
  RETURN STR$(hh,2)+":"+STR$(mm,2)+":"+STR$(dzeit%,2)
ENDFUNC
FUNCTION gzeit$(zeit%)
  ' wandelt Integer in String fÅr Dialog-Box
  IF zeit%<>0
    RETURN RIGHT$("000000"+STR$(@nzeit(zeit%)),6)
  ELSE
    RETURN "0"
  ENDIF
ENDFUNC
FUNCTION smpte(frames%)
  '  LOCAL smpte%,hh,mm,ss,ff
  hh=DIV(frames%,90000)
  mm=DIV(frames% MOD 90000,1500)
  ss=DIV(frames% MOD 1500,25)
  ff=frames% MOD 25
  return$=RIGHT$("0"+STR$(hh),2)
  return$=return$+RIGHT$("0"+STR$(mm),2)
  return$=return$+RIGHT$("0"+STR$(ss),2)
  return$=return$+RIGHT$("0"+STR$(ff),2)
  RETURN VAL(return$)
ENDFUNC
FUNCTION smpte_f(format%)
  '  LOCAL smpte%,hh,mm,ss,ff
  format$=RIGHT$("0000000"+STR$(format%),8)
  hh=VAL(LEFT$(format$,2))
  mm=VAL(MID$(format$,3,2))
  ss=VAL(MID$(format$,5,2))
  ff=VAL(MID$(format$,7,2))
  return$=RIGHT$("0"+STR$(hh),2)
  return$=return$+RIGHT$("0"+STR$(mm),2)
  return$=return$+RIGHT$("0"+STR$(ss),2)
  return$=return$+RIGHT$("0"+STR$(ff),2)
  RETURN VAL(return$)
ENDFUNC
FUNCTION smpte_d(hh,mm,ss,ff)
  frames%=hh*90000+mm*1500+ss*25+ff
  hh=DIV(frames%,90000)
  mm=DIV(frames% MOD 90000,1500)
  ss=DIV(frames% MOD 1500,25)
  ff=frames% MOD 25
  return$=RIGHT$("0"+STR$(hh),2)
  return$=return$+RIGHT$("0"+STR$(mm),2)
  return$=return$+RIGHT$("0"+STR$(ss),2)
  return$=return$+RIGHT$("0"+STR$(ff),2)
  RETURN VAL(return$)
ENDFUNC
DEFFN get_bal(pos%)=-127+(254*pos%)/1000
DEFFN bal_pos(pos%)=(127+pos%)*1000/254
DEFFN get_value=MAX(minval,MIN(maxval,minval+position%*(maxval-minval)/1000))
DEFFN set_position=(value-minval)*1000/(maxval-minval)
FUNCTION suus(seku#)
  IF seku#>0
    RETURN 100/seku#
  ELSE
    RETURN 1
  ENDIF
ENDFUNC
FUNCTION ussu(umdr#)
  IF umdr#>0
    RETURN 1/umdr#*100
  ELSE
    RETURN 1
  ENDIF
ENDFUNC
' ***   Anzeige des eingestellten Wertes in der Graphik  ***
DEFFN voldist(dist%)=MIN(127,MAX(0,(127-SQR(dist%))))
PROCEDURE test
  lfo=0
  ti%=TIMER
  FOR x=1 TO 1000
    lfo_val#(1,lfo)=50*SINQ(lfo_val#(0,lfo)+lfo_param(3,lfo,lfosetup))*lfo_param(4,lfo,lfosetup)/100+lfo_param(5,lfo,lfosetup)
  NEXT x
  PRINT TIMER-ti%
  ti%=TIMER
  FOR x=1 TO 1000
    lfo_val#(1,lfo)=((lfo_val#(0,lfo)+90+lfo_param(3,lfo,lfosetup)) MOD 360)/3.59
    IF lfo_val#(1,lfo)<=50
      ' aufsteigend bis 50
      lfo_val#(1,lfo)=lfo_val#(1,lfo)*2-50
    ELSE
      ' absteigend ab 51
      lfo_val#(1,lfo)=150-lfo_val#(1,lfo)*2
    ENDIF
  NEXT x
  PRINT TIMER-ti%
  ti%=TIMER
  FOR x=1 TO 1000
    lfo_val#(1,lfo)=koor(0,(360+(lfo_param(1,lfo,lfosetup)+lfo_param(3,lfo,lfosetup)) MOD 360))*lfo_param(4,lfo,lfosetup)/100+lfo_param(5,lfo,lfosetup)
  NEXT x
  PRINT TIMER-ti%
RETURN
PROCEDURE mtctest
  FOR qframes%=1 TO 1000
    full!=FALSE
    nzeit(qframes%/4)
    send_timec
    PAUSE a
  NEXT qframes%
RETURN
' * Erweiterte MIDI Port UnterstÅtzung *
' * Systemdeklarationen *
PROCEDURE declaration
  null%=0
  eins%=1
  midi%=3
  bufdev%=2
  bconstat%=eins%
  bconin%=bufdev%
  bconout%=midi%
  midiws%=12
  iorec%=14
  maxbyte%=255
  sizeoffset%=4
  nxtoffset%=6
  minchn%=eins%
  maxchn%=16
  minnte%=null%
  maxnte%=127
  maxbufsize%=50000
  LET switchoffset%=64
  '
  ' * MIDI Konstanten *
  '
  nte_on%=&H8F
  nte_off%=&H7F
  all_ntes_off%=&HAF
  locl%=all_ntes_off%
  midimode%=all_ntes_off%
  ctrl_chnge%=all_ntes_off%
  prg_chnge%=&HBF
  ptchbnd%=&HDF
  poly_aftertch%=&H9F
  chn_aftertch%=&HCF
  midireset%=maxbyte%
  tune_req%=&HF6
  actv_sense%=&HFE
  midiclock%=&HF8
  start_clk%=&HFA
  stp_clk%=&HFC
  cnt_clk%=&HFB
  sys_ex%=&HF0
  eox%=&HF7
  sng_pos%=&HF2
  sng_sel%=&HF3
  '
  ' * System Exclusiv ID's (Nur die wichtigsten!) *
  '
  sequential=1
  moog=4
  lexicon=6
  kurzweil=7
  ensoniq=15
  oberheim=16
  simmons=18
  fairlight=20
  hohner=36
  crumar=37
  kawai=64
  roland=65
  korg=66
  yamaha=67
  casio=68
  akai=71
RETURN
' DEFFN midi_stat=BIOS(bconstat%,midi%) ! MIDI Status checken...
PROCEDURE midi_init(buffersize) ! MIDI Kommunikation initialisieren...
  @declaration
  IF buffersize>32000
    buffersize=32000
  ENDIF
  midipar%=XBIOS(14,2)
  oldmidibuf%=LPEEK(midipar%)
  oldmidisize%=DPEEK(midipar%+4)
  DIM temp%(buffersize/4)
  SLPOKE midipar%,VARPTR(temp%(1))
  SDPOKE midipar%+4,buffersize
  SLPOKE midipar%+6,0
  midi_flushl
RETURN
PROCEDURE midi_end ! MIDI Kommunikation beenden...
  SDPOKE midipar%+4,oldmidisize%
  SLPOKE midipar%+6,0
  SLPOKE midipar%,oldmidibuf%
  SLPOKE midipar%+6,0
  ERASE temp%()
  @midi_flushl
RETURN
PROCEDURE midi_flushl ! Bufferinhalt verwerfen und Status auf Null setzen...
  WHILE BIOS(bconstat%,midi%)
    VOID BIOS(bconin%,midi%)
  WEND
RETURN
PROCEDURE get_status(val%)
  IF val% AND &H80 THEN
    status%=val% AND &HF0
    chn%=(val% AND 15)+eins%
  ELSE
    status%=null%
  ENDIF
RETURN
PROCEDURE midimon
  DO
    IF BIOS(1,3)
      PRINT HEX$(INP(3),2)+"  ";
    ENDIF
  LOOP
RETURN
PROCEDURE rscnotfound
  LOCAL x
  ALERT 1,"REALTIME3.RSC|nicht gefunden!",1,"Abbruch",x
  END
RETURN
PROCEDURE init_hnumbers
  REM Resource Datei Indizes fÅr REALTIM3
  LET desktop=0 ! Formular/Dialog
  LET deskver=2 ! BOXTEXT in Baum DESKTOP
  LET deskdat=3 ! BOXTEXT in Baum DESKTOP
  LET deskeven=5 ! FBOXTEXT in Baum DESKTOP
  LET rtmschr=6 ! IMAGE in Baum DESKTOP
  LET hauptmen=1 ! Menuebaum
  LET copyr=11 ! STRING in Baum HAUPTMEN
  LET dloadsav=18 ! STRING in Baum HAUPTMEN
  LET mladen=20 ! STRING in Baum HAUPTMEN
  LET mmerge=21 ! STRING in Baum HAUPTMEN
  LET msave=22 ! STRING in Baum HAUPTMEN
  LET ende=24 ! STRING in Baum HAUPTMEN
  LET mende=25 ! STRING in Baum HAUPTMEN
  LET mexporte=27 ! STRING in Baum HAUPTMEN
  LET mmidiin=29 ! STRING in Baum HAUPTMEN
  LET mvolres=31 ! STRING in Baum HAUPTMEN
  LET mvolausg=32 ! STRING in Baum HAUPTMEN
  LET m3ded=33 ! BOX in Baum HAUPTMEN
  LET m3dedit=34 ! STRING in Baum HAUPTMEN
  LET m2dedit=35 ! STRING in Baum HAUPTMEN
  LET meventue=36 ! STRING in Baum HAUPTMEN
  LET mlinie3d=38 ! STRING in Baum HAUPTMEN
  LET mfaden3d=39 ! STRING in Baum HAUPTMEN
  LET mgrafikm=40 ! STRING in Baum HAUPTMEN
  LET mkooranz=42 ! STRING in Baum HAUPTMEN
  LET mmauszoo=44 ! STRING in Baum HAUPTMEN
  LET minnenra=45 ! STRING in Baum HAUPTMEN
  LET mquant=47 ! STRING in Baum HAUPTMEN
  LET mrecordp=48 ! STRING in Baum HAUPTMEN
  LET mevueamp=50 ! STRING in Baum HAUPTMEN
  LET mevuebre=51 ! STRING in Baum HAUPTMEN
  LET msperre=52 ! STRING in Baum HAUPTMEN
  LET minp3=53 ! BOX in Baum HAUPTMEN
  LET mgeneset=54 ! STRING in Baum HAUPTMEN
  LET mrotalle=56 ! STRING in Baum HAUPTMEN
  LET minputs=57 ! STRING in Baum HAUPTMEN
  LET mlfopar0=58 ! STRING in Baum HAUPTMEN
  LET mlfopar1=59 ! STRING in Baum HAUPTMEN
  LET minpchan=61 ! STRING in Baum HAUPTMEN
  LET minternt=62 ! STRING in Baum HAUPTMEN
  LET mpankano=64 ! STRING in Baum HAUPTMEN
  LET mgesdreh=65 ! STRING in Baum HAUPTMEN
  LET mmausext=66 ! STRING in Baum HAUPTMEN
  LET mueberbl=68 ! STRING in Baum HAUPTMEN
  LET mbalance=69 ! STRING in Baum HAUPTMEN
  LET mperiode=71 ! STRING in Baum HAUPTMEN
  LET mwiederh=72 ! STRING in Baum HAUPTMEN
  LET mipuffer=74 ! STRING in Baum HAUPTMEN
  LET dinppara=2 ! Formular/Dialog
  LET ip1=7 ! BOXTEXT in Baum DINPPARA
  LET ipspiex1=8 ! BOXTEXT in Baum DINPPARA
  LET ipspiey1=9 ! BOXTEXT in Baum DINPPARA
  LET ipspiez1=10 ! BOXTEXT in Baum DINPPARA
  LET ipverxy1=11 ! BOXTEXT in Baum DINPPARA
  LET ipverxz1=12 ! BOXTEXT in Baum DINPPARA
  LET ipveryz1=13 ! BOXTEXT in Baum DINPPARA
  LET ipdecs1=14 ! BOXTEXT in Baum DINPPARA
  LET ipincs1=15 ! BOXTEXT in Baum DINPPARA
  LET ipsetup1=16 ! FBOXTEXT in Baum DINPPARA
  LET ipdrehx1=17 ! FBOXTEXT in Baum DINPPARA
  LET ipdrehy1=18 ! FBOXTEXT in Baum DINPPARA
  LET ipdrehz1=19 ! FBOXTEXT in Baum DINPPARA
  LET ipoffsx1=20 ! FBOXTEXT in Baum DINPPARA
  LET ipoffsy1=21 ! FBOXTEXT in Baum DINPPARA
  LET ipoffsz1=22 ! FBOXTEXT in Baum DINPPARA
  LET ipausg1=23 ! BOXTEXT in Baum DINPPARA
  LET ip2=25 ! BOXTEXT in Baum DINPPARA
  LET ip3=43 ! BOXTEXT in Baum DINPPARA
  LET ip4=61 ! BOXTEXT in Baum DINPPARA
  LET ip5=79 ! BOXTEXT in Baum DINPPARA
  LET ip6=97 ! BOXTEXT in Baum DINPPARA
  LET ip7=115 ! BOXTEXT in Baum DINPPARA
  LET ip8=133 ! BOXTEXT in Baum DINPPARA
  LET ipmtrdop=150 ! BUTTON in Baum DINPPARA
  LET ipmausmo=152 ! BOXTEXT in Baum DINPPARA
  LET ipende=153 ! BUTTON in Baum DINPPARA
  LET ipstore=155 ! BUTTON in Baum DINPPARA
  LET iprecall=156 ! BUTTON in Baum DINPPARA
  LET ipspidec=157 ! BOXTEXT in Baum DINPPARA
  LET ipspinr=158 ! FBOXTEXT in Baum DINPPARA
  LET ipspiinc=159 ! BOXTEXT in Baum DINPPARA
  LET dparam=3 ! Formular/Dialog
  LET dpareing=1 ! BOXTEXT in Baum DPARAM
  LET dpinc=2 ! BUTTON in Baum DPARAM
  LET dpdec=3 ! BUTTON in Baum DPARAM
  LET dpabbr=4 ! BUTTON in Baum DPARAM
  LET dpok=5 ! BUTTON in Baum DPARAM
  LET dpslbox=6 ! BOX in Baum DPARAM
  LET dpslide=7 ! BOXTEXT in Baum DPARAM
  LET dpwert=8 ! FBOXTEXT in Baum DPARAM
  LET dpminval=9 ! BOXTEXT in Baum DPARAM
  LET dpmaxval=10 ! BOXTEXT in Baum DPARAM
  LET dtext=4 ! Formular/Dialog
  LET dtname=1 ! BOXTEXT in Baum DTEXT
  LET dtabbr=2 ! BUTTON in Baum DTEXT
  LET dtok=3 ! BUTTON in Baum DTEXT
  LET dttext=4 ! FTEXT in Baum DTEXT
  LET dgespara=5 ! Formular/Dialog
  LET dgtitle=1 ! BOXTEXT in Baum DGESPARA
  LET dgvertxy=2 ! BUTTON in Baum DGESPARA
  LET dgvertxz=3 ! BUTTON in Baum DGESPARA
  LET dgvertyz=4 ! BUTTON in Baum DGESPARA
  LET dgdrehx=5 ! FBOXTEXT in Baum DGESPARA
  LET dgok=6 ! BUTTON in Baum DGESPARA
  LET dgdrehy=7 ! FBOXTEXT in Baum DGESPARA
  LET dgdrehz=8 ! FBOXTEXT in Baum DGESPARA
  LET dgdec=9 ! BUTTON in Baum DGESPARA
  LET dginc=10 ! BUTTON in Baum DGESPARA
  LET dgsetup=11 ! FBOXTEXT in Baum DGESPARA
  LET dgvert0=16 ! BUTTON in Baum DGESPARA
  LET dbalance=6 ! Formular/Dialog
  LET dbslblr=2 ! BOX in Baum DBALANCE
  LET dbslilr=3 ! BOXTEXT in Baum DBALANCE
  LET dbslbvh=6 ! BOX in Baum DBALANCE
  LET dbslivh=7 ! BOXTEXT in Baum DBALANCE
  LET dbslbou=10 ! BOX in Baum DBALANCE
  LET dbsliou=11 ! BOXTEXT in Baum DBALANCE
  LET dbabbr=14 ! BUTTON in Baum DBALANCE
  LET dbok=15 ! BUTTON in Baum DBALANCE
  LET dbslb78=24 ! BOX in Baum DBALANCE
  LET dbsli78=25 ! BOXTEXT in Baum DBALANCE
  LET dbslb56=26 ! BOX in Baum DBALANCE
  LET dbsli56=27 ! BOXTEXT in Baum DBALANCE
  LET dbslb34=28 ! BOX in Baum DBALANCE
  LET dbsli34=29 ! BOXTEXT in Baum DBALANCE
  LET dbslb12=30 ! BOX in Baum DBALANCE
  LET dbsli12=31 ! BOXTEXT in Baum DBALANCE
  LET dbvol1=32 ! BOXTEXT in Baum DBALANCE
  LET dbvol2=33 ! BOXTEXT in Baum DBALANCE
  LET dbvol4=34 ! BOXTEXT in Baum DBALANCE
  LET dbvol6=35 ! BOXTEXT in Baum DBALANCE
  LET dbvol8=36 ! BOXTEXT in Baum DBALANCE
  LET dbvol3=37 ! BOXTEXT in Baum DBALANCE
  LET dbvol5=38 ! BOXTEXT in Baum DBALANCE
  LET dbvol7=39 ! BOXTEXT in Baum DBALANCE
  LET dbreset=40 ! BUTTON in Baum DBALANCE
  LET dlfos=7 ! Formular/Dialog
  LET lfo1=12 ! BOX in Baum DLFOS
  LET lf1=13 ! BOXTEXT in Baum DLFOS
  LET lf1quell=14 ! BOXTEXT in Baum DLFOS
  LET lf1ctin=15 ! BOXTEXT in Baum DLFOS
  LET lf1speed=16 ! FTEXT in Baum DLFOS
  LET lf1phase=17 ! FTEXT in Baum DLFOS
  LET lf1ampl=18 ! FTEXT in Baum DLFOS
  LET lf1offs=19 ! FTEXT in Baum DLFOS
  LET lf1pauso=20 ! FTEXT in Baum DLFOS
  LET lf1pausu=21 ! FTEXT in Baum DLFOS
  LET lf1ctout=22 ! BOXTEXT in Baum DLFOS
  LET lf2=24 ! BOXTEXT in Baum DLFOS
  LET lf8=79 ! BOXTEXT in Baum DLFOS
  LET lf8ctout=88 ! BOXTEXT in Baum DLFOS
  LET lf9=90 ! BOXTEXT in Baum DLFOS
  LET lf10=101 ! BOXTEXT in Baum DLFOS
  LET lf11=112 ! BOXTEXT in Baum DLFOS
  LET lf12=123 ! BOXTEXT in Baum DLFOS
  LET lfcctout=132 ! BOXTEXT in Baum DLFOS
  LET lfstbas=150 ! BOXTEXT in Baum DLFOS
  LET lfbr12=151 ! FTEXT in Baum DLFOS
  LET lfbr34=152 ! FTEXT in Baum DLFOS
  LET lfbr56=153 ! FTEXT in Baum DLFOS
  LET lfpanpo=155 ! BOXTEXT in Baum DLFOS
  LET lfpan12=156 ! FTEXT in Baum DLFOS
  LET lfmtrspd=160 ! BOXTEXT in Baum DLFOS
  LET lfmtr1=161 ! FTEXT in Baum DLFOS
  LET lfvolume=169 ! BOXTEXT in Baum DLFOS
  LET lfvol1=170 ! FTEXT in Baum DLFOS
  LET lfzoom=178 ! BOXTEXT in Baum DLFOS
  LET lfzoom1=179 ! FTEXT in Baum DLFOS
  LET lffreew=187 ! BOXTEXT in Baum DLFOS
  LET lffree1=188 ! FTEXT in Baum DLFOS
  LET lfposx=196 ! BOXTEXT in Baum DLFOS
  LET lfposx1=197 ! FTEXT in Baum DLFOS
  LET lfposy=205 ! BOXTEXT in Baum DLFOS
  LET lfposy1=206 ! FTEXT in Baum DLFOS
  LET lfposz=214 ! BOXTEXT in Baum DLFOS
  LET lfposz1=215 ! FTEXT in Baum DLFOS
  LET lfmtrpos=223 ! BOXTEXT in Baum DLFOS
  LET lfmtrpo1=224 ! FTEXT in Baum DLFOS
  LET lftitle=232 ! BOXTEXT in Baum DLFOS
  LET lfsetdec=234 ! BUTTON in Baum DLFOS
  LET lfsetnr=235 ! FBOXTEXT in Baum DLFOS
  LET lfsetinc=236 ! BUTTON in Baum DLFOS
  LET lfstore=237 ! BUTTON in Baum DLFOS
  LET lfrecall=238 ! BUTTON in Baum DLFOS
  LET lfok=239 ! BUTTON in Baum DLFOS
  LET dlfoquel=8 ! Formular/Dialog
  LET dlfqaus=1 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqmaux=2 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqmauy=3 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqmidi=4 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqrand=5 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqpitc=6 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqsin=7 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqstri=8 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqsawu=9 ! BOXTEXT in Baum DLFOQUEL
  LET dlfqsawd=10 ! BOXTEXT in Baum DLFOQUEL
  LET dlfoqsqr=11 ! BOXTEXT in Baum DLFOQUEL
  LET dlfosel=9 ! Formular/Dialog
  LET dlfo0=1 ! BOXTEXT in Baum DLFOSEL
  LET dlfo1=2 ! BOXTEXT in Baum DLFOSEL
  LET dlfo2=3 ! BOXTEXT in Baum DLFOSEL
  LET dmidi=10 ! Formular/Dialog
  LET dmsstart=4 ! BUTTON in Baum DMIDI
  LET dmsstop=5 ! BUTTON in Baum DMIDI
  LET dmstimec=6 ! BUTTON in Baum DMIDI
  LET dmstimes=7 ! FBOXTEXT in Baum DMIDI
  LET dmspchpr=8 ! BUTTON in Baum DMIDI
  LET dmikanal=9 ! FBOXTEXT in Baum DMIDI
  LET dmsmaus=10 ! BUTTON in Baum DMIDI
  LET dmostart=13 ! BUTTON in Baum DMIDI
  LET dmostop=14 ! BUTTON in Baum DMIDI
  LET dmotimec=15 ! BUTTON in Baum DMIDI
  LET dmotimes=16 ! FBOXTEXT in Baum DMIDI
  LET dmokanal=17 ! FBOXTEXT in Baum DMIDI
  LET dmnoteof=18 ! BUTTON in Baum DMIDI
  LET dmomaus=19 ! BUTTON in Baum DMIDI
  LET dmabbr=20 ! BUTTON in Baum DMIDI
  LET dmok=21 ! BUTTON in Baum DMIDI
  LET dallrot=11 ! Formular/Dialog
  LET dasinus=3 ! BOXTEXT in Baum DALLROT
  LET datriang=4 ! BOXTEXT in Baum DALLROT
  LET dadir1=22 ! BOX in Baum DALLROT
  LET daebene1=23 ! BOXTEXT in Baum DALLROT
  LET daricht1=24 ! BOXTEXT in Baum DALLROT
  LET damodus1=25 ! BOXTEXT in Baum DALLROT
  LET dawink1=26 ! FBOXTEXT in Baum DALLROT
  LET dausek1=27 ! FBOXTEXT in Baum DALLROT
  LET dasekum1=28 ! FBOXTEXT in Baum DALLROT
  LET daphase1=29 ! FBOXTEXT in Baum DALLROT
  LET dadir2=30 ! BOX in Baum DALLROT
  LET dastore=87 ! BUTTON in Baum DALLROT
  LET darecall=88 ! BUTTON in Baum DALLROT
  LET damtrdec=89 ! BOXTEXT in Baum DALLROT
  LET damtrnr=90 ! FBOXTEXT in Baum DALLROT
  LET damtrinc=91 ! BOXTEXT in Baum DALLROT
  LET daok=92 ! BUTTON in Baum DALLROT
  LET droteben=12 ! Formular/Dialog
  LET drotrich=13 ! Formular/Dialog
  LET rotlinks=1 ! BOXTEXT in Baum DROTRICH
  LET rotstop=2 ! BOXTEXT in Baum DROTRICH
  LET rotrecht=3 ! BOXTEXT in Baum DROTRICH
  LET drotmod=14 ! Formular/Dialog
  LET rotautos=1 ! BOXTEXT in Baum DROTMOD
  LET rotpend=2 ! BOXTEXT in Baum DROTMOD
  LET rotdurch=3 ! BOXTEXT in Baum DROTMOD
  LET dzahl=15 ! Formular/Dialog
  LET dzzahl=1 ! FTEXT in Baum DZAHL
  LET dcminput=16 ! Formular/Dialog
  LET inpchtit=1 ! BOXTEXT in Baum DCMINPUT
  LET dcok=2 ! BUTTON in Baum DCMINPUT
  LET dcsig1=6 ! BOXTEXT in Baum DCMINPUT
  LET dcsig2=7 ! BOXTEXT in Baum DCMINPUT
  LET dcsig3=8 ! BOXTEXT in Baum DCMINPUT
  LET dcsig4=9 ! BOXTEXT in Baum DCMINPUT
  LET dcsig5=10 ! BOXTEXT in Baum DCMINPUT
  LET dcsig6=11 ! BOXTEXT in Baum DCMINPUT
  LET dcsig7=12 ! BOXTEXT in Baum DCMINPUT
  LET dcsig8=13 ! BOXTEXT in Baum DCMINPUT
  LET dcinp1=16 ! BOXTEXT in Baum DCMINPUT
  LET dcinp2=17 ! BOXTEXT in Baum DCMINPUT
  LET dcinp3=18 ! BOXTEXT in Baum DCMINPUT
  LET dcinp4=19 ! BOXTEXT in Baum DCMINPUT
  LET dcinp5=20 ! BOXTEXT in Baum DCMINPUT
  LET dcinp6=21 ! BOXTEXT in Baum DCMINPUT
  LET dcinp7=22 ! BOXTEXT in Baum DCMINPUT
  LET dcinp8=23 ! BOXTEXT in Baum DCMINPUT
  LET inpchdec=25 ! BUTTON in Baum DCMINPUT
  LET inpchanr=26 ! FBOXTEXT in Baum DCMINPUT
  LET inpchinc=27 ! BUTTON in Baum DCMINPUT
  LET dcstore=28 ! BUTTON in Baum DCMINPUT
  LET dcrecall=29 ! BUTTON in Baum DCMINPUT
  LET dinput=17 ! Formular/Dialog
  LET dinp1=1 ! BOXTEXT in Baum DINPUT
  LET dinp2=2 ! BOXTEXT in Baum DINPUT
  LET dinp9=9 ! BOXTEXT in Baum DINPUT
  LET dinp32=32 ! BOXTEXT in Baum DINPUT
  LET dinp64=64 ! BOXTEXT in Baum DINPUT
  LET daktstat=18 ! Formular/Dialog
  LET dxakttxt=1 ! BOXTEXT in Baum DAKTSTAT
  LET drecordp=19 ! Formular/Dialog
  LET drectext=1 ! BOXTEXT in Baum DRECORDP
  LET drec=3 ! BOXTEXT in Baum DRECORDP
  LET drec1=4 ! BOXTEXT in Baum DRECORDP
  LET drec2=5 ! BOXTEXT in Baum DRECORDP
  LET drec8=11 ! BOXTEXT in Baum DRECORDP
  LET drecx=13 ! BOXTEXT in Baum DRECORDP
  LET drecx1=14 ! BOXTEXT in Baum DRECORDP
  LET drecx2=15 ! BOXTEXT in Baum DRECORDP
  LET drecx8=21 ! BOXTEXT in Baum DRECORDP
  LET drecy=23 ! BOXTEXT in Baum DRECORDP
  LET drecy1=24 ! BOXTEXT in Baum DRECORDP
  LET drecy2=25 ! BOXTEXT in Baum DRECORDP
  LET drecy8=31 ! BOXTEXT in Baum DRECORDP
  LET drecz=33 ! BOXTEXT in Baum DRECORDP
  LET drecz1=34 ! BOXTEXT in Baum DRECORDP
  LET drecz2=35 ! BOXTEXT in Baum DRECORDP
  LET drecvol=43 ! BOXTEXT in Baum DRECORDP
  LET drecvol1=44 ! BOXTEXT in Baum DRECORDP
  LET drecvol2=45 ! BOXTEXT in Baum DRECORDP
  LET drecvol8=51 ! BOXTEXT in Baum DRECORDP
  LET dreczoom=53 ! BOXTEXT in Baum DRECORDP
  LET dreczoo2=55 ! BOXTEXT in Baum DRECORDP
  LET dreczoo8=61 ! BOXTEXT in Baum DRECORDP
  LET dreccyc=63 ! BOXTEXT in Baum DRECORDP
  LET dreccyc1=64 ! BOXTEXT in Baum DRECORDP
  LET dreccyc2=65 ! BOXTEXT in Baum DRECORDP
  LET dreccyc8=71 ! BOXTEXT in Baum DRECORDP
  LET drecover=73 ! BOXTEXT in Baum DRECORDP
  LET drecov1=74 ! BOXTEXT in Baum DRECORDP
  LET drecov2=75 ! BOXTEXT in Baum DRECORDP
  LET drecov8=81 ! BOXTEXT in Baum DRECORDP
  LET drecok=82 ! BUTTON in Baum DRECORDP
  LET dgenset=20 ! Formular/Dialog
  LET gensetit=1 ! BOXTEXT in Baum DGENSET
  LET gensemtr=3 ! FBOXTEXT in Baum DGENSET
  LET gensespi=4 ! FBOXTEXT in Baum DGENSET
  LET genselfo=5 ! FBOXTEXT in Baum DGENSET
  LET genseich=6 ! FBOXTEXT in Baum DGENSET
  LET gensesig=7 ! FBOXTEXT in Baum DGENSET
  LET genrelmt=8 ! FBOXTEXT in Baum DGENSET
  LET genseok=9 ! BUTTON in Baum DGENSET
  LET gensedec=11 ! BUTTON in Baum DGENSET
  LET gensenum=12 ! FBOXTEXT in Baum DGENSET
  LET genseinc=13 ! BUTTON in Baum DGENSET
  LET genstore=14 ! BUTTON in Baum DGENSET
  LET genrecal=15 ! BUTTON in Baum DGENSET
  LET dsaveloa=21 ! Formular/Dialog
  LET genserec=0 ! BOX in Baum DSAVELOA
  LET dlstitel=1 ! BOXTEXT in Baum DSAVELOA
  LET dls3dneu=2 ! BOXTEXT in Baum DSAVELOA
  LET dls3dalt=3 ! BOXTEXT in Baum DSAVELOA
  LET dlsmulti=4 ! BOXTEXT in Baum DSAVELOA
  LET dlslfose=5 ! BOXTEXT in Baum DSAVELOA
  LET dlsinpch=6 ! BOXTEXT in Baum DSAVELOA
  LET dlsgense=7 ! BOXTEXT in Baum DSAVELOA
  LET dlssigta=8 ! BOXTEXT in Baum DSAVELOA
  LET dlsallse=9 ! BOXTEXT in Baum DSAVELOA
  LET dlshand=10 ! BOXTEXT in Baum DSAVELOA
  LET dlsabbr=11 ! BOXTEXT in Baum DSAVELOA
  LET dsigtau=22 ! Formular/Dialog
  LET sigtitel=1 ! BOXTEXT in Baum DSIGTAU
  LET diok=2 ! BUTTON in Baum DSIGTAU
  LET disig1=6 ! BOXTEXT in Baum DSIGTAU
  LET disig2=7 ! BOXTEXT in Baum DSIGTAU
  LET disig8=13 ! BOXTEXT in Baum DSIGTAU
  LET diout1=16 ! BOXTEXT in Baum DSIGTAU
  LET diout2=17 ! BOXTEXT in Baum DSIGTAU
  LET diout8=23 ! BOXTEXT in Baum DSIGTAU
  LET direcall=25 ! BUTTON in Baum DSIGTAU
  LET distore=26 ! BUTTON in Baum DSIGTAU
  LET sigdec=27 ! BUTTON in Baum DSIGTAU
  LET signumm=28 ! FBOXTEXT in Baum DSIGTAU
  LET siginc=29 ! BUTTON in Baum DSIGTAU
  LET dsignal=23 ! Formular/Dialog
  LET dsig1=1 ! BOXTEXT in Baum DSIGNAL
  LET dsig2=2 ! BOXTEXT in Baum DSIGNAL
  LET dsig8=8 ! BOXTEXT in Baum DSIGNAL
  LET dgrafikm=24 ! Formular/Dialog
  LET dgmtitel=1 ! BOXTEXT in Baum DGRAFIKM
  LET dgmsingl=3 ! BOXTEXT in Baum DGRAFIKM
  LET dgm12pan=4 ! BOXTEXT in Baum DGRAFIKM
  LET dgmquad=5 ! BOXTEXT in Baum DGRAFIKM
  LET dgmaus=6 ! BOXTEXT in Baum DGRAFIKM
  LET dparaman=25 ! Formular/Dialog
  LET anztitel=1 ! BOXTEXT in Baum DPARAMAN
  LET anzpanpo=2 ! BOXTEXT in Baum DPARAMAN
  LET anzpanbr=3 ! BOXTEXT in Baum DPARAMAN
  LET anzmtrsp=4 ! BOXTEXT in Baum DPARAMAN
  LET anzvorun=5 ! BOXTEXT in Baum DPARAMAN
  LET anzvol=6 ! BOXTEXT in Baum DPARAMAN
  LET anzxyz=7 ! BOXTEXT in Baum DPARAMAN
  LET anzzoom=8 ! BOXTEXT in Baum DPARAMAN
  LET anzcount=9 ! BOXTEXT in Baum DPARAMAN
  LET anzzeit=10 ! BOXTEXT in Baum DPARAMAN
  LET anzok=11 ! BUTTON in Baum DPARAMAN
  LET dpresets=26 ! Formular/Dialog
  LET presgen=2 ! BOXTEXT in Baum DPRESETS
  LET presmtr=4 ! BOXTEXT in Baum DPRESETS
  LET presspi=6 ! BOXTEXT in Baum DPRESETS
  LET presinp=8 ! BOXTEXT in Baum DPRESETS
  LET presitt=10 ! BOXTEXT in Baum DPRESETS
  LET preslfo1=12 ! BOXTEXT in Baum DPRESETS
  LET preslfo2=14 ! BOXTEXT in Baum DPRESETS
  LET dmausmod=27 ! Formular/Dialog
  LET dmausmo0=1 ! BOXTEXT in Baum DMAUSMOD
  LET dmausmo1=2 ! BOXTEXT in Baum DMAUSMOD
  LET dmausmo2=3 ! BOXTEXT in Baum DMAUSMOD
RETURN
